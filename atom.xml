<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>WEBSITE</title>
  
  
  <link href="https://ycy666666.github.io/atom.xml" rel="self"/>
  
  <link href="https://ycy666666.github.io/"/>
  <updated>2023-07-20T14:54:20.070Z</updated>
  <id>https://ycy666666.github.io/</id>
  
  <author>
    <name>YCY</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>UI框架设计学习</title>
    <link href="https://ycy666666.github.io/2023/07/18/UI%E6%A1%86%E6%9E%B6%E8%AE%BE%E8%AE%A1%E5%AD%A6%E4%B9%A0/"/>
    <id>https://ycy666666.github.io/2023/07/18/UI%E6%A1%86%E6%9E%B6%E8%AE%BE%E8%AE%A1%E5%AD%A6%E4%B9%A0/</id>
    <published>2023-07-18T15:23:12.000Z</published>
    <updated>2023-07-20T14:54:20.070Z</updated>
    
    <content type="html"><![CDATA[<p>如今的项目大多是吸纳了系统开发Lua化, 针对UI的设计开发中的技术问题总结了一部份资料, 以便于自己增加对UI框架的了解, 并在自己今后设计UI框架时有所参考</p><h1 id="UI框架模型"><a href="#UI框架模型" class="headerlink" title="UI框架模型"></a>UI框架模型</h1><p>游戏UI系统需求变更频繁，为了把界面和数据分离，通常把MVC作为架构设计的参考.  MVC有很多的变种，统称为M-V-X，MVX的本质都是一样的，重点在于M-V之间的桥梁，要靠X来牵线。</p><p>简要介绍一些软件架构的概念及优缺点所在。</p><h2 id="M-V-C"><a href="#M-V-C" class="headerlink" title="M-V-C"></a>M-V-C</h2><p>MVC全称是Model View Controller,是模型(model)-视图(view)-控制器(controller)的缩写，一种软件设计范式，用一种把业务逻辑、数据、界面显示分离的方法组织代码，将业务逻辑聚集到Control中，在改变界面及用户交互的时候不需要重新编写业务逻辑。M层专注于数据处理，V层专注于数据显示</p><span id="more"></span><p><img src="/2023/07/18/UI%E6%A1%86%E6%9E%B6%E8%AE%BE%E8%AE%A1%E5%AD%A6%E4%B9%A0/image-20230714115022407-16898575034391.png" alt="image-20230714115022407"></p><p>MVC的一般流程是这样的: View (界面)发事件  —&gt; Controler (业务)处理了业务，然后发了数据更新 —&gt; 更新了Model的数据 —&gt; Model (带着数据)回到了View —&gt; View更新数据。</p><h3 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h3><p>耦合性低，视图层和业务层分离，很容易改变应用程序的数据层和业务规则，</p><p>重用性高，允许使用各种不同样式的视图来访问同一个模型里面的数据，因此多个视图能共享一个模型，分开明确，生命周期低</p><p>分离视图层和业务层使得应用更易于维护和修改</p><h3 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h3><p>数据(M层)是封闭的，如果多模块需要同一个数据块，数据之间的互通和重用性较低;</p><p>在局部实现了内聚，但是局部内的三角关系之间的逻辑糟合还是很深。<img src="/2023/07/18/UI%E6%A1%86%E6%9E%B6%E8%AE%BE%E8%AE%A1%E5%AD%A6%E4%B9%A0/image-20230714143832715.png" alt="image-20230714143832715"></p><p>在这种情况下，MVC的框架不能很好地应对游戏开发。游戏数据是互相依赖的。比如: 角色的属性展示需要用到背包里的装备，背包需要显示货币; 任务依赖角色等级，同时奖励货币和道具、装备等等。在游戏中使用MVC模式，增加了系统结构和实现的复杂性。</p><p>当你需要变化的时候你需要同时维护三个对象和三个交互，这增加了复杂度。</p><h2 id="M-V-P"><a href="#M-V-P" class="headerlink" title="M-V-P"></a>M-V-P</h2><p>MVP对MVC的改进: 切断View和Model的联系，让View只和Presenter交互，减少在需求变化中需要维护的对象的数量。Model的工作是完成对数据的操纵、获取、存储和状态变化的任务，如: 网络请求，持久化数据增删改查等任务。View只处理视图相关，不做任何逻辑处理</p><h3 id><a href="#" class="headerlink" title></a><img src="/2023/07/18/UI%E6%A1%86%E6%9E%B6%E8%AE%BE%E8%AE%A1%E5%AD%A6%E4%B9%A0/image-20230714144545825.png" alt="image-20230714144545825"></h3><h3 id="优点-1"><a href="#优点-1" class="headerlink" title="优点"></a>优点</h3><p>MVP定义了Presenter和View之间的接口，让一些可以根据已有的接口协议去各自分别独立开发，以此去解决界面需求变化频繁的问题。将Model和View解耦，不管哪一方的实现方式发生变化，只要最终和P同步的数据不变，另一方都不需要关心和修改。</p><p>可以进行View的模拟测试，在View和Model之间没有直接依赖，开发者能够借助模拟对象注入测试两者中的任一方</p><h3 id="缺点-1"><a href="#缺点-1" class="headerlink" title="缺点"></a>缺点</h3><p>每一个View都对应一个Presenter，增加了代码的复杂度，会使程序几余。</p><p>大量的View-&gt;Model，Model-&gt;Views的手动同步逻辑，会导致Presenter臃肿，维护困难。当软件复杂的时候，类和文件就特别多，仍然没有解决Model复用的问题。</p><h2 id="M-V-VM"><a href="#M-V-VM" class="headerlink" title="M-V-VM"></a>M-V-VM</h2><p>M-V-VM也就是Model - View - ViewModel模式</p><p><img src="/2023/07/18/UI%E6%A1%86%E6%9E%B6%E8%AE%BE%E8%AE%A1%E5%AD%A6%E4%B9%A0/image-20230714145946608.png" alt="image-20230714145946608"></p><p>ViewModel替代了MVP的Presenter和MVC的Controller，而View和ViewModel间没有了MVP的界面接口，而是直接交互，原本的Presenter和View一对一的关系现在可以变成了ViewModel-View一对多的关系。</p><h3 id="优点-2"><a href="#优点-2" class="headerlink" title="优点"></a>优点</h3><p>通常通过数据绑定 (DataBinding) 的形式实现View和Model之间的关系映射，抛弃了Presenter层的手动关系接口和维护。</p><p>通过数据更新事件方式不需要开发人员手动编写数据处理逻辑，而是自动地双向同步。比起MVP，M-V-VM不仅简化了业务和界面的依赖关系，还优化了数据频繁更新的问题。</p><p>ViewModel一对多的关系，表示Model在一定程度上可以复用了,类和文件的数量和管理上要减轻很多</p><h3 id="缺点-2"><a href="#缺点-2" class="headerlink" title="缺点"></a>缺点</h3><p>数据绑定使得Bug很难被调试，数据绑定使得一个位置的Bug被快速传递到别的位置，要定位出问题的地方比较闲难。</p><p>当一个大的模块Model很大时，为了保证数据的一致性，会长期持有，不释放内存，造成了花费更多的内存。</p><p>数据双向绑定不利于代码重用，客户端最常用的重复利用是View，但是数据双向绑定技术，让一个View绑定了一个Model，不同模块的Model都不同，就不能简单的重用View了</p><h1 id="事件驱动框架模型"><a href="#事件驱动框架模型" class="headerlink" title="事件驱动框架模型"></a>事件驱动框架模型</h1><p>项目框架设计中没有使用DataBinding技术, 而是定制化MVVM技术,采用事件驱动的方式, 在M与V之间靠Event来连接,  最终形成了<code>Model - View - Event - ValueObject</code>的模型</p><p><img src="/2023/07/18/UI%E6%A1%86%E6%9E%B6%E8%AE%BE%E8%AE%A1%E5%AD%A6%E4%B9%A0/image-20230714153612835.png" alt="image-20230714153612835"></p><p>ViewModel被替换成了ValueObject，以便贴近游戏开发。开发过程中有三种情况: </p><p>(1)、View层可以直接访问Model层的数据; </p><p>(2)、ValueObiect对象不能重用，一个ValueObiect对应一个View; </p><p>(3)、ValueObiect对象可以被多个View对象所使用，增加了ValueObject对象的复用，减少了ValueObject对象的数量。</p><p>游戏中的数据来源于两个地方，一部分是服务器，另外一部分是本地化存储。数据来自于服务器，View和Model是查询关系，并不会改变数据，数据的变化只能来自于服务器的协议驱动; 数据来自于本地化，当View要求Model修改数据时，Model会把数据存放在客户端，然后通知View数据进行更新。<strong>界面通过注册事件来订阅指定的事件类型，数据中心通过和服务器之间的交互来获得或者改变数据，并根据需求推送指定的Event。</strong></p><p>当界面关心的事件发生，它有两种可能:一部分是动态变化的局部更新，可以通过事件带下来;另外一种是整体数据需要去数据中心获取. </p><p>举个例子，当打开背包界面的时候，需要知道所有的背包数据，因此View和Model直接交互，拿到背包里所有道具并显示。然后吃掉了一个经验丹，<strong>服务器会告诉客户端删除一个物品，数据层会通过事件触发，背包监听了这个事件，并且查找对应的道具ID，删除，然后对背包道具进行局部重新排列刷新</strong>。</p><p>假设还有一个界面叫做一键升级，可以选择背包内不同种类的经验丹，那么<strong>它打开的时候同样找数据中心获取道具相关的数据用于显示</strong>. 如果这个时候在背包内吃掉一个，那么同样监听了这条消息的一键升级界面也要重现显示数量。</p><h1 id="底层实现"><a href="#底层实现" class="headerlink" title="底层实现"></a>底层实现</h1><p>游戏UI的展示是一个层级结构。例如: 主界面一般会在最下面，而警告框、公告跑马灯和Loading等一般会在上面。其他界面根据功能需求的不同而定，一般来说后打开会在先打开的上面。</p><p>但也有一些层级是固定的，比如:当已经弹出了警告框，但是这个时候服务器推送协议导致打开了邮件界面，也必须要显示在警告框的下面。因此，需要对UI的显示层级做整体规划，确保在任何时候打开的界面都能按照正确的层级显示正确</p><h2 id="UI层级"><a href="#UI层级" class="headerlink" title="UI层级"></a>UI层级</h2><p>可以采用ZOrder来决定同一层级UI的绘制顺序.  从排序函数中可以看出，先按ZOrder进行排序，然后再按子控件位置进行排席。不同的ZOrder，不管子控件的位置如何，都会优先显示ZOrder值比较大的界面。<strong>相同的ZOrder,按子控件的排布位置来显示，在父节点下面位置越靠下，越后绘制</strong>。</p><h3 id="分组管理"><a href="#分组管理" class="headerlink" title="分组管理"></a>分组管理</h3><p>基于<code>CanvasPanel</code>的ZOrder绘制规则，在显示一个界面时，我们只要赋予正确的ZOrder值，便可以正确的显示出来。因此，我们需要对显示层级进行分组管理，在组与组之间预留一定范围的ZOrder值，每一个界面在显示的时候给它指定对应的分组值，能隔离大部分的UI层级显示。</p><p>定义一个枚举值来表示各组Root的名称,  在总的UI Root下都有对应组的root作为各个界面的父物体</p><p><img src="/2023/07/18/UI%E6%A1%86%E6%9E%B6%E8%AE%BE%E8%AE%A1%E5%AD%A6%E4%B9%A0/image-20230714170504932.png" alt="image-20230714170504932"></p><p>已经基本涵盖了游戏功能类型, 在UIManager的显示Api中需要指定一个分组参数, 也就是定义的枚举值</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">UIManager:LuaShowUI</span><span class="params">(uiname, root, bpPath, uiSubKey, paramsTable)</span></span></span><br></pre></td></tr></table></figure><h3 id="ZOrder自动化管理"><a href="#ZOrder自动化管理" class="headerlink" title="ZOrder自动化管理"></a>ZOrder自动化管理</h3><p>即便有了分组, 大量界面由于异步加载使后打开的界面先加载好等一系列原因, 仍有可能导致渲染顺序不符预期. 为此, 在绑定分组枚举与UI根节点绑定时, 会每组预留出十万的ZOrder间隔. 同时组内面板的层级会维护一个永远增长的Order标志, 打开组内界面都+1, 排除掉了加载时间的影响</p><h2 id="栈状态机"><a href="#栈状态机" class="headerlink" title="栈状态机"></a>栈状态机</h2><p>在UI系统开发的过程中，界面之间的跳转是非常常见的，比如:角色界面有一个按钮点击之后需要打开商店界面但是出于降低设备渲染压力等目的，新打开界面的时候需要隐藏前一个打开的界面，而且关闭打开界面的时候，被隐藏的界面需要自动显示出来。</p><p>又比如A和B两个界面是互斥关系，A在打开的情况下，B打开，A要能自动关闭，同理在B打开的时候，打开A，B也要能自动关闭。还有当一个界面打开时，除了主界面，其他界面要全部自动关闭等等。</p><h3 id="显示策略"><a href="#显示策略" class="headerlink" title="显示策略"></a>显示策略</h3><p>目前定义了四种显示类型</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="built_in">enum</span> EWidgetLayerLevel&#123;</span><br><span class="line">    <span class="comment">// UI之间打开相互不影响</span></span><br><span class="line">    Normalwidget,</span><br><span class="line"><span class="comment">// 同层级会替换且保存，关闭时会自动打开上一未手动关闭的UI界面</span></span><br><span class="line">    UISameLevelCachewidget ,</span><br><span class="line"><span class="comment">// 同层级的UI直接替换，同时只存在一个</span></span><br><span class="line">    SameLevelReplacewidget</span><br><span class="line">    <span class="comment">// 关闭显示栈里除第一个以外的其他所有界面</span></span><br><span class="line">    CloseAlIBackKeywidget,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>应用场景:</p><p><code>Normalwidget</code>: 用于主界面中组队, 每日任务等半屏UI,  不影响主界面显示和隐藏</p><p><code>UISameLevelCachewidget</code>: 仓库, 商城, 活动等大部分全屏界面</p><p><code>SameLevelReplacewidget</code>:  战斗场景中的地图, 背包等界面(参考Apex), 他们之间互斥同时只能显示一个</p><p><code>CloseAlIBackKeywidget</code>:  比如遭受攻击时自动关闭除了主界面外的所有界面,  或者装扮界面需要关闭所有其他UI查看效果</p><p>把界面之间的关系独立成显示策略，可以更加方便的管理他们之间的关系，保证整个显示链路完整。同时，如果需<br>要，可以开发其他的显示策略，具有扩展性。</p><h3 id="生命周期管理"><a href="#生命周期管理" class="headerlink" title="生命周期管理"></a>生命周期管理</h3><p>多个界面之间跳转时, 基本的<code>OnUIOpened</code> 和 <code>OnUIClosed</code>已经不能满足需求. </p><p>比如 AB界面都依赖同一模块中的一些数据,  从A跳转到B时, 在B界面进行操作改变了数据.  那么返回到A界面时, 希望有一个触发函数根据最新数据刷新界面.  我们如果再次触发OnInit会导致显示错乱, 而且很容易产生Bug, 有时候我们只是需要刷新一部分. 综上,我们需要提供更多的生命周期触发函数,来满足开发需求</p><p><strong><code>OnUIOpened</code> —&gt; <code>OnShow</code> —&gt; <code>OnHide</code> —&gt; <code>OnUIClosed</code></strong></p><p>对单个界面而言，提供了四个触发函数，在两个界面跳转之间会调用各自的<code>OnShow</code>和<code>OnHide</code>函数。对同一个界面，函数<code>OnUIOpened</code>和<code>OnUIClosed</code>只会调用一次，由其他界面操作导致的界面刷新逻辑函数写在<code>OnShow</code>和<code>OnHide</code>。每个界面的逻辑放到相应的触发函数中由开发人员实现</p><p>对于一些创建开销大的界面, 我们希望内存能够缓存, 因此提供了<code>IsPersistent</code>作为常驻界面的标识, 同时还提供了枚举值(World生命周期与”主世界”保持一致,  Global全局生命周期)标识切换场景时是否删除</p><h2 id="Lua层事件分发与数据绑定"><a href="#Lua层事件分发与数据绑定" class="headerlink" title="Lua层事件分发与数据绑定"></a>Lua层事件分发与数据绑定</h2><p>每一个绑定界面的Lua脚本中, 都有模板函数 <code>GetControlDefine</code>返回绑定控件的数组. </p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">UI_Lobby_Main:GetControlDefine</span><span class="params">()</span></span></span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">        Widgets = &#123;</span><br><span class="line">            &#123;</span><br><span class="line">                Name = <span class="string">&quot;UI_Lobby_MainMenu&quot;</span>,</span><br><span class="line">                Alias = <span class="string">&quot;MainMenu&quot;</span>,</span><br><span class="line">                Handlers = &#123;</span><br><span class="line">                    <span class="comment">-- 子界面向父界面冒泡事件</span></span><br><span class="line">                    [<span class="string">&quot;OnBtnWarehouseClickedPost&quot;</span>] = <span class="built_in">self</span>.OnBtnWarehouseClickedPost</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;,</span><br><span class="line">            &#123;</span><br><span class="line">                Name = <span class="string">&quot;Btn_Activity&quot;</span>,</span><br><span class="line">                Handlers = &#123;</span><br><span class="line">                    <span class="comment">-- 普通按钮点击事件</span></span><br><span class="line">                    [<span class="string">&quot;OnBtnWarehouseClickedPost&quot;</span>] = <span class="built_in">self</span>.OnBtnWarehouseClickedPost</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;,</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>每个绑定项，由三部分组成:“Name”、“Alias”和”Handles”。“Name”是绑定控制的名称; “Alias”是绑定控件的别名，提高代码的可读性，“Handles”绑定C#提供的事件，也可以是Lua层自己扩展定义的冒泡事件。</p><h3 id="Panel内冒泡事件系统"><a href="#Panel内冒泡事件系统" class="headerlink" title="Panel内冒泡事件系统"></a>Panel内冒泡事件系统</h3><p>Lua层提供了一个事件系统, 实现逻辑内聚和控件重用, 避免Lua全局事件阻碍了控件重用, 污染全局空间</p><p>如上述<code>GetControlDefine</code>函数的Handler, 通过事件名称绑定回调函数,  回调函数中携带了发送者和参数列表. 而子界面就可以通过接口 <code>PostMessahe</code>指定事件名称和携带参数(Lua表)进行事件的冒泡发送 </p><h3 id="自定义数据绑定"><a href="#自定义数据绑定" class="headerlink" title="自定义数据绑定"></a>自定义数据绑定</h3><p>Lua可以给表动态添加字段，对于子界面，可以给子界面传递不同的配置参数，以实现功能的定制化. 在模板函数<code>GetControlDefine</code>中定义的每个控件的Lua表存储在子界面的<code>CustomSetting</code>字段上</p><p>实际案例中, Slider支持两种显示形式:</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">SliderDisplayerType = &#123;</span><br><span class="line">    None = <span class="number">0</span>,</span><br><span class="line">    Range = <span class="number">1</span>, <span class="comment">-- 100/150</span></span><br><span class="line">    Percent = <span class="number">2</span>, <span class="comment">-- 30%</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 在使用控件的地方指定显示格式</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">UI_Customize_OperationBoard_C:GetControlDefine</span><span class="params">()</span></span></span><br><span class="line">    <span class="keyword">return</span>&#123;</span><br><span class="line">        Widgets = &#123;</span><br><span class="line">            Name = <span class="string">&quot;UI_Slider_ButtonScale&quot;</span>,</span><br><span class="line">            SliderDisplayerType = SliderDisplayerType.Percent,</span><br><span class="line">            Handlers = &#123;</span><br><span class="line">            &#125;,</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><h1 id="拓展功能"><a href="#拓展功能" class="headerlink" title="拓展功能"></a>拓展功能</h1><h2 id="通用资源栏显示配置"><a href="#通用资源栏显示配置" class="headerlink" title="通用资源栏显示配置"></a>通用资源栏显示配置</h2><p>通用资源栏: 在主界面上方标志着金币, 付费货币, 体力等通用资源的UI栏.  在商城, 充值界面, 排行榜等都有不同的配置, 比如显示哪一部分数据, 点击对应图标之后是否弹窗等</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 0:Hide</span></span><br><span class="line"><span class="comment">-- 1:can pop window</span></span><br><span class="line"><span class="comment">-- 2:cannot pop window</span></span><br><span class="line"><span class="comment">-- ...</span></span><br><span class="line">UICurrencyAction = &#123;</span><br><span class="line">    [UINames.UI_Rank] = <span class="number">0</span>,</span><br><span class="line">    [UINames.UI_Recharge] = <span class="number">1</span>,</span><br><span class="line">    [UINames.UI_Shop] = <span class="number">2</span>,</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 具体实现逻辑</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">UINavigationManager:PrivateRefreshCurrency</span><span class="params">(uiname)</span></span></span><br><span class="line">    <span class="keyword">local</span> UI_Currency_ResourceBarPanel = LuaPanelUtil.GetUI(WindowsDefine.ResourceBarPanel)</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">if</span> UICurrencyAction[uiname] <span class="keyword">then</span></span><br><span class="line">        <span class="keyword">if</span> UICurrencyAction[uiname] == <span class="number">1</span> <span class="keyword">then</span></span><br><span class="line">            UI_Currency_ResourceBarPanel:PanelShowSelf(<span class="literal">true</span>)</span><br><span class="line">        <span class="keyword">elseif</span> UICurrencyAction[uiname] == <span class="number">2</span> <span class="keyword">then</span></span><br><span class="line">            UI_Currency_ResourceBarPanel:PanelShowSelf(<span class="literal">false</span>)</span><br><span class="line">        <span class="keyword">elseif</span> UICurrencyAction[uiname] == <span class="number">0</span> <span class="keyword">then</span></span><br><span class="line">            UI_Currency_ResourceBarPanel:PanelHideSelf()</span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">end</span>            </span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><h2 id="UI动画的管理"><a href="#UI动画的管理" class="headerlink" title="UI动画的管理"></a>UI动画的管理</h2><p>针对同一物体的动画播放,  如果播放时有正在播放中的动画会把前一个动画强制播放到最后一帧.</p><p>此外, 在播放界面进入和退出时,会禁用界面的输入响应而且不能穿透界面,  使用了两个Panel分别控制不能点击穿透和不响应点击事件</p><h2 id="UI循环列表"><a href="#UI循环列表" class="headerlink" title="UI循环列表"></a>UI循环列表</h2><p>循环列表可分为数据对象和显示对象, 由于显示对象可重复利用能极大的减少内存</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;如今的项目大多是吸纳了系统开发Lua化, 针对UI的设计开发中的技术问题总结了一部份资料, 以便于自己增加对UI框架的了解, 并在自己今后设计UI框架时有所参考&lt;/p&gt;
&lt;h1 id=&quot;UI框架模型&quot;&gt;&lt;a href=&quot;#UI框架模型&quot; class=&quot;headerlink&quot; title=&quot;UI框架模型&quot;&gt;&lt;/a&gt;UI框架模型&lt;/h1&gt;&lt;p&gt;游戏UI系统需求变更频繁，为了把界面和数据分离，通常把MVC作为架构设计的参考.  MVC有很多的变种，统称为M-V-X，MVX的本质都是一样的，重点在于M-V之间的桥梁，要靠X来牵线。&lt;/p&gt;
&lt;p&gt;简要介绍一些软件架构的概念及优缺点所在。&lt;/p&gt;
&lt;h2 id=&quot;M-V-C&quot;&gt;&lt;a href=&quot;#M-V-C&quot; class=&quot;headerlink&quot; title=&quot;M-V-C&quot;&gt;&lt;/a&gt;M-V-C&lt;/h2&gt;&lt;p&gt;MVC全称是Model View Controller,是模型(model)-视图(view)-控制器(controller)的缩写，一种软件设计范式，用一种把业务逻辑、数据、界面显示分离的方法组织代码，将业务逻辑聚集到Control中，在改变界面及用户交互的时候不需要重新编写业务逻辑。M层专注于数据处理，V层专注于数据显示&lt;/p&gt;</summary>
    
    
    
    
    <category term="Unity" scheme="https://ycy666666.github.io/tags/Unity/"/>
    
    <category term="lua" scheme="https://ycy666666.github.io/tags/lua/"/>
    
  </entry>
  
  <entry>
    <title>基于lua的红点树实现</title>
    <link href="https://ycy666666.github.io/2023/07/04/%E5%9F%BA%E4%BA%8Elua%E7%9A%84%E7%BA%A2%E7%82%B9%E6%A0%91%E5%AE%9E%E7%8E%B0/"/>
    <id>https://ycy666666.github.io/2023/07/04/%E5%9F%BA%E4%BA%8Elua%E7%9A%84%E7%BA%A2%E7%82%B9%E6%A0%91%E5%AE%9E%E7%8E%B0/</id>
    <published>2023-07-04T15:51:26.000Z</published>
    <updated>2023-07-04T15:52:25.162Z</updated>
    
    <content type="html"><![CDATA[<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>游戏中的红点算是一个极其常用的功能， 可以为玩家提供有效的非强制性引导。目前比较常用的红点一般围绕两种方案，一种是基于业务模块各自实现，另一种是设计一个尽可能通用的模块来管理红点</p><ol><li><p>基于业务模块</p><p>只需要从各个业务模块获取红点的显示数据，红点的生命周期由对应业务模块负责管理。</p><p>此方案可以避免红点陷入复杂的业务逻辑，但缺点也很明显，ui和业务逻辑过于耦合，ui的调整可能会带来代码逻辑上的改动，从而增加了许多重复的工作量，浪费了人力资源。</p></li><li><p>通用型红点模块</p><p>通用型红点模块即红点模块不仅管理红点数据，还需控制和管理所有业务界面的所有红点的生命周期，将之统一收纳进一个尽可能通用、灵活健壮的管理机制当中。</p><p>为了避免界面调整带来的代码调整，我们把红点的显示路径抽离出代码逻辑，以配置文件的形式交由策划去维护。优点是，程序只要实现一次逻辑，界面调整带来的红点改动只需修改配置即可</p></li></ol><h1 id="红点树配置"><a href="#红点树配置" class="headerlink" title="红点树配置"></a>红点树配置</h1><span id="more"></span><h2 id="生成过程"><a href="#生成过程" class="headerlink" title="生成过程"></a>生成过程</h2><p>获得新装备之后，物品所属种类的页面就会出现红点，如果他同时也可升级、熔炼等，其他界面也会出现红点。</p><p><img src="/2023/07/04/%E5%9F%BA%E4%BA%8Elua%E7%9A%84%E7%BA%A2%E7%82%B9%E6%A0%91%E5%AE%9E%E7%8E%B0/image-20230702234024938.png" alt="image-20230702234024938"></p><p><strong>配置过程：</strong></p><p>​    从需求可以看出，一个子红点可能有多个父红点。因此最终的api可定义为AddRedHintItem(key, …)， key为子节点， …为不定数量父节点</p><h1 id="红点树数据设置"><a href="#红点树数据设置" class="headerlink" title="红点树数据设置"></a>红点树数据设置</h1><h2 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h2><p>采用的是将所有红点存储在map中， key为红点名称， value’为红点具体信息。</p><p><img src="/2023/07/04/%E5%9F%BA%E4%BA%8Elua%E7%9A%84%E7%BA%A2%E7%82%B9%E6%A0%91%E5%AE%9E%E7%8E%B0/image-20230702234738411.png" alt="image-20230702234738411"></p><ul><li>selfValue: 该红点自身的值</li><li>parentsArr: 该红点的父节点列表</li><li>childrenArr: 该红点的子节点列表</li><li>cacheValue: 该红点及子节点红点数值之和的缓存值 (为了避免反复取值导致的反复计算)</li></ul><h2 id="红点创建与关联"><a href="#红点创建与关联" class="headerlink" title="红点创建与关联"></a>红点创建与关联</h2><p>要实现之前定义的api——<code>AddRedHintItem（key, ...）</code> , 我们需要期望能够双向关联红点， 也就是能在子红点<code>parentsArr</code>中插入父红点， 父红点<code>childrenArr</code>中插入子红点</p><p><img src="/2023/07/04/%E5%9F%BA%E4%BA%8Elua%E7%9A%84%E7%BA%A2%E7%82%B9%E6%A0%91%E5%AE%9E%E7%8E%B0/image-20230702235642422.png" alt="image-20230702235642422"></p><h2 id><a href="#" class="headerlink" title=" "></a> </h2><p>selfValue为自身红点的值， 以装备为例： 新装备的selfValue为1，尽管背包入口也有红点，当selfValue仍然为0</p><p>cacheValue为当前节点与子节点所有selfValue之和，为了避免反复计算， 将该值存储到cacheValue中</p><p>注意， 如果获得了另一个新装备， 父层红点缓存的cacheValue也就成为错误的旧数据， 因此每次设置红点时需要将父层红点的cacheValue清空</p><p>设置新红点的流程图：</p><p><img src="/2023/07/04/%E5%9F%BA%E4%BA%8Elua%E7%9A%84%E7%BA%A2%E7%82%B9%E6%A0%91%E5%AE%9E%E7%8E%B0/image-20230703001320614.png" alt="image-20230703001320614"></p><h3 id="红点的清除"><a href="#红点的清除" class="headerlink" title="红点的清除"></a>红点的清除</h3><p>当触发点击事件、特定操作使红点消失后，也需要将父层红点缓存清空</p><p>响应事件消费红点流程图：</p><p><img src="/2023/07/04/%E5%9F%BA%E4%BA%8Elua%E7%9A%84%E7%BA%A2%E7%82%B9%E6%A0%91%E5%AE%9E%E7%8E%B0/image-20230703002818876.png" alt="image-20230703002818876"></p><p>同时也可以清除该红点， 比如全部已读、一键领取等功能。主要是递归清除子节点selfValue， 如果为叶子节点那么再清除该节点与父节点的cacheValue</p><p>清除红点流程图</p><p><img src="/2023/07/04/%E5%9F%BA%E4%BA%8Elua%E7%9A%84%E7%BA%A2%E7%82%B9%E6%A0%91%E5%AE%9E%E7%8E%B0/image-20230703003100273.png" alt="image-20230703003100273"></p><h1 id="屏蔽红点树"><a href="#屏蔽红点树" class="headerlink" title="屏蔽红点树"></a>屏蔽红点树</h1><p>假设有如下需求:进入战斗后，不显示背包系统红点;当战斗结束后，再显示背包系统红点</p><p>上述需求，可以拆为以下步骤</p><ol><li>当进入战斗，设置一个屏蔽key，并通知红点需要刷新;</li><li>计算红点数值时，检测红点是否被屏蔽，若被屏蔽则不计算</li><li>当退出战斗，关闭屏蔽key，并通知红点需要刷新</li><li>重复步骤2</li></ol><h2 id="屏蔽流程"><a href="#屏蔽流程" class="headerlink" title="屏蔽流程"></a>屏蔽流程</h2><p>进入战斗的屏蔽key定义为”battleBlock”，背包入口的红点key为”equipRoot”<br>那么红点屏蔽可配置为:</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">RedHintBlockDefine = &#123;</span><br><span class="line">    battleBlock = &#123;<span class="string">&quot;equipRoot&quot;</span>,&#125;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>尽管有了红点屏蔽的设置，但我们依然无法快速得知该红点是否被屏蔽。我们更希望拿到的是，红点是受哪些blockKey的影响。即，我们希望转义得到:</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">RedHintBlockDefine = &#123;</span><br><span class="line">    equipRoot = &#123;<span class="string">&quot;battleBlock&quot;</span>,&#125;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>另外，游戏逻辑中可能会同时开启多个红点屏蔽key，所以，我们选择位运算的方式，将多个屏蔽key存到一个number字段中。 (例如，有屏蔽a和屏蔽b。当只有a开启屏蔽时，屏蔽值为1&lt;&lt;0;当只有b开启屏蔽时，屏蔽值为1&lt;&lt;1;当a和b都开启屏蔽时，二者取并集)</p><p><strong>初始化红点屏蔽列表的流程图如下图所示</strong></p><p><img src="/2023/07/04/%E5%9F%BA%E4%BA%8Elua%E7%9A%84%E7%BA%A2%E7%82%B9%E6%A0%91%E5%AE%9E%E7%8E%B0/image-20230704230010856.png" alt="image-20230704230010856"></p><p>在上述流程中，屏蔽key已对应成1左移n位的数字表述。那么，开启和关闭屏蔽红点就可以的表述为简单的位运算即可</p><p><strong>设置红点屏蔽的流程图如下图所示</strong></p><p><img src="/2023/07/04/%E5%9F%BA%E4%BA%8Elua%E7%9A%84%E7%BA%A2%E7%82%B9%E6%A0%91%E5%AE%9E%E7%8E%B0/image-20230704230418408.png" alt="image-20230704230418408"></p><p>在配置转义后，我们可以知道该红点收到了哪些屏蔽key的影响。屏蔽key对应的数字也可以通过简单的位运算方式判断是否开启了屏蔽。</p><p><strong>判断红点是否被屏蔽的流程可用下述流程图表述</strong></p><p><img src="/2023/07/04/%E5%9F%BA%E4%BA%8Elua%E7%9A%84%E7%BA%A2%E7%82%B9%E6%A0%91%E5%AE%9E%E7%8E%B0/image-20230704230501489.png" alt="image-20230704230501489"></p><h1 id="获取红点树的数值"><a href="#获取红点树的数值" class="headerlink" title="获取红点树的数值"></a>获取红点树的数值</h1><h2 id="获取过程"><a href="#获取过程" class="headerlink" title="获取过程"></a>获取过程</h2><p>如果一棵红点树比较复杂，然后还需要再主入口显示红点总数<img src="/2023/07/04/%E5%9F%BA%E4%BA%8Elua%E7%9A%84%E7%BA%A2%E7%82%B9%E6%A0%91%E5%AE%9E%E7%8E%B0/image-20230704230857437.png" alt="image-20230704230857437"></p><p>在主入口如果只有装备a显示红点，那么这时候数量显示多少？这时候1和2其实都可以， 如果希望是2那么采用广度遍历，逐层向上设置cacheValue即可</p><p><strong>获取红点的流程图：</strong></p><p><img src="/2023/07/04/%E5%9F%BA%E4%BA%8Elua%E7%9A%84%E7%BA%A2%E7%82%B9%E6%A0%91%E5%AE%9E%E7%8E%B0/image-20230704231653859.png" alt="image-20230704231653859"></p><h2 id="性能优化"><a href="#性能优化" class="headerlink" title="性能优化"></a>性能优化</h2><p>每次界面刷新都会触发红点树的刷新， 而界面刷新又是十分频繁的操作， 那么如何解决其中的性能问题呢</p><p><strong>缓存值：</strong>也就是cacheValue值， 只有为nil时才遍历取值并缓存到cacheValue中</p><p><strong>懒加载：</strong>当红点节点的数值发生变化时，只是将其当前节点及父节点的cacheValue清空，当实际需要显示这个红点数值的时候，再去遍历取值.</p><p><strong>红点树变化具体过程：</strong></p><ol><li><p>原始状态下并停留在游戏主界面，红点树各节点的值</p><p><img src="/2023/07/04/%E5%9F%BA%E4%BA%8Elua%E7%9A%84%E7%BA%A2%E7%82%B9%E6%A0%91%E5%AE%9E%E7%8E%B0/image-20230704233331147.png" alt="image-20230704233331147"></p></li><li><p>打开了背包界面， 红色标记出变化部分</p><p><img src="/2023/07/04/%E5%9F%BA%E4%BA%8Elua%E7%9A%84%E7%BA%A2%E7%82%B9%E6%A0%91%E5%AE%9E%E7%8E%B0/image-20230704233438492.png" alt="image-20230704233438492"></p></li><li><p>装备a的数据发生变化，红点系统的数据层先将装备a的self设为1，再将自己及父节点的cacheValue置空</p><p><img src="/2023/07/04/%E5%9F%BA%E4%BA%8Elua%E7%9A%84%E7%BA%A2%E7%82%B9%E6%A0%91%E5%AE%9E%E7%8E%B0/image-20230704233524474.png" alt="image-20230704233524474"></p></li><li><p>通知正在显示中的红点取对应的红点数值</p><p><img src="/2023/07/04/%E5%9F%BA%E4%BA%8Elua%E7%9A%84%E7%BA%A2%E7%82%B9%E6%A0%91%E5%AE%9E%E7%8E%B0/image-20230704233601210.png" alt="image-20230704233601210"></p></li><li><p>关闭背包界面，返回主界面</p><p><img src="/2023/07/04/%E5%9F%BA%E4%BA%8Elua%E7%9A%84%E7%BA%A2%E7%82%B9%E6%A0%91%E5%AE%9E%E7%8E%B0/image-20230704233627073.png" alt="image-20230704233627073"></p></li><li><p>再次打开背包界面时，因为各红点节点的cacheValue均已赋值，直接读取即可</p></li></ol><h1 id="预制体设置"><a href="#预制体设置" class="headerlink" title="预制体设置"></a>预制体设置</h1><p>做好单个的红点预制体后，放置在对应按钮处成为其子物体，并且再UserData的Element处配置上该红点的key</p><p><img src="/2023/07/04/%E5%9F%BA%E4%BA%8Elua%E7%9A%84%E7%BA%A2%E7%82%B9%E6%A0%91%E5%AE%9E%E7%8E%B0/image-20230704233934691.png" alt="image-20230704233934691"></p><p>对于红点的刷新，当收到获得新装备的服务器协议，设置新装备的红点为1，然后触发红点刷新的广播机制</p>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h1&gt;&lt;p&gt;游戏中的红点算是一个极其常用的功能， 可以为玩家提供有效的非强制性引导。目前比较常用的红点一般围绕两种方案，一种是基于业务模块各自实现，另一种是设计一个尽可能通用的模块来管理红点&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;p&gt;基于业务模块&lt;/p&gt;
&lt;p&gt;只需要从各个业务模块获取红点的显示数据，红点的生命周期由对应业务模块负责管理。&lt;/p&gt;
&lt;p&gt;此方案可以避免红点陷入复杂的业务逻辑，但缺点也很明显，ui和业务逻辑过于耦合，ui的调整可能会带来代码逻辑上的改动，从而增加了许多重复的工作量，浪费了人力资源。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;通用型红点模块&lt;/p&gt;
&lt;p&gt;通用型红点模块即红点模块不仅管理红点数据，还需控制和管理所有业务界面的所有红点的生命周期，将之统一收纳进一个尽可能通用、灵活健壮的管理机制当中。&lt;/p&gt;
&lt;p&gt;为了避免界面调整带来的代码调整，我们把红点的显示路径抽离出代码逻辑，以配置文件的形式交由策划去维护。优点是，程序只要实现一次逻辑，界面调整带来的红点改动只需修改配置即可&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h1 id=&quot;红点树配置&quot;&gt;&lt;a href=&quot;#红点树配置&quot; class=&quot;headerlink&quot; title=&quot;红点树配置&quot;&gt;&lt;/a&gt;红点树配置&lt;/h1&gt;</summary>
    
    
    
    
    <category term="Unity" scheme="https://ycy666666.github.io/tags/Unity/"/>
    
    <category term="lua" scheme="https://ycy666666.github.io/tags/lua/"/>
    
  </entry>
  
  <entry>
    <title>unity Lua架构学习总结</title>
    <link href="https://ycy666666.github.io/2023/06/28/unity-Lua%E6%9E%B6%E6%9E%84%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93/"/>
    <id>https://ycy666666.github.io/2023/06/28/unity-Lua%E6%9E%B6%E6%9E%84%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93/</id>
    <published>2023-06-28T14:46:14.000Z</published>
    <updated>2023-07-04T15:52:38.836Z</updated>
    
    <content type="html"><![CDATA[<h1 id="基础架构"><a href="#基础架构" class="headerlink" title="基础架构"></a>基础架构</h1><p>基于实习所在的项目组，主要是使用tolua框架在C#端进行C#接口开发，使用C/C++ Lua Bindings框架在lua层进行C++接口开发。Lua层能够以脚本更新来实现逻辑代码热更，但对于C#层和C++层的模块修改只能通过发布新的二进制包方式而无法热更</p><p>使用tolua框架能够是Lua层访问C#层接口，使用C/C++ Lua Bindings框架使其能够访问C++结构，引入C++主要是为了剥离出会造成GC Alloc压力的代码到C++层。C#层只需要关注Unity引擎接口与Unity插件模块的使用，理想情况下IO，网络，下载与SDK等核心基础模块都应该使用C++开发与优化，从而提高基础组件的性能表现</p><h1 id="Lua层结构"><a href="#Lua层结构" class="headerlink" title="Lua层结构"></a>Lua层结构</h1><h2 id="启动流程"><a href="#启动流程" class="headerlink" title="启动流程"></a>启动流程</h2><p>有了两种绑定方法，Lua层同时具有了调用C++层接口和Unity引擎接口的可能</p><span id="more"></span><p><img src="/2023/06/28/unity-Lua%E6%9E%B6%E6%9E%84%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93/image-20230624205513773.png" alt="image-20230624205513773"></p><p>游戏开始启动时，首先实例化Unity场景，执行挂载在其中的启动脚本，在脚本当中会初始化GameManager，在该脚本种会主动设置一系列全局参数。</p><p>然后会触发C++层初始化操作，这时候会负责初始化SDK， 解密模块，热更模块，线程池等核心模块。此后会创建Lua虚拟机，注册生成绑定代码（wrap文件）</p><p>C++初始化完毕后，初始化流程会返回C#，在C#层初始化基础的Unity相关模块。执行完毕后，tolua#便开始了初始化操作，创建<code>LuaManager</code>实例，<code>LuaManager</code>会创建C#层<code>LuaState</code>对象代理，用来管理C#层Lua交互. 同时tolua#的<code>LuaState</code>会执行<code>LuaBinder</code>和<code>DelegateFactory</code>的初始化注册</p><ul><li><code>LuaBinder</code>会负责所有C#导出接口的注册绑定</li><li><code>DelgateFactory</code>负责所有Lua层注册给C#的回调函数，这些回调函数的管理形式就是以C#的委托来管理的</li></ul><p>在绑定代码注册完毕后，就会加载外部脚本，执行tolua的Lua脚本的加载，其中包括tolua#的Lua组件和tolua++在Lua的实现模块。</p><p>最后就能加载Lua Framework, 开始游戏的启动和登录流程</p><h2 id="toLua"><a href="#toLua" class="headerlink" title="toLua++"></a>toLua++</h2><p>这是Tolua框架的C++层, 其Lua Binding技术特点如下</p><ol><li>宿主语言为C/C++</li><li>C++对象的生命周期可依托Lua的GC机制,C++层通过在userdata中存储某个对象地址</li><li>对tolua的简单封装，基于纯净的头文件方式，轻量级的，支持C++模板,极大的简化了C/C++代码与Lua代码的集成</li><li>tolua++提供自动生成从Lua访问C/C++功能的绑定代码的工具</li></ol><h3 id="对象访问原理"><a href="#对象访问原理" class="headerlink" title="对象访问原理"></a>对象访问原理</h3><p>tolua++为原生对象构建一个userdata作为Lua的引用，其中userdata的值就是C++对象的地址，它的metatable即为对应C++类型的元表，表中包含了导出的成员变量、成员函数等信息。</p><p>对于类成员变量的读取赋值，tolua++是在C++类型的metatable里建立了.get和.set两个表，两个表里key为变量名，value是读取/设置的C函数。而_index和 _newindex元方法里，以变量名为key，从.get和.set表里获取对应函数并调用</p><p>调用类成员函数时，会将C++对象的地址作为key（形式为light_userdata），将Lua持有的引用对象作为userdata压入Lua栈中，并将该键值对存储在tolua_ubox表内，下次如果是相同的C++对象，便可直接从这个表中读取缓存</p><p>C++对象与userdata引用关系如下：</p><p><img src="/2023/06/28/unity-Lua%E6%9E%B6%E6%9E%84%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93/image-20230627004308358.png" alt="image-20230627004308358"></p><p>由上图可知，所有light_userdata都共享一张metatable, 不能通过传入的内存地址直接与具体的C++类型metatable相绑定。所以引入tolua_unbox表用来表示C++对象与userdata的映射，用于判断C++对象类型的metatable中是否有ubox表。</p><h3 id="对象生命周期"><a href="#对象生命周期" class="headerlink" title="对象生命周期"></a>对象生命周期</h3><p>在语言绑定技术中，对于原生层对象和脚本层对象，这两种对象的生命周期是不同步的，典型的案例就是开发者调用某个原生类对象的destroy或者remove接口，此时原生层对象将会被释放，而脚本层对象的引用如果仍然被持有，是可以访问的，但是开发者调用任何绑定层提供的接口，都会发现无法找到原生层对象而发生错误或者崩溃。</p><p>基于以上的原因，原生对象的生命周期管理依托于Lua的GC机制，<strong>Lua脚本对象持有C++原生对象的引用，而仅在脚本对象被垃圾回收的时候才释放原生对象</strong>，所以内存模型也被称为 Full GC ReliedMemory Model (完全依赖垃圾回收机制的内存模型)，通过下面这张图可以看到它的基本运作方式</p><p><img src="/2023/06/28/unity-Lua%E6%9E%B6%E6%9E%84%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93/image-20230627005805569.png" alt="image-20230627005805569"></p><p>图中<strong>虚线代表脚本对象对原生对象的引用(通过增加引用计数)</strong>，这样即便从节点树上删除某个节点，它的原生对象也不会被释放。而当脚本对象被垃圾回收的时候，会减少它所引用的原生对象的引用计数，使得原生对象也会被释放。</p><p>这种模式通过以下两点避免原生对象和脚本对象生命周期不同步</p><ol><li>使用垃圾回收机制同时控制原生对象和脚本对象的生命周期</li><li>传递原生层的引用关系给脚本层</li></ol><p><strong>红色箭头代表了在脚本层的对象引用关系</strong>，tolua++在脚本层引用生成时会对C++对象的引用计数加1，而对于脚本对象，当脚本对象的引用被解除后，会使得脚本对象进入GC。又由于每个脚本对象的userdata的元表实现了 _gc的元方法，使得C++导出类的GC函数会被触发执行，此时其中GC函数会将当前原生对象的引用计数减1</p><p>在基于引用计数的管理模式下，即使开发者在原生层释放了某个对象也只会减少它所持有的原生对象的引用计数，并不会影响到因为脚本层引用而所产生的引用计数，从而保证了原生对象和脚本对象生命周期的同步。</p><h3 id="绑定"><a href="#绑定" class="headerlink" title="绑定"></a>绑定</h3><p>tolua++绑定C/C++接口，在Lua访问C++对象和方法时，主要有以下三个过程</p><ol><li>获取C++对象指针并且取出Lua传递的参数</li><li>调用对应的C++方法</li><li>将C++返回值传递给Lua</li></ol><p>将C++层API按照Lua的注册函数的签名格式注册到虚拟机中，在Lua层调用对应的C++层的API时tolua++会在当前tolua_ubox中通过userdata找到对应的对象指针，从而取出对应的C++对象，并将参数做类型转换为C++的参数以及做参数类型检查，调用C++层的API，传递解析后的C++参数，并且将C++层的返回值压入Lua栈返回给Lua层</p><h2 id="C-结构"><a href="#C-结构" class="headerlink" title="C++结构"></a>C++结构</h2><h3 id="Runtime"><a href="#Runtime" class="headerlink" title="Runtime"></a>Runtime</h3><p>C++运行时类，负责Lua引擎的管理，以及C++调度管理，包括运行时环境的初始化、清理</p><p>Runtime的创建，主要完成了LuaEngine的构造并控制其整个生命周期，Runtime析构的时候会主动移除LuaEngine并且进行相关的资源释放操作</p><h3 id="LuaEngine"><a href="#LuaEngine" class="headerlink" title="LuaEngine"></a>LuaEngine</h3><p>Lua引擎的管理员，掌管着Lua的初始化、销毁、绑定代码注册，垃圾回收，当他初始化时会创建当前Lua虚拟机的LuaStack对象</p><p>而LuaStack对象管理C++与Lua交互, 负责绑定代码的注册</p><h3 id="LuaDelegate"><a href="#LuaDelegate" class="headerlink" title="LuaDelegate"></a>LuaDelegate</h3><p>保存了对Lua函数的引用, 通过持有对应函数的ref来管理释放与调用</p><p>如果引用计数为0会触发对象的析构, 这个过程中会移除对该Lua函数的引用, 从而使其和当前C++的引用链断开, 如果没有其他地方引用则会GC这个Lua函数</p><h2 id="C-结构-1"><a href="#C-结构-1" class="headerlink" title="C#结构"></a>C#结构</h2><p>项目目前C#结构主题仍然是toLua#的类结构设计, </p><p>主要组成部分功能介绍:</p><h3 id="GameManager"><a href="#GameManager" class="headerlink" title="GameManager"></a>GameManager</h3><p>在C#控制整个游戏的核心逻辑, 管理游戏的生命周期. 实例化构造后, 会执行基础模块的C#文件IO管理, 资源管理的初始化, 然后执行LuaManager的构造以及其他业务模块的初始化</p><p>在C#的创建, 销毁, 调度等都会同步到C++, 使得C++的逻辑能被驱动起来</p><h3 id="LuaManager"><a href="#LuaManager" class="headerlink" title="LuaManager"></a>LuaManager</h3><p>C#层的Lua管理器, 负责Lua初始化和导出绑定代码的注册以及LuaState的初始化.</p><p>C++初始化完成之后,会创建该实例, 拿到C++层初始化的lua_State对象之后执行C#层的初始化. C#会对lua_State封装成LuaState, 提供函数调用以及参数传递转换等,  同样也能维护内部hash表, 对LuaFunction进行弱引用管理</p><h3 id="ObjectTranslator"><a href="#ObjectTranslator" class="headerlink" title="ObjectTranslator"></a>ObjectTranslator</h3><p>为Lua中与C#对象的交互提供了基础, 简单来说就是C#传递对象给Lua时并非直接暴露, 而是会在ObjectTranslator里面注册并返回对应索引.  并将索引包装为userdata传递给Lua,同时为其设置元表</p><p>通过每次生成新的userdata来代表当前C#对象在Lua层的访问存在形式,  会从ObjectTranslator中获取新的索引, 然后将该索引存入userdata中.</p><p>当Lua通过userdata访问C#对象时, 会从userdata中取出这个索引,  在ObjectTranslator中通过索引获取对象</p><p>ObjectTranslator主要用于缓存Lua需要访问的C#对象, 提供对象池以及对象的增删查方法, 管理对象生命周期.  LuaObjectPool对象池包含了PoolNode对象的链表进行循环复用, PoolNode对象包含对真正object的引用以及一个当前空闲索引</p><h3 id="LuaTable"><a href="#LuaTable" class="headerlink" title="LuaTable"></a>LuaTable</h3><p>LuaTable是一种tolua#提供的用于Lua和C#之间传递数据的类型, 可以被看作是C#中的Dictionary, 键和值都可以是任何类型的Lua对象. C#层可以根据tolua#提供的接口获得LuaTable, 然后进行读写或者是传递给Lua中的函数,从而进行数据交换,这是一种双向数据绑定</p><p>而LuaFunction 是tolua#提供的代表C#中的委托,  在Lua中获取到LuaFunction之后就可以直接调用对应的C#函数了</p><h1 id="常见问题与优化"><a href="#常见问题与优化" class="headerlink" title="常见问题与优化"></a>常见问题与优化</h1><h2 id="C-对象访问"><a href="#C-对象访问" class="headerlink" title="C#对象访问"></a>C#对象访问</h2><p>C#对象的访问和C++类似, 都是通过lua中userdata的引用, 然后拿到其中对应的索引信息后在C#的ObjectTranslator中查询到C#对象, 然后调用C#方法.</p><p>那么以Unity的特定组件举例, 假设我们需要获取某游戏对象的transform组件, 然后以此来改变对象数据. 下面给出整个过程的实现细节:</p><div class="table-container"><table><thead><tr><th style="text-align:left">调用</th><th>含义</th></tr></thead><tbody><tr><td style="text-align:left"><code>UnityEngine_GameObjectWrap.get_transform</code></td><td>Lua层访问transform属性会直接调用注册进Lua虚拟机的绑定函数，从而调用到该绑定函数</td></tr><tr><td style="text-align:left"><code>LuaDLL.tolua_rawnetobj</code></td><td>从Lua对象的userdata中拿到C#对象在ObjectTranslator中的索引</td></tr><tr><td style="text-align:left"><code>ObjectTranslator.GetObject</code></td><td>用索引获取在ObjectTranslator中的GameObject对象</td></tr><tr><td style="text-align:left"><code>obj.transform</code></td><td>获取gameObject中的transform组件对象</td></tr><tr><td style="text-align:left"><code>ObjectTranslator.AddObject</code></td><td>分配一个新的index给transform对象，存入ObjectTranslator</td></tr><tr><td style="text-align:left"><code>LuaDLL.tolua_pushnewudata</code></td><td>分配一个新的userdata,并把当前的index存入其中，并把userdata留在Lua栈返回给Lua层</td></tr></tbody></table></div><p>可以看出获取组件的代价是巨大的,  而且C#的Object不能作为指针直接操作, 所以主流Lua结构都是用ID表示C#的对象索引, 以hash表来对应ID和Object, 同时正如之前所说 这还保证了Lua持有引用时C#对象不会被GC</p><h3 id="值类型传递"><a href="#值类型传递" class="headerlink" title="值类型传递"></a>值类型传递</h3><p>对于Vector3等table类数据,  在C#和Lua中已经是两个数据类型了， 每次传递都会存在类型转换。 尽管tolua已经做了一定的优化， 在Lua层以纯Lua形式实现Vector3，而避免在C#之间传递。 但这种性能优化明显不够，但UI界面需要频繁更新UI节点时会产生大量的Vector3 tabel，这会导致大量GC， 而这时候只是需要通知C#层更新位置而已， 并不需要这样的表对象。这时候完全可以拓展出新的接口， 用number的方式传递，而且这种方式是无GC的</p><h3 id="枚举类型传递"><a href="#枚举类型传递" class="headerlink" title="枚举类型传递"></a>枚举类型传递</h3><p>同样类似的， 对于C#枚举类型的传递，原本tolua会将每个enum强制转换为object类型通过userdata的方式传递给lua， 而且tolua会在c#层维护一个enumMap来映射枚举和对应的object，便于重复读取。</p><p>显然，这也会导致多余GC，因此采用将枚举转换int64的方式，压入栈中传递给Lua层， </p><h2 id="Lua代码加载"><a href="#Lua代码加载" class="headerlink" title="Lua代码加载"></a>Lua代码加载</h2><p>tolua#在C#层提供了一个<code>LuaFileUtils</code>类，内部维护了一个搜索路径的优先级，用来管理Lua文件或者Lua Bundle文件的动态读取，因为是在C#层的lO，所以会产生很多C#的内存，进而导致Mono的GC.</p><p>加载方式主要是C#层通过<code>P/Invoke</code>的方式调用Lua的 C API来设置Lua的Loader。 这样就会导致在require代码的时候， 通过<code>LuaFileUtils</code>类实现Lua文件的IO，然后将文件压入Lua栈中， 这就有C#和C两层的内存开销</p><p>考虑到Lua直接宿主语言是C/C++， 因此将Lua编译以及IO操作移植到C++中， 这就可以做到与C#无关，也就不会有相应的GC</p><h2 id="全局变量"><a href="#全局变量" class="headerlink" title="全局变量"></a>全局变量</h2><p>Lua这样的嵌入式语言中，是通过是宿主语言调用代码段(trunk)来实现功能的，Lua不适用全局变量而是使用一个名为全局环境（global  environment）的表来模拟全局环境</p><p>全局变量的使用总是会引发问题， 除了会随着功能增多不稳定之外，如果在_G表中引用了Unity的Object对象就会导致即使对象被Destroy了，仍然会保持引用，引发内存泄漏</p><p>为了避免这个问题， 项目中通常会为_G表设置元表，并实现__Index元方法来阻断全局变量定义</p><h2 id="配置表优化"><a href="#配置表优化" class="headerlink" title="配置表优化"></a>配置表优化</h2><p>随着项目的进行，策划使用的表格也会越来越多， 总体优化思路为去除冗余的无用数据</p><p>csv导出的原始数据一般会保持最直接的多维结构， 因此存在许多默认值为空的字段，增加了table表大小与嵌套。原始结构如下：</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">TaskConfig = &#123;</span><br><span class="line">    [<span class="number">1</span>] = &#123;</span><br><span class="line">    [<span class="string">&quot;TaskID&quot;</span>] = <span class="number">1000</span>,</span><br><span class="line">        [<span class="string">&quot;TaskName&quot;</span>] = <span class="string">&quot;NewPlayer&quot;</span>,</span><br><span class="line">        [<span class="string">&quot;Reward&quot;</span>] = &#123;<span class="string">&quot;Gold&quot;</span>, <span class="string">&quot;Exp&quot;</span>&#125;,</span><br><span class="line">        ...</span><br><span class="line">    &#125;,</span><br><span class="line">    [<span class="number">2</span>] = &#123;</span><br><span class="line">        [<span class="string">&quot;TaskID&quot;</span>] = <span class="number">1001</span>,</span><br><span class="line">        [<span class="string">&quot;TaskName&quot;</span>] = <span class="string">&quot;Daily&quot;</span>,</span><br><span class="line">        [<span class="string">&quot;Reward&quot;</span>] = &#123;<span class="string">&quot;Gold&quot;</span>, <span class="string">&quot;Exp&quot;</span>&#125;,</span><br><span class="line">        ...</span><br><span class="line">    &#125;,</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="字段名优化"><a href="#字段名优化" class="headerlink" title="字段名优化"></a>字段名优化</h3><p>利用metatable， 创建一张KeyMap， 导出时将Hash表转为数组，降低小表的内存占用</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 所有字段名都标注一个字段序</span></span><br><span class="line"><span class="keyword">local</span> KeyMap = &#123;</span><br><span class="line">    [<span class="string">&quot;TaskID&quot;</span>] = <span class="number">1</span>,</span><br><span class="line">    [<span class="string">&quot;TaskName&quot;</span>] = <span class="number">2</span>,</span><br><span class="line">    [<span class="string">&quot;Reward&quot;</span>] = <span class="number">3</span>,</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 数组形式展开</span></span><br><span class="line">TaskConfig = &#123;</span><br><span class="line">    [<span class="number">1</span>] = &#123;<span class="number">1000</span>, <span class="string">&quot;NewPlayer&quot;</span>, &#123;<span class="string">&quot;Gold&quot;</span>, <span class="string">&quot;Exp&quot;</span>&#125;, ...&#125;,</span><br><span class="line">    [<span class="number">2</span>] = &#123;<span class="number">1001</span>, <span class="string">&quot;Daily&quot;</span>, &#123;<span class="string">&quot;Gold&quot;</span>, <span class="string">&quot;Exp&quot;</span>&#125;, ...&#125;,</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 迭代器函数</span></span><br><span class="line"><span class="keyword">local</span> <span class="function"><span class="keyword">function</span> <span class="title">iterator</span><span class="params">(t, k)</span></span></span><br><span class="line">    <span class="keyword">local</span> v</span><br><span class="line">    k, v = <span class="built_in">next</span>(KeyMap, k)</span><br><span class="line">    <span class="keyword">if</span> v ~= <span class="literal">nil</span> <span class="keyword">then</span> <span class="keyword">return</span> k, t[v] <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span>    </span><br><span class="line"></span><br><span class="line"><span class="comment">-- 元表</span></span><br><span class="line"><span class="keyword">local</span> mt = &#123;</span><br><span class="line">    <span class="built_in">__index</span> = <span class="function"><span class="keyword">function</span><span class="params">(t, k)</span></span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> k <span class="keyword">then</span> <span class="keyword">return</span> <span class="keyword">end</span></span><br><span class="line">        <span class="keyword">return</span> t[KeyMap[k]]</span><br><span class="line">    <span class="keyword">end</span>,</span><br><span class="line">    <span class="built_in">__newindex</span> = <span class="function"><span class="keyword">function</span><span class="params">(t, k, v)</span></span></span><br><span class="line">        <span class="keyword">local</span> tk = KeyMap[k] <span class="keyword">or</span> k</span><br><span class="line">        rawret(t, tk, v)</span><br><span class="line">    <span class="keyword">end</span>,</span><br><span class="line">    __pairs = <span class="function"><span class="keyword">function</span><span class="params">(t)</span></span></span><br><span class="line">        <span class="keyword">return</span> iterator, t, <span class="literal">nil</span></span><br><span class="line">    <span class="keyword">end</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 设置每行数据的metatable</span></span><br><span class="line"><span class="keyword">local</span> <span class="function"><span class="keyword">function</span> <span class="title">_setmatatable</span><span class="params">(t,cnt)</span></span></span><br><span class="line">    <span class="keyword">if</span> cnt == <span class="number">0</span> <span class="keyword">then</span></span><br><span class="line">        <span class="built_in">setmetatable</span>(t, mt)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> _, v <span class="keyword">in</span> <span class="built_in">pairs</span>(t) <span class="keyword">do</span></span><br><span class="line">        _setmetatable(v, cnt - <span class="number">1</span>)</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">local</span> KeyConut = <span class="number">1</span></span><br><span class="line">_setmatatable(TaskConfig, KeyConut)</span><br></pre></td></tr></table></figure><h3 id="默认值提取"><a href="#默认值提取" class="headerlink" title="默认值提取"></a>默认值提取</h3><p>对于大量重复的默认值，常见优化方式是将默认数据置空，所有默认值存储在单独的table中，作为共享对象使用</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">local</span> DefaultValueMap = &#123;</span><br><span class="line">    [<span class="string">&quot;Reward&quot;</span>] = &#123;<span class="string">&quot;Gold&quot;</span>, <span class="string">&quot;Exp&quot;</span>&#125;,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">TaskConfig = &#123;</span><br><span class="line">    [<span class="number">1</span>] = &#123;<span class="number">1000</span>, <span class="string">&quot;NewPlayer&quot;</span>, <span class="literal">nil</span>, ...&#125;,</span><br><span class="line">    [<span class="number">2</span>] = &#123;<span class="number">1001</span>, <span class="string">&quot;Daily&quot;</span>, <span class="literal">nil</span>, ...&#125;,</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">local</span> mt = &#123;</span><br><span class="line">    <span class="built_in">__index</span> = <span class="function"><span class="keyword">function</span><span class="params">(t, k)</span></span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> k <span class="keyword">then</span> <span class="keyword">return</span> <span class="keyword">end</span></span><br><span class="line">        <span class="keyword">return</span> t[KeyMap[k]] <span class="keyword">or</span> DefaultValueMap[k]</span><br><span class="line">    <span class="keyword">end</span>,</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="表格压缩"><a href="#表格压缩" class="headerlink" title="表格压缩"></a>表格压缩</h3><p>核心点是将导出的配置表中的N维表格改成用一维数组的方式来表示，减少整个配置表结构中的Lua表规模，从而降低Lua内存</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 把N维表格转为一维， 降低table表个数</span></span><br><span class="line"><span class="keyword">local</span> DataTable = &#123;</span><br><span class="line">    [<span class="number">1</span>] = &#123;<span class="number">1000</span>, <span class="string">&quot;NewPlayer&quot;</span>, <span class="literal">nil</span>, ..., <span class="number">1001</span>, <span class="string">&quot;Daily&quot;</span>, <span class="literal">nil</span>, ...&#125;,</span><br><span class="line">    [<span class="number">2</span>] = &#123;<span class="number">1000</span>, <span class="number">1001</span>, ...&#125;,<span class="comment">-- 提取出索引ID</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 所有字段名都标注一个字段序</span></span><br><span class="line"><span class="keyword">local</span> KeyMap = &#123;</span><br><span class="line">    [<span class="string">&quot;TaskID&quot;</span>] = <span class="number">1</span>,</span><br><span class="line">    [<span class="string">&quot;TaskName&quot;</span>] = <span class="number">2</span>,</span><br><span class="line">    [<span class="string">&quot;Reward&quot;</span>] = <span class="number">3</span>,</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 迭代器，用于遍历每一行数据</span></span><br><span class="line"><span class="keyword">local</span> <span class="function"><span class="keyword">function</span> <span class="title">iter1</span><span class="params">(t, k)</span></span></span><br><span class="line">    k = <span class="built_in">next</span>(KeyMap, k)</span><br><span class="line">    <span class="keyword">return</span> k, t[k]</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 一维数组每一段的迭代器, 对应表格中每一行</span></span><br><span class="line"><span class="keyword">local</span> mt1 = &#123;</span><br><span class="line">    <span class="built_in">__index</span> = <span class="function"><span class="keyword">function</span><span class="params">(t, k)</span></span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> k <span class="keyword">or</span> <span class="keyword">not</span> KeyMap[k] <span class="keyword">then</span> <span class="keyword">return</span> <span class="keyword">end</span></span><br><span class="line">        <span class="keyword">local</span> idx = t.left + KeyMap[k]</span><br><span class="line">        <span class="keyword">return</span> DataTable[<span class="number">1</span>][idx] <span class="keyword">or</span> DefaultValues[k]</span><br><span class="line">    <span class="keyword">end</span>,</span><br><span class="line">    __pairs = <span class="function"><span class="keyword">function</span><span class="params">(t)</span></span></span><br><span class="line">        <span class="keyword">return</span> iter1, t, <span class="literal">nil</span></span><br><span class="line">    <span class="keyword">end</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 一维数组迭代器， 也就是遍历出每个Task</span></span><br><span class="line"><span class="keyword">local</span> <span class="function"><span class="keyword">function</span> <span class="title">iter2</span><span class="params">(t, k)</span></span></span><br><span class="line">    <span class="keyword">local</span> v</span><br><span class="line">    <span class="keyword">if</span> k <span class="keyword">then</span></span><br><span class="line">        <span class="keyword">local</span> vv = t[k]</span><br><span class="line">        <span class="keyword">local</span> i = vv.idx + <span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> i &gt; #DataTable[<span class="number">2</span>] <span class="keyword">then</span></span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">        k = DataTable[<span class="number">2</span>][i]</span><br><span class="line">        v = &#123; left = (i - <span class="number">1</span>) * ValConut + <span class="number">1</span>, idx = i&#125;</span><br><span class="line">        <span class="built_in">setmetatable</span>(v, mt1)</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        k = DataTable[<span class="number">2</span>][<span class="number">1</span>]</span><br><span class="line">        v = t[k]</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">return</span> k, v</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 配置表对象的元表， 用于获取某个key的表对象，以mt1为元表</span></span><br><span class="line"><span class="keyword">local</span> mt2 = &#123;</span><br><span class="line">    <span class="built_in">__index</span> = <span class="function"><span class="keyword">function</span><span class="params">(t,k)</span></span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> k <span class="keyword">then</span> <span class="keyword">return</span> <span class="keyword">end</span></span><br><span class="line">        <span class="keyword">for</span> i = <span class="number">1</span>, #DataTable[<span class="number">2</span>], <span class="number">1</span> <span class="keyword">do</span></span><br><span class="line">            <span class="keyword">if</span> k == DataTable[<span class="number">2</span>][i] <span class="keyword">then</span></span><br><span class="line">                <span class="keyword">local</span> tbl = &#123; left = (i - <span class="number">1</span>) * ValCount + <span class="number">1</span>&#125;</span><br><span class="line">                <span class="built_in">setmetatable</span>(tbl, mt1)</span><br><span class="line">                <span class="keyword">return</span> tbl</span><br><span class="line">            <span class="keyword">end</span></span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">end</span>,</span><br><span class="line">    __pairs = <span class="function"><span class="keyword">function</span><span class="params">(t)</span></span></span><br><span class="line">        <span class="keyword">return</span> iter2, t, <span class="literal">nil</span></span><br><span class="line">    <span class="keyword">end</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">local</span> tbl = &#123;&#125;</span><br><span class="line"><span class="built_in">setmetatable</span>(tbl, mt2)</span><br><span class="line">TaskConfig = tbl</span><br></pre></td></tr></table></figure><h2 id="Lua内存泄漏"><a href="#Lua内存泄漏" class="headerlink" title="Lua内存泄漏"></a>Lua内存泄漏</h2><p>Lua层内存泄漏主要在三个方面</p><ul><li><p>C#委托</p></li><li><p>循环引用</p></li><li><p>全局引用</p></li></ul><h3 id="C-委托"><a href="#C-委托" class="headerlink" title="C#委托"></a>C#委托</h3><p>Lua层会通过tolua#注册回调给C#层, 使得Lua层会有对应的逻辑. 但如果在C#层没有及时的对委托进行清理, tolua#层在Collector的时候也无法回收对应的LuaFunction对象,也就不能释放其中引用的Lua表对象</p><p>因此需要对每一个在Lua层注册到C#层的回调函数都显式的做出清理操作, 不再使用委托时 应当实现Dispose接口或者其他接口清理委托对象</p><h3 id="循环引用"><a href="#循环引用" class="headerlink" title="循环引用"></a>循环引用</h3><p>会经常使用handler这个函数对象接口来包装回调函数, 但是handler调用之后会产生一个新的匿名函数对象,  而传入的obj参数会成为该匿名函数的upvalue, 只有匿名函数引用消失后才会对obj的引用消除</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">handler</span><span class="params">(obj, method)</span></span></span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> <span class="params">(...)</span></span></span><br><span class="line">        method(obj, ...)</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span>    </span><br></pre></td></tr></table></figure><p>handler一般都会传入一个self表做包装, 如果是一个可以反复创建的对象, 如果不主动清理这个匿名函数, 就会导致这个匿名函数与对象循环引用, 造成两侧的内存泄漏</p><p>出于安全性的考虑, 时刻关注匿名函数生命周期不太合适, 因此采用自动管理的方式.  将handler传入的obj对象从强引用转换为弱引用, 在其他地方没有对obj的引用后会自动进入GC</p><h3 id="全局引用"><a href="#全局引用" class="headerlink" title="全局引用"></a>全局引用</h3><p>因为前面已经提出了禁止全局变量使用的优化, 但部分特殊框架仍然会在_G表下</p><p>tolua#中提供了多个调度对象—<code>UpdateBeat</code>, <code>LateUpdateBeat</code>, <code>FixedUpdateBeat</code>, <code>CoUpdateBeat</code>, 这些都是event实例化的对象, 且均在_G环境下作为常驻对象存在</p><p>tolua的event类其中的self.current会引用最后一次遍历对象, 那么这就导致了这些对象会被一直引用,无法进入GC. 既然是因为引用链未及时清理, 那么每次遍历结束后直接清理self.current为nil即可</p><p>对于这种因为上层对象是全局对象引发的内存泄漏, 只需清理引用关系链,驱动真缺德内存对象GC即可, 特别是Lua函数很容易形成闭包upvalue的强引用关系,</p>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;基础架构&quot;&gt;&lt;a href=&quot;#基础架构&quot; class=&quot;headerlink&quot; title=&quot;基础架构&quot;&gt;&lt;/a&gt;基础架构&lt;/h1&gt;&lt;p&gt;基于实习所在的项目组，主要是使用tolua框架在C#端进行C#接口开发，使用C/C++ Lua Bindings框架在lua层进行C++接口开发。Lua层能够以脚本更新来实现逻辑代码热更，但对于C#层和C++层的模块修改只能通过发布新的二进制包方式而无法热更&lt;/p&gt;
&lt;p&gt;使用tolua框架能够是Lua层访问C#层接口，使用C/C++ Lua Bindings框架使其能够访问C++结构，引入C++主要是为了剥离出会造成GC Alloc压力的代码到C++层。C#层只需要关注Unity引擎接口与Unity插件模块的使用，理想情况下IO，网络，下载与SDK等核心基础模块都应该使用C++开发与优化，从而提高基础组件的性能表现&lt;/p&gt;
&lt;h1 id=&quot;Lua层结构&quot;&gt;&lt;a href=&quot;#Lua层结构&quot; class=&quot;headerlink&quot; title=&quot;Lua层结构&quot;&gt;&lt;/a&gt;Lua层结构&lt;/h1&gt;&lt;h2 id=&quot;启动流程&quot;&gt;&lt;a href=&quot;#启动流程&quot; class=&quot;headerlink&quot; title=&quot;启动流程&quot;&gt;&lt;/a&gt;启动流程&lt;/h2&gt;&lt;p&gt;有了两种绑定方法，Lua层同时具有了调用C++层接口和Unity引擎接口的可能&lt;/p&gt;</summary>
    
    
    
    
    <category term="Unity" scheme="https://ycy666666.github.io/tags/Unity/"/>
    
    <category term="lua" scheme="https://ycy666666.github.io/tags/lua/"/>
    
  </entry>
  
  <entry>
    <title>NGUI使用方法</title>
    <link href="https://ycy666666.github.io/2023/04/29/NGUI%E4%BD%BF%E7%94%A8%E6%96%B9%E6%B3%95/"/>
    <id>https://ycy666666.github.io/2023/04/29/NGUI%E4%BD%BF%E7%94%A8%E6%96%B9%E6%B3%95/</id>
    <published>2023-04-29T12:59:39.000Z</published>
    <updated>2023-04-29T13:12:49.688Z</updated>
    
    <content type="html"><![CDATA[<h1 id="基本用法"><a href="#基本用法" class="headerlink" title="基本用法"></a>基本用法</h1><p>很多基本模块比如按钮、slider等都能从Prefab中直接拖拽到场景中实现，但都需要有一个Collider（Prefab已经自带）</p><p>因为不仅是UI，所有带有Collider的游戏物体都能接收到OnClick， OnPress这样的事件——前提是需要在Main Camera里面添加上event System组件，然后自定义脚本添加以下函数：</p><p><img src="/2023/04/29/NGUI%E4%BD%BF%E7%94%A8%E6%96%B9%E6%B3%95/莉莉丝飞书20230412-142107.jpg" alt="莉莉丝飞书20230412-142107"></p><p>如果不想写代码，也可以直接拖拽UIEventTrugger脚本来实现相关功能</p><p><img src="/2023/04/29/NGUI%E4%BD%BF%E7%94%A8%E6%96%B9%E6%B3%95/莉莉丝飞书20230412-143328.jpg" alt="莉莉丝飞书20230412-143328"></p><p>与此同时，我们也可以给其中一个事件绑定多个函数，比如滑动条的变更既改变音量大小也能改变滑动条背景颜色。也能在On Finished中指定动作完成后发生的下一动作</p><span id="more"></span><h2 id="核心组件"><a href="#核心组件" class="headerlink" title="核心组件"></a>核心组件</h2><h3 id="UILabel-标签"><a href="#UILabel-标签" class="headerlink" title="UILabel (标签)"></a>UILabel (标签)</h3><p><img src="/2023/04/29/NGUI%E4%BD%BF%E7%94%A8%E6%96%B9%E6%B3%95/v2-74aa8940d4cc2e8235c5126f2a8c9735_720w.webp" alt="img"></p><p>用于创建各种类型的文本标签和标注，除了基本的文本属性外，NGUI的UILabel还具有文本对齐方式（alignment）, 渐变和模糊（gradient和blur属性）</p><h3 id="UISlider-进度条"><a href="#UISlider-进度条" class="headerlink" title="UISlider (进度条)"></a>UISlider (进度条)</h3><p><strong>Appearance [添加进度条显示组件]</strong></p><ol><li>Foreground [表层进度条]<ol><li>Background [背景进度条]</li><li>Thumb [滑块]</li><li>Direction [进度条方向]</li></ol></li></ol><h3 id="UIInput-输入框"><a href="#UIInput-输入框" class="headerlink" title="UIInput (输入框)"></a>UIInput (输入框)</h3><p><img src="/2023/04/29/NGUI%E4%BD%BF%E7%94%A8%E6%96%B9%E6%B3%95/v2-9e39aca5c3d80e8929fc2188ee903fcc_720w.webp" alt="img"></p><ul><li>Starting Value [默认输入文字]</li></ul><blockquote><p>默认输入文本和初始化显示文本是两个概念,默认输入的文本是有效文本,初始化显示文本是提示用户输入用的文本</p></blockquote><ul><li>Saved As [设置输入的内容在PlayerPref中哪个字段保存] 这里通常不用设置,它会自动保存</li><li><strong>KeyboardType [文本输入时键盘类型设定]</strong>： 电话号码、URL、隐藏输入等</li><li>On Submit ：提交输入内容时触发事件函数设定</li><li>OnChange： 当输入内容改变时触发事件函数设定</li><li>Validation [验证输入类型] 只能验证指定输入类型,通过下拉框选择</li></ul><p><strong>一些注意事项：</strong></p><ol><li>输入框Input本身是无法显示文字的，它必须借助于一个 Label 来帮它显示输入的文本，字体、颜色等都与其相关联。如果发生冲突，比如颜色设置那么将会以 Input 中的设置为准。</li><li>输入框必须要有一个 BoxCollider 和一个 Sprite 底框否则无法输入。</li><li>输入框无法显示文字的一些情况:<ul><li>超出最大字符数限定, 或者文字大小超出范围;</li><li>Label所选用的字体库中没有这个文字或者输入的字符不符合要求的验证类型</li></ul></li><li>输入的文字可以从Input 中的 value 变量读取也可以从关联的 Label中的text变量读取。</li><li>请将相关联的 Label 设为输入框的子物体，这样就可以保证输入的文字和底框保持相对位置不变。</li></ol><h3 id="Scroll-View"><a href="#Scroll-View" class="headerlink" title="Scroll View"></a>Scroll View</h3><ul><li><strong>Drag Effect [拖动效果]</strong><ul><li>None [无效果] 视窗拖动到哪里就是哪里</li><li>Momentum [惯性拖动] 松开拖动后会根据惯性动能继续拖动</li><li>MomentumAndSpring [弹性拖动] 内容被拖到边界外时会自动回弹为正常视窗界面</li></ul></li></ul><p><strong>注意事项：</strong><br>(1)通常情况下，滚动视图一定要有一个 UIPanel 来进行窗口剪辑。这个UIPanel组件在创建ScrollView时会自动生成。</p><p>(3)<strong>滚动视图内包含的内容，一定要有一个 BoxCollider和 DragScrollView 组件</strong>，DragScrollView 组件会和ScrollView 相互作用，在运行时，它会自动去找到父物体中的 ScrollView，然后和它相互作用，让视图内的内容可以被滚动起来</p><p>(5)滚动视图的内容，最好放到创建的 Scrollview 节点下面作为子物体存在，这样可以免去大量的烦恼和隐患。</p><p>(7)滚动视图的剪辑窗口的尺寸一定要调整到位，尽量别去调整 clip的Centero</p><h1 id="UI动画"><a href="#UI动画" class="headerlink" title="UI动画"></a>UI动画</h1><h2 id="渐隐渐现动画-透明度动画"><a href="#渐隐渐现动画-透明度动画" class="headerlink" title="渐隐渐现动画 (透明度动画)"></a>渐隐渐现动画 (透明度动画)</h2><p><img src="/2023/04/29/NGUI%E4%BD%BF%E7%94%A8%E6%96%B9%E6%B3%95/v2-a8083694077f2067ea794be249cd7b54_720w.webp" alt="img"></p><p>创建TweenAlpha动画: NGUI 菜单 -&gt; Tween -&gt; Alpha 脚本</p><ul><li><p>From 和 To [开始和结束] Tween动画核心设置,起始点的设置</p></li><li><p><strong>PlayStyle [循环模式]</strong></p></li><li><ul><li>Once [单次播放]</li><li>Loop [循环播放] 播放完毕后,瞬间回到起点重新播放</li><li>PingPong [乒乓模式] 播放完毕后,从终点倒着播放回到起点</li></ul></li><li><p>Animation Curve [动画曲线编辑] 通过编辑曲线可以调整动画播放的快慢</p></li></ul><p><strong>注意点</strong></p><p>(1)从起点播放到终点，就算动画播放完了一遍。但是，在动画结束的触发事件中，我们需要注意的是，如果动画模式是 Loop 或者 PingPong，那么它将永远不会结束。</p><p>(2)透明度动画会实实在在地改变 UI的透明度，并不是一个临时透明度。例如，我们设置了一个透明度从1变为 0的渐渐消失动画，当透明度变化到 0.5时我们就将动画组件关闭，此时 UI 的透明度将会一直停留在 0.5。</p><p>(4)动画组件激活后，它会立即开启 StartDelay 的计时，然后播放动画。</p><p>(5)如果动画播放设定为播放一次，那么动画播放一次之后，就会自动关闭该组</p><h2 id="颜色变化动画-变色动画"><a href="#颜色变化动画-变色动画" class="headerlink" title="颜色变化动画 (变色动画)"></a>颜色变化动画 (变色动画)</h2><p><img src="/2023/04/29/NGUI%E4%BD%BF%E7%94%A8%E6%96%B9%E6%B3%95/v2-4839e178a210b97eee116e8f7cb30e57_720w.webp" alt="img"></p><p>颜色改变原理为UI原色与控件颜色相乘</p><h2 id="动画控制组件-UIPlayTween"><a href="#动画控制组件-UIPlayTween" class="headerlink" title="动画控制组件 (UIPlayTween)"></a>动画控制组件 (UIPlayTween)</h2><p><img src="/2023/04/29/NGUI%E4%BD%BF%E7%94%A8%E6%96%B9%E6%B3%95/16827732611752.png" alt="img"></p><p>UIPlayTween需要接收外部点击事件,所以我们会将它放在带有Collider的组件上</p><h2 id="动画控制组件-UIPlayAnimation"><a href="#动画控制组件-UIPlayAnimation" class="headerlink" title="动画控制组件 (UIPlayAnimation)"></a>动画控制组件 (UIPlayAnimation)</h2><p><img src="/2023/04/29/NGUI%E4%BD%BF%E7%94%A8%E6%96%B9%E6%B3%95/16827732611751.png" alt="img"></p><ul><li>为目标物体添加Animation组件: AddComponent -&gt; Animation 脚本 (注意:这里的Animation并不是UIPlayAnimation)</li><li>为目标物体添加动画: Animation组件 -&gt; Animation选项 -&gt; AnimationClip动画</li><li>为本体添加UIPlayAnimation: NGUI 菜单 -&gt; Attach -&gt; PlayAnimation 脚本</li><li>为本体添加目标物体: 拖动目标物体 -&gt; PlayAnimation脚本 -&gt; Animation选项</li></ul><h1 id="NGUI各组件实现功能"><a href="#NGUI各组件实现功能" class="headerlink" title="NGUI各组件实现功能"></a>NGUI各组件实现功能</h1><h2 id="屏幕适应"><a href="#屏幕适应" class="headerlink" title="屏幕适应"></a>屏幕适应</h2><p>NGUI中Anchors下拉菜单中type选择Unified或Advanced可以自定义UI四个方向上与给定位置保持相同距离，Unified四边选择的是同一transform，andvanced每边可以选择不同tansform作为target<br>Widget菜单中可选择Pivot位置（主要是影响子物体） 以及UI所处层级</p><h1 id="NGUI-相较于-UGUI的区别"><a href="#NGUI-相较于-UGUI的区别" class="headerlink" title="NGUI 相较于 UGUI的区别"></a>NGUI 相较于 UGUI的区别</h1><p>UGUI中UI元素被当作添加了UI组件的GameObject使用，更方便于单个使用。<br>NGUI使用仅有一个脚本挂载的GameObject，更方便控制所有UI元素</p><h2 id="从性能来看，UGUI比NGUI有底层优势"><a href="#从性能来看，UGUI比NGUI有底层优势" class="headerlink" title="从性能来看，UGUI比NGUI有底层优势"></a><strong>从性能来看，UGUI比NGUI有底层优势</strong></h2><p>UGUI的排序及合批逻辑都在C++层处理，采用EventSystem的分发模式，效率更高；</p><h2 id="UI动画-1"><a href="#UI动画-1" class="headerlink" title="UI动画"></a><strong>UI动画</strong></h2><p>NGUI整合了ITween，并将ITween的使用封装成脚本，可以非常方便制作出各种旋转、平移、缩放的效果，易用性很强。</p><p>UGUI官方文档建议是采用Animation System来制作UI动画，但是有个比较明显的缺陷，在UI频繁显隐的时候（Active/Inactive），Animator会重新Rebind一次Controller，导致无意义的性能损耗。所以UGUI的动画实现，一般通过整合DoTween来实现。Dotween不存在Animation的反复初始化问题，并且它使用了一些缓存策略，相对于ITween来说，每帧耗时更短，效率更高，产生GC更少</p><h2 id="交互形式"><a href="#交互形式" class="headerlink" title="交互形式"></a>交互形式</h2><p>在NGUI中，默认控件是不参与交互的，除非加上Collider；而在UGUI中，默认控件是参与交互的，除非使用canvas Group组件来禁止交互（可以通过去掉勾选raycast Target来禁止）</p><p>NGUI的交互事件是通过SendMessage来发送消息的，相比较于Delegate的性能，Delegate会快10倍左右。UGUI的交互事件改为通过事件回调机制来发送消息，性能上提升不少，比较直接反馈是scroll view的滑动流畅度。</p><h1 id="NGUI重要类的UML图"><a href="#NGUI重要类的UML图" class="headerlink" title="NGUI重要类的UML图"></a>NGUI重要类的UML图</h1><p><img src="/2023/04/29/NGUI%E4%BD%BF%E7%94%A8%E6%96%B9%E6%B3%95/image-20230429210221355.png" alt="image-20230429210221355"></p>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;基本用法&quot;&gt;&lt;a href=&quot;#基本用法&quot; class=&quot;headerlink&quot; title=&quot;基本用法&quot;&gt;&lt;/a&gt;基本用法&lt;/h1&gt;&lt;p&gt;很多基本模块比如按钮、slider等都能从Prefab中直接拖拽到场景中实现，但都需要有一个Collider（Prefab已经自带）&lt;/p&gt;
&lt;p&gt;因为不仅是UI，所有带有Collider的游戏物体都能接收到OnClick， OnPress这样的事件——前提是需要在Main Camera里面添加上event System组件，然后自定义脚本添加以下函数：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/2023/04/29/NGUI%E4%BD%BF%E7%94%A8%E6%96%B9%E6%B3%95/莉莉丝飞书20230412-142107.jpg&quot; alt=&quot;莉莉丝飞书20230412-142107&quot;&gt;&lt;/p&gt;
&lt;p&gt;如果不想写代码，也可以直接拖拽UIEventTrugger脚本来实现相关功能&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/2023/04/29/NGUI%E4%BD%BF%E7%94%A8%E6%96%B9%E6%B3%95/莉莉丝飞书20230412-143328.jpg&quot; alt=&quot;莉莉丝飞书20230412-143328&quot;&gt;&lt;/p&gt;
&lt;p&gt;与此同时，我们也可以给其中一个事件绑定多个函数，比如滑动条的变更既改变音量大小也能改变滑动条背景颜色。也能在On Finished中指定动作完成后发生的下一动作&lt;/p&gt;</summary>
    
    
    
    
    <category term="Unity" scheme="https://ycy666666.github.io/tags/Unity/"/>
    
  </entry>
  
  <entry>
    <title>ToLua框架学习</title>
    <link href="https://ycy666666.github.io/2023/04/29/ToLua%E6%A1%86%E6%9E%B6%E5%AD%A6%E4%B9%A0/"/>
    <id>https://ycy666666.github.io/2023/04/29/ToLua%E6%A1%86%E6%9E%B6%E5%AD%A6%E4%B9%A0/</id>
    <published>2023-04-29T12:59:26.000Z</published>
    <updated>2023-04-29T13:13:01.143Z</updated>
    
    <content type="html"><![CDATA[<p>ToLua 是一个用于在 Unity 中为 Lua 提供 C# 语言绑定的框架。通过 ToLua，你可以方便地将 C# 代码暴露给 Lua 脚本，并在 Lua 脚本中调用 C# 类、方法和属性。</p><h1 id="更新流程"><a href="#更新流程" class="headerlink" title="更新流程"></a>更新流程</h1><p>原理：使用AssetBundle进行资源的更新，而由于lua运行时才编译的特性，所以lua文件也可以被看成是一种资源文件（与fbx、Image等一样）可以打进ab包中</p><p>流程：</p><p>游戏运行时从服务器下载files.txt清单文件,与本地的files.txt清单文件进行对比。如果新下载的files里面的md5值与本地files的md5值不一样,或者本地清单里没有对应文件，那么就从服务器下载AB包，然后解压进行初始化</p><h1 id="LuaState"><a href="#LuaState" class="headerlink" title="LuaState"></a>LuaState</h1><p>C#能调用lua的原理就是创建了一个lua虚拟机，LuaState封装了对lua 主要数据结构 lua_State 指针的各种堆栈操作。</p><span id="more"></span><h2 id="去反射"><a href="#去反射" class="headerlink" title="去反射"></a>去反射</h2><p>旧版本中lua调用C#函数是基于反射的，而现阶段是基于去反射，意思就是：把所有的c#类的public成员变量、成员函数，都导出到一个相对应的Wrap类中。而这些成员函数通过特殊的标记，映射到lua的虚拟机中，当在lua中调用相对应的函数时候，直接调用映射进去的c# wrap函数，然后再调用到实际的c#类，完成调用过程</p><h3 id="Lua虚拟栈"><a href="#Lua虚拟栈" class="headerlink" title="Lua虚拟栈"></a>Lua虚拟栈</h3><p><img src="/2023/04/29/ToLua%E6%A1%86%E6%9E%B6%E5%AD%A6%E4%B9%A0/16827734664141.png" alt="img"></p><p>C#会告诉虚拟机传入的参数和需要返回的参数，然后虚拟机开始访问栈，从栈中取出对应函数传送给Lua编译器。然后lua程序调用Lua文件全局表（Global table）查找对应函数，然后将返回参数入栈，C#再从栈中读取数据。</p><ol><li>可以按1~N的顺序从栈底向上，也可以从-1~-N从栈顶向下</li><li>栈中可以存储任何数据，函数、table等，空的位置用nil表示</li></ol><h2 id="前置准备"><a href="#前置准备" class="headerlink" title="前置准备"></a>前置准备</h2><p>使用Tolua的相关类和方法都需要调用命名空间LuaInterface，LuaState.Start 需要在tolua代码加载到内存后调用。如果使用assetbunblde加载lua文件，调用Start()之前assetbundle必须加载好。</p><p>调用lua脚本必须先创建一个lua虚拟机， 一般对于客户端，推荐只创建一个LuaState对象。如果要使用多State需要在Unity中设置全局宏 MULTI_STATE，创建步骤为：</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">LuaState lua = new LuaState();</span><br></pre></td></tr></table></figure><h2 id="加载脚本"><a href="#加载脚本" class="headerlink" title="加载脚本"></a>加载脚本</h2><p>重要方法lua.AddSearchPath ，通过此方法添加lua文件的路径，只有添加了文件路径之后，在该路径上的lua文件才可以被读取。这样DoFile跟Require函数可以只用文件名,无需写全路径。</p><p>在C#中运行一段lua脚本最简单的方法就是lua.DoString，该方法声明如下：</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">public object[] DoString(<span class="built_in">string</span> chunk, <span class="built_in">string</span> chunkName = <span class="string">&quot;LuaState.DoString&quot;</span>)</span><br></pre></td></tr></table></figure><p><strong>注意dofile需要扩展名</strong>, 可反复执行, 后面的变量会覆盖之前的DoFile加载的变量这里加载了就会从开始逐句执行。</p><p>LuaState.Require</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">public void Require(<span class="built_in">string</span> filename)</span><br></pre></td></tr></table></figure><p>因为Require 读取文件是会检查该文件是否被加载过，如果被加载过，则直接返回一个索引，否则则加载并返回一个索引</p><ul><li><p>使用完lua虚拟机之后记得要销毁，具体操作如下：</p></li><li><ul><li>先进行lua虚拟机的判空，具体做法为lua.CheckTop</li><li>析构掉lua虚拟机，具体做法为：lua.Dispose</li></ul></li></ul><h1 id="C-调用lua函数"><a href="#C-调用lua函数" class="headerlink" title="C#调用lua函数"></a>C#调用lua函数</h1><h2 id="调用lua方法"><a href="#调用lua方法" class="headerlink" title="调用lua方法"></a>调用lua方法</h2><p>我们可以把lua中的函数看成一个对象，在虚拟机初始化完成后，加载对应的lua文件，接着需要创建一个LuaFunction类型的对象来表示这个lua函数，可以通过调用：<strong><code>lua.GetFunction(&quot;方法名&quot;);</code></strong> 来获取对应的函数对象</p><p>获取了之后就需要在C#中调用了，主要方式有两种：</p><ol><li>直接调用LuaFunction类型的对象的func.Call 方法，完整声明为：</li></ol><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="built_in">object</span>[] <span class="title">Call</span>(<span class="params"><span class="keyword">params</span> <span class="built_in">object</span>[] args</span>)</span></span><br></pre></td></tr></table></figure><p>这种调用方法比较简单，但是有一个缺点，lua对象的内存无法被自动释放，所以当使用完这个lua函数对象之后，我们需要手动的调用LuaFunction类型的对象的func.Dispose();方法，释放掉垃圾内存，否则会造成内存泄漏！</p><p>不过选择都采用的是委托的方式，需要先进行<code>DelegateFactory.Init()；</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">int num = luaFunc.Invoke&lt;int,int&gt;(arg);</span><br></pre></td></tr></table></figure><p>或者是</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Func&lt;<span class="built_in">int</span>, <span class="built_in">int</span>&gt; Func = luaFunc.ToDelegate&lt;Func&lt;<span class="built_in">int</span>, <span class="built_in">int</span>&gt;&gt;();</span><br><span class="line">num = Func(<span class="number">123456</span>);</span><br></pre></td></tr></table></figure><ol><li>如同案例当中的CallFunc()</li></ol><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="built_in">int</span> <span class="title">CallFunc</span>()</span></span><br><span class="line">&#123;        </span><br><span class="line">    luaFunc.BeginPCall();                </span><br><span class="line">    luaFunc.Push(<span class="number">123456</span>);</span><br><span class="line">    luaFunc.PCall();        </span><br><span class="line">    <span class="built_in">int</span> num = (<span class="built_in">int</span>)luaFunc.CheckNumber();</span><br><span class="line">    luaFunc.EndPCall();</span><br><span class="line">    <span class="keyword">return</span> num;                </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先我们必须先以<code>func.BeginPCall;</code>开始，通过<code>func.Push(参数)</code>来给方法传参—通过众多重载函数来解决参数转换的gc，然后需要通过<code>func.PCall();</code>来运行，接着通过对应的<code>func.Checkxxx()</code>方法来获取返回值,最后通过<code>func.EndPCall();</code>结束—清楚函数调用导致的堆栈变化。整个流程比较繁琐且不易封装，不过优点是不会有垃圾内存，所以不用手动释放GC。</p><h2 id="获取lua中的变量"><a href="#获取lua中的变量" class="headerlink" title="获取lua中的变量"></a>获取lua中的变量</h2><h3 id="创建全局变量"><a href="#创建全局变量" class="headerlink" title="创建全局变量"></a>创建全局变量</h3><p>在lua虚拟机创建完成且初始化完毕（调用Start方法）之后，可以直接声明一个lua虚拟机的全局变量:</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">LuaState lua = <span class="keyword">new</span> LuaState();</span><br><span class="line">lua.Start();</span><br><span class="line">lua[<span class="string">&quot;Objs2Spawn&quot;</span>] = <span class="number">5</span>;</span><br></pre></td></tr></table></figure><p>获取全局变量格式是相同的，这点和lua相同，没有就创建否则就读取。值得注意的是对于获取的函数需要强制转换为LuaFunction：<code>LuaFunction func = lua[&quot;TestFunc&quot;] as LuaFunction;</code></p><h3 id="获取与创建lua的table"><a href="#获取与创建lua的table" class="headerlink" title="获取与创建lua的table"></a>获取与创建lua的table</h3><p>通过调用虚拟机的方法lua.GetTable 来获取lua中的table，用LuaTable类型来储存lua中的Table，通过调用Luatable的成员方法table.AddTable来创建lua中的table , 除了通过虚拟机的GetTable方法访问之外，直接通过 LuaTable 型变量按字典的类似方法也可以调用table </p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">LuaTable table1 = lua.GetTable(<span class="string">&quot;varTable&quot;</span>);</span><br><span class="line">Debug.Log(<span class="string">&quot;Read VarTable from lua name:&#123;0&#125;&quot;</span>, table1[map.name]);<span class="comment">//会将map.name作为整体识别为键,值为nil，不会有任何输出</span></span><br><span class="line">table1[<span class="string">&quot;map.name&quot;</span>] = <span class="string">&quot;new&quot;</span>;<span class="comment">// table字符串只能为key,现在为“new”</span></span><br><span class="line">LuaTable table2 = (LuaTable)table[<span class="string">&quot;newmap&quot;</span>];</span><br></pre></td></tr></table></figure><p>对于lua元表也能使用LuaTable的GetMetaTable()方法来获取</p><p>对于变量的获取有一点值得注意：</p><p>如同注释中的那样，[]中的string会作为整体。lua语法中，如果有一个table A，那么A.x代表的是A[“x”],表示的是由字符串 “x”索引的表， 而a[x]表示的是变量x对应的值索引的表</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">a = &#123;&#125;</span><br><span class="line">x = &quot;y&quot;</span><br><span class="line">a[x] = 10</span><br><span class="line">a.x --&gt;nil 字段“x”的值，未定义</span><br><span class="line">a.y --&gt;10, 字段“y”的值</span><br></pre></td></tr></table></figure><p>因此如果想要C#正确获取的话，需要像下面这样：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">LuaTable table = lua.GetTable(<span class="string">&quot;varTable&quot;</span>);</span><br><span class="line">LuaTable map = (LuaTable)table[<span class="string">&quot;map&quot;</span>];</span><br><span class="line">Debugger.Log(<span class="string">&quot;Read varTable from lua,  name: &#123;0&#125;&quot;</span>, map[<span class="string">&quot;name&quot;</span>]);</span><br></pre></td></tr></table></figure><p>对LuaTable类型的变量，在使用完后需要手动释放内存，否则会因为内存未自动释放造成内存泄漏，具体方法为调用LuaTable对象的方法table.Dispose();</p><h2 id="GameObject"><a href="#GameObject" class="headerlink" title="GameObject"></a>GameObject</h2><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="built_in">string</span> script =</span><br><span class="line">    <span class="string">@&quot;                                    </span></span><br><span class="line"><span class="string">        local GameObject = UnityEngine.GameObject          </span></span><br><span class="line"><span class="string">        local ParticleSystem = UnityEngine.ParticleSystem            </span></span><br><span class="line"><span class="string">        local go = GameObject(&#x27;go&#x27;)</span></span><br><span class="line"><span class="string">        go:AddComponent(typeof(ParticleSystem))</span></span><br><span class="line"><span class="string">        local node = go.transform</span></span><br><span class="line"><span class="string">        node.position = Vector3.one      </span></span><br><span class="line"><span class="string">        print(&#x27;gameObject is: &#x27;..tostring(go))    </span></span><br><span class="line"><span class="string">        GameObject.Destroy(go, 2)                        </span></span><br><span class="line"><span class="string">    &quot;</span>;</span><br><span class="line">    </span><br><span class="line">LuaState lua = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Start</span>()</span></span><br><span class="line">&#123;        </span><br><span class="line">    lua = <span class="keyword">new</span> LuaState();</span><br><span class="line">    lua.LogGC = <span class="literal">true</span>;</span><br><span class="line">    lua.Start();</span><br><span class="line">    LuaBinder.Bind(lua);</span><br><span class="line">    lua.DoString(script);            </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Update</span>()</span>&#123;</span><br><span class="line">    lua.CheckTop();</span><br><span class="line">    lua.Collect();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>LuaBinder.Bind();  ——该方法需要传入一个 <code>LuaState</code> 类型参数。该方法会将 C# 代码中定义的类、方法、属性等绑定到该 Lua 模块中。这样，Lua 脚本就可以调用 C# 代码中定义的函数和属性，而 C# 代码也可以通过 Lua 脚本调用 Lua 中的函数和属性。</p><p>lua.Collect();——垃圾回收, 对于被自动gc的LuaFunction, LuaTable, 以及委托减掉的LuaFunction, 延迟删除的Object之类。等等需要延迟处理的回收, 都在这里自动执行</p><h1 id="lua调用C-函数"><a href="#lua调用C-函数" class="headerlink" title="lua调用C#函数"></a>lua调用C#函数</h1><p>如同 案例中的那样，</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">local</span> ParticleSystem = UnityEngine.ParticleSystem</span><br><span class="line"><span class="keyword">local</span> GameObject = UnityEngine.GameObjectlocal </span><br><span class="line">go = GameObject(<span class="string">&#x27;go&#x27;</span>)</span><br><span class="line">go:AddComponent(typeof(ParticleSystem))</span><br><span class="line"><span class="keyword">local</span> node = go.transform</span><br><span class="line">node.position = Vector3.one                  </span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;gameObject is: &#x27;</span>..<span class="built_in">tostring</span>(go))</span><br></pre></td></tr></table></figure><p>对于UnityEngine下的一部分方法，lua中可以直接引用。</p><h2 id="自定义脚本"><a href="#自定义脚本" class="headerlink" title="自定义脚本"></a>自定义脚本</h2><p>对于自己实现的脚本比较麻烦，首先需要调用 LuaBinder.Bind(LuaState lua) </p><p>其次需要将自定义的类写入CustomSetting.cs文件中，你将你的自定义类加入到customTypeList数组中的末尾，如果是静态类就还需加入staticClassTypes中。然后依次点击Lua菜单中的Clear wrap files 和Gen All</p><h2 id="自定义委托"><a href="#自定义委托" class="headerlink" title="自定义委托"></a>自定义委托</h2><p>只要需要使用到delegate字段，都要调用一次DelegateFactory.Init()，如果有自定义的委托还是要添加到CustomSetting.cs中的customDelegateList</p><p>如何给按钮动态添加监听事件？ 首先我们可以定义一个LuaHelper的静态类，在其中实现一个AddButtonClick的静态函数，NGUI中给按钮添加事件代码示例：EventDelegate.Add(UIButton.onclick, Call call)</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">AddButtonClick</span>(<span class="params">GameObject g,LuaFunction callback</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    EventDelegate.Add(g.GetComponent&lt;UIButton&gt;().onClick, callback.Call);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在lua代码中只需找到对应的游戏物体</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">local</span> helper = LuaHelper</span><br><span class="line"><span class="keyword">local</span> btn = UnityEngine.GameObject.Find(<span class="string">&quot;Button&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">local</span> <span class="function"><span class="keyword">function</span> <span class="title">Onclick</span><span class="params">()</span></span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;OnClick&quot;</span>)</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line">helper.AddButtonClick(btn,Onclick)</span><br></pre></td></tr></table></figure><p>Lua调用C#的规范就是不在Start周期函数中去做初始化，而是包装好初始化相关的函数，在lua中获取该函数在调用</p><h2 id="获取C-数组元素"><a href="#获取C-数组元素" class="headerlink" title="获取C#数组元素"></a>获取C#数组元素</h2><p>lua想要访问C#数组有几种方法，</p><ul><li>通过下标访问——这与C#中一致，而且还可以通过array.Length获取数组大小</li><li>通过迭代器访问——array:GetEnumerator()获取数组的迭代器，通过iter.Current获得当前的迭代器所指向的元素值，通过iter:MoveNext()将迭代器所指位置移至下一个</li><li>调用 array:ToTable() 实现将数组对象转化为对应的lua中的Table表的形式进行访问，注意lua数组下标从0开始</li></ul><p>C#中获得lua函数的返回值，可以通过func.Checkxxx()来获得</p><p>比如</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">double</span> arg1 = func.CheckNumber();<span class="comment">//获得func函数double类型的返回值</span></span><br><span class="line"><span class="built_in">string</span> arg2 = func.CheckString();<span class="comment">//获得func函数string类型的返回值</span></span><br><span class="line"><span class="comment">// 调用通用函数时需要转换类型，避免拆成多个参数</span></span><br><span class="line"><span class="built_in">object</span>[] objs = func.Invoke((<span class="built_in">object</span>)array);</span><br><span class="line"><span class="keyword">if</span> (objs != <span class="literal">null</span>)</span><br><span class="line">&#123;</span><br><span class="line">    Debugger.Log(<span class="string">&quot;return is &#123;0&#125; &#123;1&#125; &#123;2&#125;&quot;</span>, objs[<span class="number">0</span>], objs[<span class="number">1</span>], objs[<span class="number">2</span>]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="ToLua框架UML"><a href="#ToLua框架UML" class="headerlink" title="ToLua框架UML"></a>ToLua框架UML</h1><p>LuaState，LuaFunction、LuaTable</p><p>暂时无法在莉莉丝飞书文档外展示此内容</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;ToLua 是一个用于在 Unity 中为 Lua 提供 C# 语言绑定的框架。通过 ToLua，你可以方便地将 C# 代码暴露给 Lua 脚本，并在 Lua 脚本中调用 C# 类、方法和属性。&lt;/p&gt;
&lt;h1 id=&quot;更新流程&quot;&gt;&lt;a href=&quot;#更新流程&quot; class=&quot;headerlink&quot; title=&quot;更新流程&quot;&gt;&lt;/a&gt;更新流程&lt;/h1&gt;&lt;p&gt;原理：使用AssetBundle进行资源的更新，而由于lua运行时才编译的特性，所以lua文件也可以被看成是一种资源文件（与fbx、Image等一样）可以打进ab包中&lt;/p&gt;
&lt;p&gt;流程：&lt;/p&gt;
&lt;p&gt;游戏运行时从服务器下载files.txt清单文件,与本地的files.txt清单文件进行对比。如果新下载的files里面的md5值与本地files的md5值不一样,或者本地清单里没有对应文件，那么就从服务器下载AB包，然后解压进行初始化&lt;/p&gt;
&lt;h1 id=&quot;LuaState&quot;&gt;&lt;a href=&quot;#LuaState&quot; class=&quot;headerlink&quot; title=&quot;LuaState&quot;&gt;&lt;/a&gt;LuaState&lt;/h1&gt;&lt;p&gt;C#能调用lua的原理就是创建了一个lua虚拟机，LuaState封装了对lua 主要数据结构 lua_State 指针的各种堆栈操作。&lt;/p&gt;</summary>
    
    
    
    
    <category term="lua" scheme="https://ycy666666.github.io/tags/lua/"/>
    
  </entry>
  
  <entry>
    <title>CICD中的jenkins和ansible解决方案</title>
    <link href="https://ycy666666.github.io/2023/04/29/CICD%E4%B8%AD%E7%9A%84jenkins%E5%92%8Cansible%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/"/>
    <id>https://ycy666666.github.io/2023/04/29/CICD%E4%B8%AD%E7%9A%84jenkins%E5%92%8Cansible%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/</id>
    <published>2023-04-29T12:59:11.000Z</published>
    <updated>2023-04-29T13:13:10.287Z</updated>
    
    <content type="html"><![CDATA[<p>每一次重装系统或者是需要在服务器上正确运行软件，我们都需要重新安装所有的package、dependency并进行相应配置的微调。而这一过程可能就会因为疏忽导致错误，因此需要自动化部署</p><p>持续整合，持续交付（CI/CD）的实践，我们能够周期性的对产品进行各种专业测试，如果出现问题我们也能快速找到发生问题的最近位置。同时我们还能进行报表分析和自动通知等其他操作</p><h1 id="Ansible"><a href="#Ansible" class="headerlink" title="Ansible"></a>Ansible</h1><p>ansible就是这样一款主流的自动化部署工具，要通过ansible在被控节点（managed node）上配置环境，我们需要安装Pyhton然后通过SSH连线。</p><span id="more"></span><h2 id="安装过程"><a href="#安装过程" class="headerlink" title="安装过程"></a>安装过程</h2><p>Ansible当中，所有机器分为以下两类：</p><ul><li>控制主机（Control Machine）： 这类主机能通过Ansible的playbook（剧本）对被控节点进行部署</li><li>被控节点（Managed Machine）：又称Remote Node，这类节点就是我们通过Ansible进行部署的对象</li></ul><p><strong>值得注意的是，Ansible并不用安装在被控主机上，只需要保证能通过SSH与Control Machine沟通就可以了</strong></p><h2 id="playbook"><a href="#playbook" class="headerlink" title="playbook"></a>playbook</h2><p>我们使用playbook，这一由YAML编写的程序，来告诉Ansible需要做什么。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="bullet">-</span> <span class="attr">hosts:</span> <span class="string">server</span></span><br><span class="line">  <span class="attr">tasks:</span></span><br><span class="line">    <span class="comment"># task 1</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">test</span> <span class="string">connection</span></span><br><span class="line">      <span class="attr">ping:</span></span><br><span class="line">      <span class="attr">register:</span> <span class="string">message</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># task 2</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">print</span> <span class="string">debug</span> <span class="string">message</span></span><br><span class="line">      <span class="attr">debug:</span></span><br><span class="line">        <span class="attr">msg:</span> <span class="string">&quot;<span class="template-variable">&#123;&#123; message &#125;&#125;</span>&quot;</span></span><br></pre></td></tr></table></figure><p>task1中，调用了ansible内置模块-ping，用于测试控制主机能否与被控节点连线。如果正常，会回传“pong”信息，然后我们能通过register将被控主机回传的消息存贮在message变量中</p><p>task2中，利用debug方法将message输出到终端上</p><h3 id="如何运行playbook"><a href="#如何运行playbook" class="headerlink" title="如何运行playbook"></a>如何运行playbook</h3><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ansible<span class="literal">-playbook</span> playbook.yml</span><br></pre></td></tr></table></figure><p>但是这样ansible并不会做任何task，因为ansible应该对hosts指定的server来执行task。但是我们并没有告诉ansible哪一台是server，因此需要一个inventory来让ansible参考，具体编写需要先在ansible的config中指定inventory路径。</p><p>但是呢，不同的部署环境（比如test、development、producting）需要不同的配置细节，因此我们就可以定义多个inventory file，然后通过以下指令来实现部署</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$</span> ansible<span class="literal">-playbook</span> <span class="literal">-i</span> devl<span class="literal">-inventory</span> devl<span class="literal">-playbook</span>.yml</span><br><span class="line"><span class="variable">$</span> ansible<span class="literal">-playbook</span> <span class="literal">-i</span> prod<span class="literal">-inventory</span> prod<span class="literal">-playbook</span>.yml</span><br></pre></td></tr></table></figure><p>当然也可以写在同一文件中使用[]标识</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">[<span class="string">test</span>]</span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span> <span class="string">ansible_port=2222</span> <span class="string">ansible_user=test_user</span></span><br><span class="line"></span><br><span class="line">[<span class="string">test:vars</span>]</span><br><span class="line"><span class="string">email_receivers=test@gmail.com</span></span><br><span class="line"></span><br><span class="line">[<span class="string">devl</span>]</span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span> <span class="string">ansible_port=2222</span> <span class="string">ansible_user=devl_user</span></span><br><span class="line"></span><br><span class="line">[<span class="string">devl:vars</span>]</span><br><span class="line"><span class="string">email_receivers=devl@gmail.com</span></span><br></pre></td></tr></table></figure><h2 id="Ansible-Role"><a href="#Ansible-Role" class="headerlink" title="Ansible Role"></a>Ansible Role</h2><p>我们可以通过自定义的role来使playbook重复使用，以此来是一部分部署资源能被重复使用</p><p>Ansible会在下列路径寻找可执行roles：</p><ol><li>与playbook同一层额roles文件夹</li><li>/etc/ansible/roles</li></ol><p>例如</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">workspace</span><br><span class="line">├── inventory</span><br><span class="line">├── playbook.yml</span><br><span class="line">└── roles</span><br><span class="line">    └── pip</span><br><span class="line">        └── tasks</span><br><span class="line">            └── main.yml</span><br></pre></td></tr></table></figure><p>表示pip是第一个role的名称，然后工作流程定义在tasks/main.yml中</p><p>playbook中改为以下内容</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">---</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">hosts:</span> <span class="string">server</span></span><br><span class="line">    <span class="attr">roles:</span></span><br><span class="line">      <span class="bullet">-</span> &#123; <span class="attr">role:</span> <span class="string">pip</span>, <span class="attr">become:</span> <span class="literal">yes</span> &#125;</span><br></pre></td></tr></table></figure><h1 id="Jenkins"><a href="#Jenkins" class="headerlink" title="Jenkins"></a>Jenkins</h1><p>当前安装Jenkins的方法有许多，其中一种比较好的是利用docker来进行。因为容器本身比较轻量，资源远少于启动虚拟机；而且容器之间资源相互隔离，不存在相互污染。</p><h2 id="Jenkins-Job"><a href="#Jenkins-Job" class="headerlink" title="Jenkins Job"></a>Jenkins Job</h2><p>Job（任务）是构建持续集成流程的基本单元，Job 可以包括多个构建步骤，例如源码管理、构建、测试和发布等。</p><p>Job 的用途主要包括以下几个方面：</p><ol><li>构建持续集成流程：通过 Job，可以将代码拉取、构建、测试和部署等步骤串联起来，从而构建出一个完整的持续集成流程。这样可以实现快速、自动化的构建和部署，提高软件开发的效率和质量。</li><li>自动化测试：Job 中可以包含自动化测试步骤，例如单元测试、集成测试和端到端测试等。自动化测试可以在构建过程中自动运行，从而及早发现代码错误，减少测试成本和时间。</li><li>构建报告和通知：Job 运行后，可以生成各种构建报告，例如测试报告、代码覆盖率报告和构建日志等。同时，Jenkins 还支持各种通知方式在构建失败或成功后通知相关人员。</li><li>构建流水线：多个 Job 可以通过 Jenkins 提供的 Pipeline 功能串联起来，形成一个完整的构建流水线，实现多个 Job 的协同工作</li></ol>]]></content>
    
    
    <summary type="html">&lt;p&gt;每一次重装系统或者是需要在服务器上正确运行软件，我们都需要重新安装所有的package、dependency并进行相应配置的微调。而这一过程可能就会因为疏忽导致错误，因此需要自动化部署&lt;/p&gt;
&lt;p&gt;持续整合，持续交付（CI/CD）的实践，我们能够周期性的对产品进行各种专业测试，如果出现问题我们也能快速找到发生问题的最近位置。同时我们还能进行报表分析和自动通知等其他操作&lt;/p&gt;
&lt;h1 id=&quot;Ansible&quot;&gt;&lt;a href=&quot;#Ansible&quot; class=&quot;headerlink&quot; title=&quot;Ansible&quot;&gt;&lt;/a&gt;Ansible&lt;/h1&gt;&lt;p&gt;ansible就是这样一款主流的自动化部署工具，要通过ansible在被控节点（managed node）上配置环境，我们需要安装Pyhton然后通过SSH连线。&lt;/p&gt;</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>Unity打包流程</title>
    <link href="https://ycy666666.github.io/2023/04/29/Unity%E6%89%93%E5%8C%85%E6%B5%81%E7%A8%8B/"/>
    <id>https://ycy666666.github.io/2023/04/29/Unity%E6%89%93%E5%8C%85%E6%B5%81%E7%A8%8B/</id>
    <published>2023-04-29T12:58:43.000Z</published>
    <updated>2023-04-29T13:13:25.425Z</updated>
    
    <content type="html"><![CDATA[<h1 id="一般打包流程"><a href="#一般打包流程" class="headerlink" title="一般打包流程"></a><strong>一般打包流程</strong></h1><p>通常打包流程主要是通过 <code>Building setting</code>来选择需要打包的场景后出包到指定文件夹位置，也可以采用 <code>[MenuItem(&quot;MyMenu/Do Something&quot;)]</code>中使用static函数来选择打包路径和打包方式——需要将该脚本放置在 <code>Editor</code>文件夹下</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[<span class="meta">MenuItem(<span class="string">&quot;Test/BuildAndroid&quot;</span>)</span>]</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">BuildAndroid</span>()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">string</span> path = Path.GetFullPath(<span class="string">&quot;D:\\Packages&quot;</span>) + <span class="string">&quot;/Backbag&quot;</span> + <span class="string">&quot;.apk&quot;</span>;</span><br><span class="line">    BuildPipeline.BuildPlayer(GetBuildScence(), path, BuildTarget.Android, BuildOptions.None);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="命令行控制"><a href="#命令行控制" class="headerlink" title="命令行控制"></a><strong>命令行控制</strong></h2><ol><li>Launching Unity</li><li>首先我们需要在<code>Unity.exe</code>所在目录下执行</li><li>选择对应Option</li></ol><span id="more"></span><h3 id="命令语句解释"><a href="#命令语句解释" class="headerlink" title="命令语句解释"></a><strong>命令语句解释</strong></h3><div class="table-container"><table><thead><tr><th>命令语句</th><th>解释</th></tr></thead><tbody><tr><td>-batchmode</td><td>以批处理模式运行 Unity。在批处理模式下，Unity 无需人为操作即可运行命令行参数。它还抑制了部分弹出窗口（例如“保存场景”窗口）；但是，Unity 编辑器本身会照常打开。使用命令行参数时，您应该始终以批处理模式运行 Unity，因为它允许自动化不间断地运行</td></tr><tr><td>-quit</td><td>其他命令执行完毕后将退出Unity编辑器。但会导致错误消息被隐藏（显示在Editor.log文件）</td></tr><tr><td>-executeMethod <ClassName.MethodName></ClassName.MethodName></td><td>Unity 打开项目后立即执行静态方法，并在可选的资产服务器更新完成后执行。执行方法所在脚本必须在Editor文件中而且是static的。要从命令行进程返回错误，要么抛出异常导致 Unity 退出并返回代码 1，要么调用 EditorApplication.Exit 并返回非零代码</td></tr></tbody></table></div><p>此外Unity Standalone Player平台中也能执行一些参数（官方文档中指Mac、Windows和Linux）</p><p>要在从命令行以批处理模式启动输入 <code>PATH_TO_STANDALONE_BUILD -projectPath PROJECT_PATH -batchMode</code></p><p>比如 <code>C:\projects\myproject\builds\myproject.exe</code><strong><code>-batchMode</code></strong></p><div class="table-container"><table><thead><tr><th>命令语句</th><th>解释</th></tr></thead><tbody><tr><td>-batchmode</td><td>在”headless”模式下运行游戏。游戏将不显示任何内容，或接受用户输入。主要作用于网络游戏的服务器</td></tr><tr><td>-single-instance (Linux and Windows only)</td><td>同一时候只允许一个游戏实例运行。如果另一个实例已在运行，然后再次通过 -single-instance启动它的话会调节到现有的这个实例</td></tr><tr><td>-force-(…)</td><td>强制性的使用规定的渲染方式（DirectX 、Metal、OpenGL等 ）</td></tr><tr><td>-screen-(…)</td><td>重新规定屏幕的大小或者是出现方式（弹窗或全屏）</td></tr></tbody></table></div><h1 id="Player-Setting——PC"><a href="#Player-Setting——PC" class="headerlink" title="Player Setting——PC"></a><strong>Player Setting——PC</strong></h1><p>Player Settings提供了各种选项来帮助你完成最终游戏的出包，虽然说有很多不同的平台，但是大体上的设置会分为以下几个部分</p><h2 id="Icon"><a href="#Icon" class="headerlink" title="Icon"></a><strong>Icon</strong></h2><p>图标，在桌面上显示的默认图标</p><h2 id="Resolution-and-Presentation"><a href="#Resolution-and-Presentation" class="headerlink" title="Resolution and Presentation"></a><strong>Resolution and Presentation</strong></h2><p>分辨率和启动前窗口设置，包括了支持的分辨率比例和是否默认全屏启动等选项；</p><h3 id="Resolution"><a href="#Resolution" class="headerlink" title="Resolution"></a><strong>Resolution</strong></h3><p><img src="/2023/04/29/Unity%E6%89%93%E5%8C%85%E6%B5%81%E7%A8%8B/168277357919210.png" alt="img"></p><ul><li>Fullscreen Mode ： 选择默认窗口模式</li><li><strong>Default Is Native Resolution</strong> ： 是游戏以默认的分辨率启动，取消勾选后可以强制游戏的分辨率。但是有一点，如果你的游戏已经打包启动过了，那下次再打包强制分辨率就没有意义了，因为Windows会将该应用最后的分辨率记录到注册表中。此时有三种解决方案：</li><li>1.改变应用的名称或公司；</li><li>2.在代码中直接控制分辨率；</li><li>3.使用Unity自带的启动前分辨率设置小窗口。</li><li>Mac Retina Support：可以使游戏在Mac高DPI的屏幕上显示的更加清晰，但是可能会占用更多的资源；</li><li><strong>Run in background</strong>：在游戏失去焦点时仍旧继续运行不会暂停，联网游戏肯定要勾选；</li></ul><h3 id="Standalone-Player-Options"><a href="#Standalone-Player-Options" class="headerlink" title="Standalone Player Options"></a><strong>Standalone Player Options</strong></h3><p><img src="/2023/04/29/Unity%E6%89%93%E5%8C%85%E6%B5%81%E7%A8%8B/16827735791901.png" alt="img"></p><p>此部分允许指定用户如何自定义屏幕。 例如可以在此处确定用户是否可以调整屏幕大小以及可以并发运行多少个实例。</p><ul><li>Capture Single Screen: 启用此选项可确保全屏模式下的独立游戏不会使多显示器设置中的辅助显示器变暗。</li><li><strong>Use Player Log</strong>:  将所有Debug.Log的信息输入到一个log文件中，默认勾选</li><li>Resizable Window: 允许玩家可以重新调整游戏窗口的大小；</li><li>Visible in Background:  即使在后台任然能正常显示</li><li><strong>Force Single Instance</strong> ： 一台主机只能由一个运行实例</li><li>Supported Aspect Ratios： 支持的纵横比</li></ul><h2 id="Splash-Image"><a href="#Splash-Image" class="headerlink" title="Splash Image"></a><strong>Splash Image</strong></h2><p>初始图象，设置允许为独立平台指定启动图像</p><p><img src="/2023/04/29/Unity%E6%89%93%E5%8C%85%E6%B5%81%E7%A8%8B/16827735791912.png" alt="img"></p><h2 id="Other-Setting"><a href="#Other-Setting" class="headerlink" title="Other Setting"></a><strong>Other Setting</strong></h2><h3 id="Rendering"><a href="#Rendering" class="headerlink" title="Rendering"></a><strong>Rendering</strong></h3><p><img src="/2023/04/29/Unity%E6%89%93%E5%8C%85%E6%B5%81%E7%A8%8B/16827735791913.png" alt="img"></p><ul><li><strong>Color Space：</strong>颜色空间，很重要的选项，手机上只能选择Gamma，而一般3A大作都是Linear，Linear显示效果更加真实</li><li>Auto Graphics API for Windows/ Mac/ Linux:  自动选择最佳的图形API，如果不勾选，可以自行添加支持的图形API</li><li><strong>Static Batching</strong>:  静态批处理。——将静态（非移动）游戏对象组合成大网格，并以更快的方式渲染它们</li><li><strong>Dynamic Batching</strong>：动态批处理，自动化Unity进程，一次性批量化渲染多个网络以优化图形性能，该技术转换 CPU 上的所有 GameObject 顶点并将许多相似的顶点组合在一起。 （当可编程渲染管线处于活动状态时，动态批处理没有效果）</li><li>GPU Skinning / Compute Skinning : 使用GPU处理骨骼与皮肤联系的过程,释放CPU资源</li><li><strong>Graphics Jobs</strong> ： 可以使游戏将一些渲染任务交给其他CPU核心进行处理，增加游戏的处理效率</li><li>Frame Timing Stats： 帧时序状态。启用此属性以收集 CPU 和 GPU 帧时间统计信息。 将其与动态分辨率相机设置一起使用以确定您的应用程序是 CPU 还是 GPU 受限。</li></ul><h3 id="Configuration（配置）"><a href="#Configuration（配置）" class="headerlink" title="Configuration（配置）"></a><strong>Configuration（配置）</strong></h3><p><img src="/2023/04/29/Unity%E6%89%93%E5%8C%85%E6%B5%81%E7%A8%8B/16827735791914.png" alt="img"></p><ul><li><strong>Scripting Backend</strong>： 选择项目中编译和执行 C# 代码的方式。Unity 根据目标平台支持三种不同的脚本后端：Mono、.NET 和 IL2CPP。 通用 Windows 平台仅支持两种：.NET 和 IL2CPP。<ul><li><em>Mono</em>： 将 C# 代码编译成 .NET 通用中间语言 (CIL) 并使用通用语言运行时执行该 CIL</li><li><em>IL2CPP</em>： 将 C# 代码编译为 CIL，将 CIL 转换为 C++，然后将 C++ 编译为本机代码，在运行时直接执行。</li></ul></li><li><strong>API</strong> <strong>Compatibility Level</strong>： 选择在项目中使用的 .NET API。 此设置会影响第三方库的兼容性。</li><li>Use incremental GC：使用增量垃圾收集器，它将垃圾收集分布在多个帧上，以减少与 gc 相关的帧持续时间峰值。</li></ul><h3 id="Script-Compilation"><a href="#Script-Compilation" class="headerlink" title="Script Compilation"></a><strong>Script Compilation</strong></h3><p><img src="/2023/04/29/Unity%E6%89%93%E5%8C%85%E6%B5%81%E7%A8%8B/16827735791915.png" alt="img"></p><ul><li>Allow ‘unsafe’ Code： 启用对在预定义程序集中编译“不安全”C# 代码的支持（例如，Assembly-CSharp.dll）。</li><li><strong>Use Deterministic Compilation</strong>： 禁用此设置以防止使用 -deterministic C# 标志进行编译。 启用此设置后，编译后的程序集在每次编译时都是逐字节相同的。</li></ul><p>以及一部分涉及到Roslyn Analyzers的选项，它可以静态地分析代码，并在代码中检测到潜在的错误、漏洞和优化机会</p><h4 id="Scripting-Define-Symbols"><a href="#Scripting-Define-Symbols" class="headerlink" title="Scripting Define Symbols"></a><strong>Scripting Define Symbols</strong></h4><p>脚本编译时的标志设置，能够根据定义在编译阶段包含或者剔除一些代码，示例代码：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">if</span> UNITY_STANDALONE_WIN</span></span><br><span class="line"></span><br><span class="line">  Debug.Log(<span class="string">&quot;Standalone Windows&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure><p><strong>Platform scripting symbols</strong>：（平台标识）</p><div class="table-container"><table><thead><tr><th>定义</th><th>含义</th></tr></thead><tbody><tr><td>UNITY_EDITOR</td><td>用于从游戏脚本调用Editor下的符号</td></tr><tr><td>UNITY_EDITOR_XXX</td><td>在XXX平台上的Editor时编译/执行代码</td></tr><tr><td>UNITY_STANDALONE</td><td>在任意独立平台（Mac OS X, Windows or Linux）上的应用中编译/执行的代码</td></tr><tr><td>UNITY_STANDALONE_XXX</td><td>在XXX平台上的应用中编译/执行的代码</td></tr><tr><td>UNITY_XXX</td><td>在XXX平台（除了独立平台外）上的编译/执行的代码</td></tr></tbody></table></div><p><strong>Editor version Scripting symbols</strong>：（引擎版本标识）</p><p>可选择unity版本号，可具体到X_Y_Z任意版本</p><div class="table-container"><table><thead><tr><th>UNITY_2019</th><th>Unity2019版本，包括2019.Y.Z等所有版本</th></tr></thead><tbody><tr><td>UNITY_2019_4</td><td>Unity2019.4版本，包括2019.4.Z等所有版本</td></tr><tr><td>UNITY_2019_4_14</td><td>Unity2019.4.14版本</td></tr></tbody></table></div><p><strong>其余标识</strong>：</p><div class="table-container"><table><thead><tr><th>定义</th><th>含义</th></tr></thead><tbody><tr><td>CSHARP_7_3_OR_NEWER</td><td>支持 C# 7.3 及以上版本</td></tr><tr><td>ENABLE_MONO</td><td>编译方式为Mono.</td></tr><tr><td>ENABLE_IL2CPP</td><td>S编译方式为IL2CPP .</td></tr><tr><td>NET_X_Y</td><td>在Mono和IL2CPP上针对Net对应版本API兼容性生成脚本</td></tr><tr><td>UNITY_SERVER</td><td>在Build Setting勾选Server Build选项</td></tr></tbody></table></div><h3 id="Optimization-（优化）"><a href="#Optimization-（优化）" class="headerlink" title="Optimization （优化）"></a><strong>Optimization （优化）</strong></h3><p><img src="/2023/04/29/Unity%E6%89%93%E5%8C%85%E6%B5%81%E7%A8%8B/16827735791916.png" alt="img"></p><ul><li><strong>Prebake Collision Meshes</strong>：只在build游戏时添加碰撞盒；</li><li>Keep Loaded Shaders Alive：保证Shader不会被卸载；</li><li><strong>Preloader Assets</strong>：预先读取的Assets列表；</li><li><strong>Managed Stripping Level</strong>： 决定Unity剥离未使用的托管代码的程度。这会使生成的可执行文件变小，但可能导致错误移除实际上使用的代码</li><li><strong>Vertex Compression</strong>： 顶点压缩，选择模型会压缩的数据，比如可以选择everything，然后去掉positions和lightmap UVs。当然每个模型在导入时，该参数可以设置独立，会覆盖掉该选项</li><li>Optimize Mesh Data： 优化Mesh数据，勾选该选项会移除材质所不需要的Mesh数据，例如tangents、normals、colors、UV。</li></ul><h3 id="Logging"><a href="#Logging" class="headerlink" title="Logging"></a><strong>Logging</strong></h3><p><img src="/2023/04/29/Unity%E6%89%93%E5%8C%85%E6%B5%81%E7%A8%8B/16827735791917.png" alt="img"></p><p>可以选择在运行脚本（ScriptOnly）、任何时候（Full）或者是从不（None）的时间选择记录类型</p><h1 id="Player-Setting——Android"><a href="#Player-Setting——Android" class="headerlink" title="Player Setting——Android"></a><strong>Player Setting——Android</strong></h1><p>大多数比较类似，只介绍重要的差异部分</p><h2 id="Resolution-and-Presentation-1"><a href="#Resolution-and-Presentation-1" class="headerlink" title="Resolution and Presentation"></a><strong>Resolution and Presentation</strong></h2><h3 id="Orientation"><a href="#Orientation" class="headerlink" title="Orientation"></a><strong>Orientation</strong></h3><p>方向， 自定义与设备上应用程序方向相关的设置。</p><p><img src="/2023/04/29/Unity%E6%89%93%E5%8C%85%E6%B5%81%E7%A8%8B/16827735791918.png" alt="img"></p><div class="table-container"><table><thead><tr><th>Setting</th><th>Description</th></tr></thead><tbody><tr><td>Portrait</td><td>纵向，底部与设备顶部对齐</td></tr><tr><td>Portrait Upside Down</td><td>纵向，底部与设备底部对齐</td></tr><tr><td>Landscape Right</td><td>横向，左侧与设备顶部对齐</td></tr><tr><td>Landscape Left</td><td>横向，右侧与设备顶部对齐</td></tr><tr><td>Auto Rotation</td><td>屏幕可以旋转到您在“Allowed Orientations for Auto Rotation”部分中指定的任何方向。</td></tr></tbody></table></div><h2 id="Other-Setting-1"><a href="#Other-Setting-1" class="headerlink" title="Other Setting"></a><strong>Other Setting</strong></h2><h3 id="Identification"><a href="#Identification" class="headerlink" title="Identification"></a><strong>Identification</strong></h3><p><img src="/2023/04/29/Unity%E6%89%93%E5%8C%85%E6%B5%81%E7%A8%8B/16827735791919.png" alt="img"></p><div class="table-container"><table><thead><tr><th>Property</th><th>Function</th></tr></thead><tbody><tr><td>Override Default Package Name</td><td>表示是否替换掉应用的默认包名——同样会影响macOS，IOS和Android</td></tr><tr><td>Package Name</td><td>设置应用程序 ID，它可以在设备和 Google Play 商店中唯一标识您的应用程序。 应用程序 ID 必须遵循约定 com.YourCompanyName.YourProductName 并且必须仅包含字母数字和下划线字符。 每个段必须以字母字符开头。</td></tr><tr><td>Version</td><td>输入捆绑包的构建版本号，它标识捆绑包的迭代（已发布或未发布） 版本，以包含由点分隔的数字的字符串的通用格式指定（例如，4.3.2）( iOS 和Android共享)</td></tr><tr><td>Bundle Version Code</td><td>内部版本号，只用于比较哪个版本更新（数字大表示最新）,并不展示给用户。可以见x.y转换为整数或者是每次发布版本简单的加1</td></tr></tbody></table></div>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;一般打包流程&quot;&gt;&lt;a href=&quot;#一般打包流程&quot; class=&quot;headerlink&quot; title=&quot;一般打包流程&quot;&gt;&lt;/a&gt;&lt;strong&gt;一般打包流程&lt;/strong&gt;&lt;/h1&gt;&lt;p&gt;通常打包流程主要是通过 &lt;code&gt;Building setting&lt;/code&gt;来选择需要打包的场景后出包到指定文件夹位置，也可以采用 &lt;code&gt;[MenuItem(&amp;quot;MyMenu/Do Something&amp;quot;)]&lt;/code&gt;中使用static函数来选择打包路径和打包方式——需要将该脚本放置在 &lt;code&gt;Editor&lt;/code&gt;文件夹下&lt;/p&gt;
&lt;figure class=&quot;highlight c#&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;[&lt;span class=&quot;meta&quot;&gt;MenuItem(&lt;span class=&quot;string&quot;&gt;&amp;quot;Test/BuildAndroid&amp;quot;&lt;/span&gt;)&lt;/span&gt;]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;BuildAndroid&lt;/span&gt;()&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;built_in&quot;&gt;string&lt;/span&gt; path = Path.GetFullPath(&lt;span class=&quot;string&quot;&gt;&amp;quot;D:\\Packages&amp;quot;&lt;/span&gt;) + &lt;span class=&quot;string&quot;&gt;&amp;quot;/Backbag&amp;quot;&lt;/span&gt; + &lt;span class=&quot;string&quot;&gt;&amp;quot;.apk&amp;quot;&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    BuildPipeline.BuildPlayer(GetBuildScence(), path, BuildTarget.Android, BuildOptions.None);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h2 id=&quot;命令行控制&quot;&gt;&lt;a href=&quot;#命令行控制&quot; class=&quot;headerlink&quot; title=&quot;命令行控制&quot;&gt;&lt;/a&gt;&lt;strong&gt;命令行控制&lt;/strong&gt;&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;Launching Unity&lt;/li&gt;
&lt;li&gt;首先我们需要在&lt;code&gt;Unity.exe&lt;/code&gt;所在目录下执行&lt;/li&gt;
&lt;li&gt;选择对应Option&lt;/li&gt;
&lt;/ol&gt;</summary>
    
    
    
    
    <category term="Unity" scheme="https://ycy666666.github.io/tags/Unity/"/>
    
  </entry>
  
  <entry>
    <title>lua面向对象</title>
    <link href="https://ycy666666.github.io/2022/12/26/lua%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/"/>
    <id>https://ycy666666.github.io/2022/12/26/lua%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/</id>
    <published>2022-12-26T14:26:47.000Z</published>
    <updated>2023-04-29T13:12:25.032Z</updated>
    
    <content type="html"><![CDATA[<h1 id="简单的类实现"><a href="#简单的类实现" class="headerlink" title="简单的类实现"></a>简单的类实现</h1><p>LUA中最基本的结构是table，用table来描述对象的属性。lua 中的 function 可以用来表示方法。</p><p><strong>那么LUA中的类可以通过 table + function 模拟出来。</strong></p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">Student = &#123;</span><br><span class="line">    age = <span class="number">1</span>,</span><br><span class="line">    growUp = <span class="function"><span class="keyword">function</span><span class="params">()</span></span></span><br><span class="line">        <span class="comment">-- print(age) 这样写与表中没有任何关系，他打印age这个全局变量</span></span><br><span class="line">        <span class="comment">-- 一定要调用表名.属性来指明是谁做的</span></span><br><span class="line">        <span class="built_in">print</span>(Student.age)</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">-- 声明表之后 ，仍可以在表外生命变量和方法</span></span><br><span class="line">Student.name = <span class="string">&quot;Name&quot;</span></span><br><span class="line">Student.Speak = <span class="function"><span class="keyword">function</span><span class="params">()</span></span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;说话&quot;</span>)</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 第三种函数的声明方法</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Student.Speak2</span><span class="params">()</span></span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;说话2&quot;</span>)</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 使用冒号 : 来将调用时冒号前的变量作为self</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Student:Speak3</span><span class="params">()</span></span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">self</span>.name..<span class="string">&quot;说话3&quot;</span>)</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(Student.age)</span><br><span class="line">Student.Speak()</span><br><span class="line">Student.Speak2()</span><br><span class="line">Student:Speak3() <span class="comment">-- Student 作为self</span></span><br><span class="line"><span class="comment">--[[输出结果</span></span><br><span class="line"><span class="comment">1</span></span><br><span class="line"><span class="comment">说话</span></span><br><span class="line"><span class="comment">说话2</span></span><br><span class="line"><span class="comment">Name说话3</span></span><br><span class="line"><span class="comment">--]]</span></span><br></pre></td></tr></table></figure><span id="more"></span><h1 id="Lua封装"><a href="#Lua封装" class="headerlink" title="Lua封装"></a>Lua封装</h1><p>类都是基于table来实现的</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">Object = &#123;&#125;</span><br><span class="line">Object.id = <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 冒号 会自动调用这个函数的对象，作为第一个参数传入</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Object:new</span><span class="params">()</span></span></span><br><span class="line">    <span class="comment">-- self 表示我们默认传入的第一个参数</span></span><br><span class="line">    <span class="keyword">local</span> obj = &#123;&#125;</span><br><span class="line">    <span class="comment">--__index当找不到自己的变量时就去元表当中查找__index指向的内容</span></span><br><span class="line">    <span class="built_in">self</span>.<span class="built_in">__index</span> = <span class="built_in">self</span></span><br><span class="line">    <span class="built_in">setmetatable</span>(obj, <span class="built_in">self</span>)</span><br><span class="line">    <span class="comment">-- 返回出去的本质上是表对象</span></span><br><span class="line">    <span class="keyword">return</span> obj</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Object:Test</span><span class="params">()</span></span></span><br><span class="line">    <span class="built_in">print</span>(<span class="built_in">self</span>.id)</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">local</span> myObj = Object:new()</span><br><span class="line"><span class="built_in">print</span>(myObj)</span><br><span class="line"><span class="built_in">print</span>(myObj.id)</span><br><span class="line">myObj:Test()</span><br><span class="line"></span><br><span class="line"><span class="comment">--[[输出</span></span><br><span class="line"><span class="comment">table: 00B09730</span></span><br><span class="line"><span class="comment">1</span></span><br><span class="line"><span class="comment">1--]]</span></span><br></pre></td></tr></table></figure><p>myObj就是个空表，但是因为指定了__index所以会返回Object中的id</p><h1 id="Lua继承"><a href="#Lua继承" class="headerlink" title="Lua继承"></a>Lua继承</h1><p>继承是指一个对象直接使用另一对象的属性和方法。可用于扩展基础类的属性和方法。</p><p>以下演示了一个简单的继承实例, 沿用Lua封装中的代码</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Object:subClass</span><span class="params">(className)</span></span></span><br><span class="line">    <span class="comment">-- 大G表存储了所有的非local变量，相当于创建了一个名为className的空表</span></span><br><span class="line">    <span class="built_in">_G</span>[className] = &#123;&#125;</span><br><span class="line">    <span class="comment">-- 写继承相关的规则</span></span><br><span class="line">    <span class="keyword">local</span> obj = <span class="built_in">_G</span>[className]</span><br><span class="line">    <span class="comment">-- 将元表的index设为自己，这样obj找不到某个值时会去传入的self查找</span></span><br><span class="line">    <span class="built_in">self</span>.<span class="built_in">__index</span> = <span class="built_in">self</span></span><br><span class="line">    <span class="comment">-- 给子类定义base属性代表父类</span></span><br><span class="line">    obj.base = <span class="built_in">self</span></span><br><span class="line">    <span class="built_in">setmetatable</span>(obj, <span class="built_in">self</span>)</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">Object:subClass(<span class="string">&quot;Person&quot;</span>)</span><br><span class="line"><span class="keyword">local</span> p1 = Person:new()</span><br><span class="line"><span class="built_in">print</span>(p1.id)</span><br><span class="line">p1.id = <span class="number">100</span></span><br><span class="line"><span class="built_in">print</span>(p1.id)</span><br><span class="line">p1:Test()</span><br><span class="line"></span><br><span class="line">Object:subClass(<span class="string">&quot;Monster&quot;</span>)</span><br><span class="line"><span class="keyword">local</span> m1 = Monster:new()</span><br><span class="line"><span class="built_in">print</span>(m1.id)</span><br><span class="line">m1.id = <span class="number">200</span></span><br><span class="line"><span class="built_in">print</span>(m1.id)</span><br><span class="line">m1:Test()</span><br><span class="line"></span><br><span class="line"><span class="comment">--[[输出结果</span></span><br><span class="line"><span class="comment">1</span></span><br><span class="line"><span class="comment">100</span></span><br><span class="line"><span class="comment">100</span></span><br><span class="line"><span class="comment">1</span></span><br><span class="line"><span class="comment">200</span></span><br><span class="line"><span class="comment">200--]]</span></span><br></pre></td></tr></table></figure><blockquote><p><strong>引用参数self:</strong>指向<strong>调用者自身</strong>,相当于this指针</p><p><strong>冒号引用：</strong>self指针指向冒号之前的对象，相当于把将独显赋值给self。</p><p>总之就相当于 <strong>冒号定义的函数如果用点来调用，那么第一个参数就视为self</strong></p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">myclass = &#123;age = <span class="number">10</span>, name=<span class="string">&quot;aa&quot;</span>&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">myclass:fun</span><span class="params">(p)</span></span></span><br><span class="line"> <span class="built_in">print</span>(<span class="built_in">self</span>)</span><br><span class="line"> <span class="built_in">print</span>(<span class="built_in">self</span>.age)</span><br><span class="line"> <span class="built_in">print</span>(p)</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">myclass:fun(<span class="string">&quot;22&quot;</span>) </span><br><span class="line"><span class="comment">--[[输出table: 00D69810</span></span><br><span class="line"><span class="comment">10</span></span><br><span class="line"><span class="comment">22]]</span><span class="comment">--</span></span><br><span class="line"></span><br><span class="line">myclass.fun(<span class="string">&quot;22&quot;</span>)</span><br><span class="line"><span class="comment">--[[输出22</span></span><br><span class="line"><span class="comment">nil</span></span><br><span class="line"><span class="comment">nil]]</span><span class="comment">--</span></span><br><span class="line"></span><br><span class="line">myclass.fun(myclass, <span class="string">&quot;22&quot;</span>)</span><br><span class="line"><span class="comment">--[[输出table: 00F298B0</span></span><br><span class="line"><span class="comment">10</span></span><br><span class="line"><span class="comment">22]]</span><span class="comment">--</span></span><br></pre></td></tr></table></figure></blockquote><h1 id="Lua多态"><a href="#Lua多态" class="headerlink" title="Lua多态"></a>Lua多态</h1><p>多态：不同表现相同行为，还是沿用之前的部分代码</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">Object:subClass(<span class="string">&quot;GameObject&quot;</span>)</span><br><span class="line">GameObject.posX = <span class="number">0</span></span><br><span class="line">GameObject.posY = <span class="number">0</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">GameObject:Move</span><span class="params">()</span></span></span><br><span class="line">    <span class="built_in">self</span>.posX = <span class="built_in">self</span>.posX + <span class="number">1</span></span><br><span class="line">    <span class="built_in">self</span>.posY = <span class="built_in">self</span>.posY + <span class="number">1</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="built_in">self</span>.posX)</span><br><span class="line">    <span class="built_in">print</span>(<span class="built_in">self</span>.posY)</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">GameObject:subClass(<span class="string">&quot;Player&quot;</span>)</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Player:Move</span><span class="params">()</span></span> <span class="comment">-- 重写同名方法</span></span><br><span class="line">    <span class="comment">-- 因为lua继承是我们自己实现的，所以也就不能用base.Move()这种形式来调用父类的方法</span></span><br><span class="line">    <span class="built_in">self</span>.base:Move() <span class="comment">-- 使用冒号调用，就相当于把Gameobject作为self传入方法中，就相当于所有实例公用了同一张表，这是不行的</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">--正确调用方法</span></span><br><span class="line">    <span class="built_in">self</span>.base.Move(<span class="built_in">self</span>) <span class="comment">-- 将调用者传入作为Move方法中的self</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">local</span> player1 = Player:new()</span><br><span class="line">player1:Move() <span class="comment">-- self 指向player1</span></span><br><span class="line"><span class="keyword">local</span> player2 = Player:new()</span><br><span class="line">player2:Move() <span class="comment">-- self 指向player2</span></span><br><span class="line"></span><br><span class="line"><span class="comment">--[[</span></span><br><span class="line"><span class="comment">错误调用的输出 1 1 2 2</span></span><br><span class="line"><span class="comment">正确调用的输出 1 1 1 1</span></span><br><span class="line"><span class="comment">--]]</span></span><br></pre></td></tr></table></figure><h1 id="Lua包"><a href="#Lua包" class="headerlink" title="Lua包"></a>Lua包</h1><p><strong>定义:包是一种组织代码的方式。</strong></p><h2 id="简单的多脚本执行"><a href="#简单的多脚本执行" class="headerlink" title="简单的多脚本执行"></a>简单的多脚本执行</h2><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- test.lua</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;successful&quot;</span>)</span><br><span class="line">A = <span class="string">&quot;123&quot;</span></span><br><span class="line"><span class="keyword">local</span> locA = <span class="string">&quot;234&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- main.lua</span></span><br><span class="line"><span class="built_in">require</span>(<span class="string">&quot;test&quot;</span>) <span class="comment">-- 加载执行test.lua脚本</span></span><br><span class="line"><span class="built_in">print</span>(A)</span><br><span class="line"><span class="built_in">print</span>(localA)</span><br><span class="line"></span><br><span class="line"><span class="comment">--[[输出结果</span></span><br><span class="line"><span class="comment">successful </span></span><br><span class="line"><span class="comment">123</span></span><br><span class="line"><span class="comment">nil</span></span><br><span class="line"><span class="comment">]]</span><span class="comment">--</span></span><br></pre></td></tr></table></figure><ul><li>脚本不仅会加载，还会执行</li><li>可以使用<code>package.loaded[&quot;脚本名&quot;]</code>，返回值是该脚本是否被执行的boolean</li><li>如果想要卸载脚本，<code>package.loaded[&quot;脚本名&quot;] = nil</code></li></ul><p>如果我们想要获取另一脚本的local变量，我们可以return出来。比如在上诉的 <code>test.lua</code>中 添加<code>return localA</code></p><p>然后再 <code>main.lua</code>中创建变量接受他 <code>testLocalA = require(&quot;test&quot;)</code></p><p>可以使用大G表，所有声明的全局变量都将会存储在里面，local 变量不会在里面</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> k,v <span class="keyword">in</span> <span class="built_in">pairs</span>(<span class="built_in">_G</span>) <span class="keyword">do</span></span><br><span class="line"><span class="built_in">print</span>(k,v)</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><h2 id="包使用实例"><a href="#包使用实例" class="headerlink" title="包使用实例"></a>包使用实例</h2><p>一般在一个Lua文件内以module函数开始定义一个包。<strong>module同时定义了一个新的包的函数环境,以使在此包中定义的全局变量都在这个环境中,而非使用包的函数的环境中。</strong></p><p>自定义包</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- mypack.lua</span></span><br><span class="line"><span class="built_in">module</span>(..., <span class="built_in">package</span>.<span class="built_in">seeall</span>) <span class="comment">--定义包,包的名字与定义包的文件的名字相同,并且在包的函数环境里可以访问使用包的函数环境</span></span><br><span class="line">ver = <span class="string">&quot;0.1 alpha&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">aFunInMyPack</span><span class="params">()</span></span> </span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Hello!&quot;</span>)</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">_G</span>.aFuncFromMyPack = aFunInMyPack</span><br></pre></td></tr></table></figure><p>测试代码</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- hello.lua</span></span><br><span class="line"><span class="keyword">local</span> pack = <span class="built_in">require</span> <span class="string">&quot;mypack&quot;</span>  <span class="comment">--导入包,导入的包必须被置于包路径(packagepath)上。包路径可以通过package.path或者环境变量来设定</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(ver <span class="keyword">or</span> <span class="string">&quot;No ver defined!&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(pack.ver)</span><br><span class="line"></span><br><span class="line">pack.aFunInMyPack()</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(aFunInMyPack <span class="keyword">or</span> <span class="string">&quot;No aFunInMyPack defined!&quot;</span>)</span><br><span class="line">aFuncFromMyPack()</span><br><span class="line"><span class="comment">--[[输出结果</span></span><br><span class="line"><span class="comment">No ver defined!</span></span><br><span class="line"><span class="comment">0.1 alpha</span></span><br><span class="line"><span class="comment">Hello!</span></span><br><span class="line"><span class="comment">No aFunInMyPack defined!</span></span><br><span class="line"><span class="comment">Hello!</span></span><br><span class="line"><span class="comment">--]]</span></span><br></pre></td></tr></table></figure><p>require 用于使用模块，module 用于创建模块。</p><h2 id="创建包"><a href="#创建包" class="headerlink" title="创建包"></a>创建包</h2><p>简单的说，一个模块就是一个程序库，可以通过 require 来加载。<strong>然后便得到了一个全局变量，表示一个 table</strong>。这个 table 就像是一个命名空间，其内容就是模块中导出的所有东西，比如函数和常量</p><p>如果不用module 函数创建包</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">local</span> M = &#123;&#125;;</span><br><span class="line"><span class="keyword">local</span> modelName = ...;</span><br><span class="line"><span class="built_in">_G</span>[modelName] = M;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">M.play</span><span class="params">()</span></span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;那么，开始吧&quot;</span>);</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">M.quit</span><span class="params">()</span></span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;你走吧，我保证你不会出事的，呵，呵呵&quot;</span>);</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> M;</span><br><span class="line"></span><br><span class="line"><span class="comment">----或者是下面这样----</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">local</span> M = &#123;&#125;;</span><br><span class="line"><span class="keyword">local</span> modelName = ...;</span><br><span class="line"><span class="built_in">_G</span>[modelName] = M;</span><br><span class="line"><span class="built_in">package</span>.<span class="built_in">loaded</span>[modname] = M</span><br><span class="line"><span class="built_in">setfenv</span>(<span class="number">1</span>, M);</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">play</span><span class="params">()</span></span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;那么，开始吧&quot;</span>);</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">quit</span><span class="params">()</span></span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;你走吧，我保证你不会出事的，呵，呵呵&quot;</span>);</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> M;</span><br></pre></td></tr></table></figure><p><strong>在调用 module 函数时，多传入一个 package.seeall 的参数，相当于 setmetatable(M, {__index = _G})</strong> </p><h1 id="Lua实战——实现2048"><a href="#Lua实战——实现2048" class="headerlink" title="Lua实战——实现2048"></a>Lua实战——实现2048</h1><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">local</span> <span class="function"><span class="keyword">function</span> <span class="title">initGrid</span><span class="params">(m,n)</span></span></span><br><span class="line">    <span class="keyword">local</span> grid = &#123;&#125;</span><br><span class="line">    <span class="keyword">for</span> i=<span class="number">1</span>,m <span class="keyword">do</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> grid[i] <span class="keyword">then</span></span><br><span class="line">            grid[i] = &#123;&#125;</span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">        <span class="keyword">for</span> j=<span class="number">1</span>,n <span class="keyword">do</span></span><br><span class="line">            grid[i][j] = <span class="number">0</span></span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">return</span> grid</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"><span class="keyword">local</span> <span class="function"><span class="keyword">function</span> <span class="title">printGrid</span><span class="params">(grid)</span></span></span><br><span class="line">    <span class="keyword">local</span> celllen = <span class="number">8</span>  <span class="comment">-- 每个格子占用字符数</span></span><br><span class="line">    <span class="keyword">local</span> gridStrLines = &#123;&#125;</span><br><span class="line">    <span class="built_in">table</span>.<span class="built_in">insert</span>(gridStrLines,<span class="string">&quot;-------------------------------------&quot;</span>)</span><br><span class="line">    <span class="keyword">for</span> i,row <span class="keyword">in</span> <span class="built_in">ipairs</span>(grid) <span class="keyword">do</span></span><br><span class="line">        <span class="keyword">local</span> line = &#123;&#125;</span><br><span class="line">        <span class="keyword">for</span> _,num <span class="keyword">in</span> <span class="built_in">ipairs</span>(row) <span class="keyword">do</span></span><br><span class="line">            <span class="keyword">if</span> num==<span class="number">0</span> <span class="keyword">then</span></span><br><span class="line">                <span class="keyword">local</span> pres = <span class="string">&quot;&quot;</span></span><br><span class="line">                <span class="keyword">for</span> tmp=<span class="number">1</span>,celllen <span class="keyword">do</span></span><br><span class="line">                    pres = pres .. <span class="string">&quot; &quot;</span></span><br><span class="line">                <span class="keyword">end</span></span><br><span class="line">                <span class="keyword">local</span> s = <span class="built_in">string</span>.<span class="built_in">format</span>(<span class="string">&quot;%s&quot;</span>,pres)</span><br><span class="line">                <span class="built_in">table</span>.<span class="built_in">insert</span>(line,s)</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                <span class="keyword">local</span> s = <span class="built_in">tostring</span>(num)</span><br><span class="line">                <span class="keyword">local</span> l = <span class="built_in">string</span>.<span class="built_in">len</span>(s)</span><br><span class="line">                <span class="keyword">local</span> l = (celllen-l)/<span class="number">2</span></span><br><span class="line">                <span class="keyword">local</span> prel = <span class="built_in">math</span>.<span class="built_in">floor</span>(l)</span><br><span class="line">                <span class="keyword">local</span> sufl = <span class="built_in">math</span>.<span class="built_in">ceil</span>(l)</span><br><span class="line">                <span class="keyword">local</span> pres = <span class="string">&quot;&quot;</span></span><br><span class="line">                <span class="keyword">for</span> tmp=<span class="number">1</span>,prel <span class="keyword">do</span></span><br><span class="line">                    pres = pres .. <span class="string">&quot; &quot;</span></span><br><span class="line">                <span class="keyword">end</span></span><br><span class="line">                <span class="keyword">local</span> sufs = pres</span><br><span class="line">                <span class="keyword">if</span> sufl&gt;prel <span class="keyword">then</span></span><br><span class="line">                    sufs = pres.. <span class="string">&quot; &quot;</span></span><br><span class="line">                <span class="keyword">end</span></span><br><span class="line">                <span class="keyword">local</span> s = <span class="built_in">string</span>.<span class="built_in">format</span>(<span class="string">&quot;%s%s%s&quot;</span>,pres,s,sufs)</span><br><span class="line">                <span class="built_in">table</span>.<span class="built_in">insert</span>(line,s)</span><br><span class="line">            <span class="keyword">end</span></span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">        <span class="keyword">local</span> line = <span class="built_in">table</span>.<span class="built_in">concat</span>(line,<span class="string">&quot;|&quot;</span>)</span><br><span class="line">        line = <span class="string">&quot;|&quot;</span> .. line .. <span class="string">&quot;|&quot;</span></span><br><span class="line">        <span class="built_in">table</span>.<span class="built_in">insert</span>(gridStrLines,line)</span><br><span class="line">        <span class="built_in">table</span>.<span class="built_in">insert</span>(gridStrLines,<span class="string">&quot;-------------------------------------&quot;</span>)</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">local</span> gridStr = <span class="built_in">table</span>.<span class="built_in">concat</span>(gridStrLines,<span class="string">&quot;\n&quot;</span>)</span><br><span class="line">    <span class="built_in">print</span>(gridStr)</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"><span class="keyword">local</span> <span class="function"><span class="keyword">function</span> <span class="title">randomGrid</span><span class="params">(grid)</span></span></span><br><span class="line">    <span class="keyword">local</span> m = #grid</span><br><span class="line">    <span class="keyword">local</span> n = #grid[<span class="number">1</span>]</span><br><span class="line">    <span class="keyword">for</span> i=<span class="number">1</span>,m <span class="keyword">do</span></span><br><span class="line">        <span class="keyword">for</span> j=<span class="number">1</span>,n <span class="keyword">do</span></span><br><span class="line">            <span class="keyword">local</span> r = <span class="built_in">math</span>.<span class="built_in">random</span>(<span class="number">1</span>,<span class="number">5</span>)</span><br><span class="line">            <span class="keyword">local</span> num = <span class="number">2</span>^r</span><br><span class="line">            grid[i][j] = num</span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"><span class="keyword">local</span> <span class="function"><span class="keyword">function</span> <span class="title">getRandomZeroPos</span><span class="params">(grid)</span></span></span><br><span class="line">    <span class="keyword">local</span> m = #grid</span><br><span class="line">    <span class="keyword">local</span> n = #grid[<span class="number">1</span>]</span><br><span class="line">    <span class="keyword">local</span> zeros = &#123;&#125;</span><br><span class="line">    <span class="keyword">for</span> i=<span class="number">1</span>,m <span class="keyword">do</span></span><br><span class="line">        <span class="keyword">for</span> j=<span class="number">1</span>,n <span class="keyword">do</span></span><br><span class="line">            <span class="keyword">if</span> grid[i][j]==<span class="number">0</span> <span class="keyword">then</span></span><br><span class="line">                <span class="built_in">table</span>.<span class="built_in">insert</span>(zeros,&#123;i=i,j=j&#125;)</span><br><span class="line">            <span class="keyword">end</span></span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">if</span> #zeros&gt;<span class="number">0</span> <span class="keyword">then</span></span><br><span class="line">        <span class="keyword">local</span> r = <span class="built_in">math</span>.<span class="built_in">random</span>(<span class="number">1</span>,#zeros)</span><br><span class="line">        <span class="keyword">return</span> zeros[r].i,zeros[r].j</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"><span class="keyword">local</span> <span class="function"><span class="keyword">function</span> <span class="title">randomNum</span><span class="params">(grid)</span></span></span><br><span class="line">    <span class="keyword">local</span> i,j = getRandomZeroPos(grid)</span><br><span class="line">    <span class="keyword">if</span> i <span class="keyword">and</span> j <span class="keyword">then</span></span><br><span class="line">        <span class="keyword">local</span> r = <span class="built_in">math</span>.<span class="built_in">random</span>()</span><br><span class="line">        <span class="keyword">if</span> r&lt;<span class="number">0.9</span> <span class="keyword">then</span></span><br><span class="line">            grid[i][j] = <span class="number">2</span></span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            grid[i][j] = <span class="number">4</span></span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">        <span class="keyword">return</span> i,j</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"><span class="keyword">local</span> <span class="function"><span class="keyword">function</span> <span class="title">moveLeft</span><span class="params">(grid)</span></span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;==============moveLeft===============&quot;</span>)</span><br><span class="line">    <span class="keyword">local</span> m = #grid</span><br><span class="line">    <span class="keyword">local</span> n = #grid[<span class="number">1</span>]</span><br><span class="line">    <span class="keyword">for</span> i=<span class="number">1</span>,m <span class="keyword">do</span></span><br><span class="line">        <span class="keyword">local</span> line = &#123;&#125;</span><br><span class="line">        <span class="keyword">for</span> j=<span class="number">1</span>,n <span class="keyword">do</span></span><br><span class="line">            <span class="keyword">if</span> grid[i][j]~=<span class="number">0</span> <span class="keyword">then</span></span><br><span class="line">                <span class="built_in">table</span>.<span class="built_in">insert</span>(line,grid[i][j])</span><br><span class="line">            <span class="keyword">end</span></span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">        <span class="keyword">local</span> k=#line</span><br><span class="line">        <span class="keyword">for</span> j=<span class="number">1</span>,n <span class="keyword">do</span></span><br><span class="line">            <span class="keyword">if</span> j&lt;=k <span class="keyword">then</span></span><br><span class="line">                grid[i][j] = line[j]</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                grid[i][j] = <span class="number">0</span></span><br><span class="line">            <span class="keyword">end</span></span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">        <span class="keyword">for</span> j=<span class="number">1</span>,k<span class="number">-1</span> <span class="keyword">do</span></span><br><span class="line">            <span class="keyword">if</span> grid[i][j]==grid[i][j+<span class="number">1</span>] <span class="keyword">then</span></span><br><span class="line">                grid[i][j+<span class="number">1</span>] = grid[i][j] + grid[i][j+<span class="number">1</span>]</span><br><span class="line">                <span class="keyword">for</span> x=j,n<span class="number">-1</span> <span class="keyword">do</span></span><br><span class="line">                    grid[i][x] = grid[i][x+<span class="number">1</span>]</span><br><span class="line">                <span class="keyword">end</span></span><br><span class="line">                grid[i][n] = <span class="number">0</span></span><br><span class="line">            <span class="keyword">end</span></span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"><span class="keyword">local</span> <span class="function"><span class="keyword">function</span> <span class="title">moveRight</span><span class="params">(grid)</span></span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;==============moveRight==============&quot;</span>)</span><br><span class="line">    <span class="keyword">local</span> m = #grid</span><br><span class="line">    <span class="keyword">local</span> n = #grid[<span class="number">1</span>]</span><br><span class="line">    <span class="keyword">for</span> i=<span class="number">1</span>,m <span class="keyword">do</span></span><br><span class="line">        <span class="keyword">local</span> line = &#123;&#125;</span><br><span class="line">        <span class="keyword">for</span> j=n,<span class="number">1</span>,<span class="number">-1</span> <span class="keyword">do</span></span><br><span class="line">            <span class="keyword">if</span> grid[i][j]~=<span class="number">0</span> <span class="keyword">then</span></span><br><span class="line">                <span class="built_in">table</span>.<span class="built_in">insert</span>(line,grid[i][j])</span><br><span class="line">            <span class="keyword">end</span></span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">        <span class="keyword">local</span> k = #line</span><br><span class="line">        <span class="keyword">for</span> j=n,<span class="number">1</span>,<span class="number">-1</span> <span class="keyword">do</span></span><br><span class="line">            <span class="keyword">if</span> n-j+<span class="number">1</span>&lt;=k <span class="keyword">then</span></span><br><span class="line">                grid[i][j] = line[n-j+<span class="number">1</span>]</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                grid[i][j] = <span class="number">0</span></span><br><span class="line">            <span class="keyword">end</span></span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">        <span class="keyword">for</span> j=n,n-k+<span class="number">2</span>,<span class="number">-1</span> <span class="keyword">do</span></span><br><span class="line">            <span class="keyword">if</span> grid[i][j]==grid[i][j<span class="number">-1</span>] <span class="keyword">then</span></span><br><span class="line">                grid[i][j<span class="number">-1</span>] = grid[i][j] + grid[i][j<span class="number">-1</span>]</span><br><span class="line">                <span class="keyword">for</span> x=j,<span class="number">2</span>,<span class="number">-1</span> <span class="keyword">do</span></span><br><span class="line">                    grid[i][x] = grid[i][x<span class="number">-1</span>]</span><br><span class="line">                <span class="keyword">end</span></span><br><span class="line">                grid[i][<span class="number">1</span>] = <span class="number">0</span></span><br><span class="line">            <span class="keyword">end</span></span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"><span class="keyword">local</span> <span class="function"><span class="keyword">function</span> <span class="title">moveUp</span><span class="params">(grid)</span></span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;===============moveUp================&quot;</span>)</span><br><span class="line">    <span class="keyword">local</span> m = #grid</span><br><span class="line">    <span class="keyword">local</span> n = #grid[<span class="number">1</span>]</span><br><span class="line">    <span class="keyword">for</span> j=<span class="number">1</span>,n <span class="keyword">do</span></span><br><span class="line">        <span class="keyword">local</span> line = &#123;&#125;</span><br><span class="line">        <span class="keyword">for</span> i=<span class="number">1</span>,m <span class="keyword">do</span></span><br><span class="line">            <span class="keyword">if</span> grid[i][j]~=<span class="number">0</span> <span class="keyword">then</span></span><br><span class="line">                <span class="built_in">table</span>.<span class="built_in">insert</span>(line,grid[i][j])</span><br><span class="line">            <span class="keyword">end</span></span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">        <span class="keyword">local</span> k = #line</span><br><span class="line">        <span class="keyword">for</span> i=<span class="number">1</span>,m <span class="keyword">do</span></span><br><span class="line">            <span class="keyword">if</span> i&lt;=k <span class="keyword">then</span></span><br><span class="line">                grid[i][j] = line[i]</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                grid[i][j] = <span class="number">0</span></span><br><span class="line">            <span class="keyword">end</span></span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">        <span class="keyword">for</span> i=<span class="number">1</span>,k<span class="number">-1</span> <span class="keyword">do</span></span><br><span class="line">            <span class="keyword">if</span> grid[i][j]==grid[i+<span class="number">1</span>][j] <span class="keyword">then</span></span><br><span class="line">                grid[i+<span class="number">1</span>][j] = grid[i][j] + grid[i+<span class="number">1</span>][j]</span><br><span class="line">                <span class="keyword">for</span> x=i,m<span class="number">-1</span> <span class="keyword">do</span></span><br><span class="line">                    grid[x][j] = grid[x+<span class="number">1</span>][j]</span><br><span class="line">                <span class="keyword">end</span></span><br><span class="line">                grid[m][j] = <span class="number">0</span></span><br><span class="line">            <span class="keyword">end</span></span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"><span class="keyword">local</span> <span class="function"><span class="keyword">function</span> <span class="title">moveDown</span><span class="params">(grid)</span></span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;==============moveDown===============&quot;</span>)</span><br><span class="line">    <span class="keyword">local</span> m = #grid</span><br><span class="line">    <span class="keyword">local</span> n = #grid[<span class="number">1</span>]</span><br><span class="line">    <span class="keyword">for</span> j=<span class="number">1</span>,n <span class="keyword">do</span></span><br><span class="line">        <span class="keyword">local</span> line = &#123;&#125;</span><br><span class="line">        <span class="keyword">for</span> i=m,<span class="number">1</span>,<span class="number">-1</span> <span class="keyword">do</span></span><br><span class="line">            <span class="keyword">if</span> grid[i][j]~=<span class="number">0</span> <span class="keyword">then</span></span><br><span class="line">                <span class="built_in">table</span>.<span class="built_in">insert</span>(line,grid[i][j])</span><br><span class="line">            <span class="keyword">end</span></span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">        <span class="keyword">local</span> k = #line</span><br><span class="line">        <span class="keyword">for</span> i=m,<span class="number">1</span>,<span class="number">-1</span> <span class="keyword">do</span></span><br><span class="line">            <span class="keyword">if</span> m-i+<span class="number">1</span>&lt;=k <span class="keyword">then</span></span><br><span class="line">                grid[i][j] = line[m-i+<span class="number">1</span>]</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                grid[i][j] = <span class="number">0</span></span><br><span class="line">            <span class="keyword">end</span></span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">        <span class="keyword">for</span> i=m,m-k+<span class="number">2</span>,<span class="number">-1</span> <span class="keyword">do</span></span><br><span class="line">            <span class="keyword">if</span> grid[i][j]==grid[i<span class="number">-1</span>][j] <span class="keyword">then</span></span><br><span class="line">                grid[i<span class="number">-1</span>][j] = grid[i][j] + grid[i<span class="number">-1</span>][j]</span><br><span class="line">                <span class="keyword">for</span> x=i,<span class="number">2</span>,<span class="number">-1</span> <span class="keyword">do</span></span><br><span class="line">                    grid[x][j] = grid[x<span class="number">-1</span>][j]</span><br><span class="line">                <span class="keyword">end</span></span><br><span class="line">                grid[<span class="number">1</span>][j] = <span class="number">0</span></span><br><span class="line">            <span class="keyword">end</span></span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"><span class="keyword">local</span> <span class="function"><span class="keyword">function</span> <span class="title">canMove</span><span class="params">(grid)</span></span></span><br><span class="line">    <span class="keyword">local</span> m = #grid</span><br><span class="line">    <span class="keyword">local</span> n = #grid[<span class="number">1</span>]</span><br><span class="line">    <span class="keyword">for</span> i=<span class="number">1</span>,m <span class="keyword">do</span></span><br><span class="line">        <span class="keyword">for</span> j=<span class="number">1</span>,n <span class="keyword">do</span></span><br><span class="line">            <span class="keyword">if</span> grid[i][j]==<span class="number">0</span> <span class="keyword">then</span></span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">            <span class="keyword">end</span></span><br><span class="line">            <span class="keyword">if</span> (i&lt;m <span class="keyword">and</span> j&lt;n)</span><br><span class="line">            <span class="keyword">and</span> (grid[i][j]==grid[i][j+<span class="number">1</span>]</span><br><span class="line">                <span class="keyword">or</span> grid[i][j]==grid[i+<span class="number">1</span>][j]) <span class="keyword">then</span></span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">            <span class="keyword">end</span></span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"><span class="keyword">local</span> <span class="function"><span class="keyword">function</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line">    <span class="keyword">local</span> grid = initGrid(<span class="number">4</span>,<span class="number">4</span>)</span><br><span class="line">    randomNum(grid)</span><br><span class="line">    printGrid(grid)</span><br><span class="line">    <span class="built_in">io</span>.<span class="built_in">write</span>(<span class="string">&quot;next step &#x27;a&#x27;[←],&#x27;w&#x27;[↑],&#x27;s&#x27;[↓],&#x27;d&#x27;[→],&#x27;q&#x27;[exit] &gt;&gt; &quot;</span>)</span><br><span class="line">    <span class="keyword">local</span> <span class="built_in">input</span> = <span class="built_in">io</span>.<span class="built_in">read</span>()</span><br><span class="line">    <span class="keyword">while</span> <span class="built_in">input</span>~=<span class="string">&quot;q&quot;</span> <span class="keyword">do</span></span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">input</span>==<span class="string">&quot;a&quot;</span> <span class="keyword">or</span> <span class="built_in">input</span>==<span class="string">&quot;w&quot;</span> <span class="keyword">or</span> <span class="built_in">input</span>==<span class="string">&quot;s&quot;</span> <span class="keyword">or</span> <span class="built_in">input</span>==<span class="string">&quot;d&quot;</span> <span class="keyword">then</span></span><br><span class="line">            <span class="keyword">if</span> <span class="built_in">input</span>==<span class="string">&quot;a&quot;</span> <span class="keyword">then</span></span><br><span class="line">                moveLeft(grid)</span><br><span class="line">            <span class="keyword">elseif</span> <span class="built_in">input</span>==<span class="string">&quot;w&quot;</span> <span class="keyword">then</span></span><br><span class="line">                moveUp(grid)</span><br><span class="line">            <span class="keyword">elseif</span> <span class="built_in">input</span>==<span class="string">&quot;s&quot;</span> <span class="keyword">then</span></span><br><span class="line">                moveDown(grid)</span><br><span class="line">            <span class="keyword">elseif</span> <span class="built_in">input</span>==<span class="string">&quot;d&quot;</span> <span class="keyword">then</span></span><br><span class="line">                moveRight(grid)</span><br><span class="line">            <span class="keyword">end</span></span><br><span class="line">            randomNum(grid)</span><br><span class="line">            printGrid(grid)</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&quot;error input. please input &#x27;a&#x27;[←] or &#x27;w&#x27;[↑] or &#x27;s&#x27;[↓] or &#x27;d&#x27;[→] or &#x27;q&#x27;[exit]&quot;</span>)</span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">        <span class="built_in">io</span>.<span class="built_in">write</span>(<span class="string">&quot;next step &#x27;a&#x27;[←],&#x27;w&#x27;[↑],&#x27;s&#x27;[↓],&#x27;d&#x27;[→],&#x27;q&#x27;[exit] &gt;&gt; &quot;</span>)</span><br><span class="line">        <span class="built_in">input</span> = <span class="built_in">io</span>.<span class="built_in">read</span>()</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line">main()</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;简单的类实现&quot;&gt;&lt;a href=&quot;#简单的类实现&quot; class=&quot;headerlink&quot; title=&quot;简单的类实现&quot;&gt;&lt;/a&gt;简单的类实现&lt;/h1&gt;&lt;p&gt;LUA中最基本的结构是table，用table来描述对象的属性。lua 中的 function 可以用来表示方法。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;那么LUA中的类可以通过 table + function 模拟出来。&lt;/strong&gt;&lt;/p&gt;
&lt;figure class=&quot;highlight lua&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;21&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;22&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;23&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;24&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;25&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;26&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;27&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;28&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;29&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;30&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;31&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;32&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;33&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;34&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;Student = &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    age = &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    growUp = &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;comment&quot;&gt;-- print(age) 这样写与表中没有任何关系，他打印age这个全局变量&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;comment&quot;&gt;-- 一定要调用表名.属性来指明是谁做的&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;built_in&quot;&gt;print&lt;/span&gt;(Student.age)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;end&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;-- 声明表之后 ，仍可以在表外生命变量和方法&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;Student.name = &lt;span class=&quot;string&quot;&gt;&amp;quot;Name&amp;quot;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;Student.Speak = &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&lt;span class=&quot;built_in&quot;&gt;print&lt;/span&gt;(&lt;span class=&quot;string&quot;&gt;&amp;quot;说话&amp;quot;&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;end&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;-- 第三种函数的声明方法&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;Student.Speak2&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&lt;span class=&quot;built_in&quot;&gt;print&lt;/span&gt;(&lt;span class=&quot;string&quot;&gt;&amp;quot;说话2&amp;quot;&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;end&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;-- 使用冒号 : 来将调用时冒号前的变量作为self&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;Student:Speak3&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&lt;span class=&quot;built_in&quot;&gt;print&lt;/span&gt;(&lt;span class=&quot;built_in&quot;&gt;self&lt;/span&gt;.name..&lt;span class=&quot;string&quot;&gt;&amp;quot;说话3&amp;quot;&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;end&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;built_in&quot;&gt;print&lt;/span&gt;(Student.age)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;Student.Speak()&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;Student.Speak2()&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;Student:Speak3() &lt;span class=&quot;comment&quot;&gt;-- Student 作为self&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;--[[输出结果&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;1&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;说话&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;说话2&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;Name说话3&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;--]]&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;</summary>
    
    
    
    
    <category term="lua" scheme="https://ycy666666.github.io/tags/lua/"/>
    
  </entry>
  
  <entry>
    <title>lua 基本语法</title>
    <link href="https://ycy666666.github.io/2022/12/23/lua-%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95/"/>
    <id>https://ycy666666.github.io/2022/12/23/lua-%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95/</id>
    <published>2022-12-23T12:40:07.000Z</published>
    <updated>2023-04-29T13:12:40.012Z</updated>
    
    <content type="html"><![CDATA[<h1 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h1><p>lua是动态语言类型，变量不需要类型定义，只需要为变量赋值</p><p>lua有8个基本类型：</p><div class="table-container"><table><thead><tr><th style="text-align:left">数据类型</th><th style="text-align:left">描述</th></tr></thead><tbody><tr><td style="text-align:left">nil</td><td style="text-align:left">这个最简单，只有值nil属于该类，表示一个无效值（在条件表达式中相当于false）。</td></tr><tr><td style="text-align:left">boolean</td><td style="text-align:left">包含两个值：false和true。</td></tr><tr><td style="text-align:left">number</td><td style="text-align:left">表示双精度类型的实浮点数</td></tr><tr><td style="text-align:left">string</td><td style="text-align:left">字符串由一对双引号或单引号来表示</td></tr><tr><td style="text-align:left">function</td><td style="text-align:left">由 C 或 Lua 编写的函数</td></tr><tr><td style="text-align:left">userdata</td><td style="text-align:left">表示任意存储在变量中的C数据结构</td></tr><tr><td style="text-align:left">thread</td><td style="text-align:left">表示执行的独立线路，用于执行协同程序</td></tr><tr><td style="text-align:left">table</td><td style="text-align:left">Lua 中的表（table）其实是一个”关联数组”（associative arrays），数组的索引可以是数字、字符串或表类型。在 Lua 里，table 的创建是通过”构造表达式”来完成，最简单构造表达式是{}，用来创建一个空表。</td></tr></tbody></table></div><span id="more"></span><h2 id="nil-空"><a href="#nil-空" class="headerlink" title="nil(空)"></a>nil(空)</h2><p>表示没有任何有效值，例如打印一个没有赋值的变量，便会输出一个 nil 值</p><p>对于全局变量和 table，nil 还有一个”删除”作用，给全局变量或者 table 表里的变量赋一个 nil 值，等同于把它们删掉</p><p> type(X) 实质是返回的 <strong>“nil”</strong> 字符串，是一个 string 类型，所以nil作比较时应该加上双引号 <strong>“</strong></p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&gt; <span class="built_in">type</span>(X)</span><br><span class="line"><span class="literal">nil</span></span><br><span class="line">&gt; <span class="built_in">type</span>(X)==<span class="literal">nil</span></span><br><span class="line"><span class="literal">false</span></span><br><span class="line">&gt; <span class="built_in">type</span>(X)==<span class="string">&quot;nil&quot;</span></span><br><span class="line"><span class="literal">true</span></span><br></pre></td></tr></table></figure><h2 id="boolean（布尔）"><a href="#boolean（布尔）" class="headerlink" title="boolean（布尔）"></a>boolean（布尔）</h2><p>boolean 类型只有两个可选值：true（真） 和 false（假），<strong>Lua 把 false 和 nil 看作是 false，其他的都为 true</strong></p><h2 id="number（数字）"><a href="#number（数字）" class="headerlink" title="number（数字）"></a>number（数字）</h2><p>Lua 默认只有一种 number 类型 — double</p><h2 id="string（字符串）"><a href="#string（字符串）" class="headerlink" title="string（字符串）"></a>string（字符串）</h2><p>字符串由一对双引号或单引号来表示。也可以用 2 个方括号 “[[]]” 来表示”一块”字符串。</p><p>在对一个数字字符串上进行算术操作时，Lua 会尝试将这个数字字符串转成一个数字，字符串连接使用的是 ..</p><p>使用 # 来计算字符串的长度，放在字符串前面</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&gt; <span class="built_in">print</span>(<span class="string">&quot;2 + 6&quot;</span>)</span><br><span class="line"><span class="number">2</span> + <span class="number">6</span></span><br><span class="line">&gt; <span class="built_in">print</span>(<span class="number">157</span> .. <span class="number">428</span>)</span><br><span class="line"><span class="number">157428</span></span><br><span class="line"></span><br><span class="line">&gt; <span class="built_in">len</span> = <span class="string">&quot;www.runoob.com&quot;</span></span><br><span class="line">&gt; <span class="built_in">print</span>(#<span class="built_in">len</span>)</span><br><span class="line"><span class="number">14</span></span><br><span class="line">&gt; <span class="built_in">print</span>(#<span class="string">&quot;www.runoob.com&quot;</span>)</span><br><span class="line"><span class="number">14</span></span><br></pre></td></tr></table></figure><h2 id="table（表）"><a href="#table（表）" class="headerlink" title="table（表）"></a>table（表）</h2><p>在 Lua 里，table 的创建是通过”构造表达式”来完成，最简单构造表达式是{}，用来创建一个空表。也可以在表里添加一些数据</p><p>其实是一个”关联数组”（associative arrays），数组的索引可以是数字或者是字符串。</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">a = &#123;&#125;</span><br><span class="line">a[<span class="string">&quot;key&quot;</span>] = <span class="string">&quot;value&quot;</span></span><br><span class="line">key = <span class="number">10</span></span><br><span class="line">a[key] = <span class="number">22</span></span><br><span class="line"><span class="keyword">for</span> k, v <span class="keyword">in</span> <span class="built_in">pairs</span>(a) <span class="keyword">do</span></span><br><span class="line">    <span class="built_in">print</span>(k .. <span class="string">&quot; : &quot;</span> .. v)</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"><span class="comment">--[[执行结果为</span></span><br><span class="line"><span class="comment">key : value</span></span><br><span class="line"><span class="comment">10 : 22</span></span><br><span class="line"><span class="comment">]]</span><span class="comment">--</span></span><br></pre></td></tr></table></figure><p><strong>在 Lua 里表的默认初始索引一般以 1 开始。</strong></p><h2 id="function（函数）"><a href="#function（函数）" class="headerlink" title="function（函数）"></a>function（函数）</h2><p>在 Lua 中，函数是被看作是”第一类值（First-Class Value）”，函数可以存在变量里:</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">factorial1</span><span class="params">(n)</span></span></span><br><span class="line">    <span class="keyword">if</span> n == <span class="number">0</span> <span class="keyword">then</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> n * factorial1(n - <span class="number">1</span>)</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"><span class="built_in">print</span>(factorial1(<span class="number">5</span>))</span><br><span class="line">factorial2 = factorial1</span><br><span class="line"><span class="built_in">print</span>(factorial2(<span class="number">5</span>))</span><br></pre></td></tr></table></figure><p>function 可以以匿名函数的方式通过参数传递:</p><h2 id="thread（线程）"><a href="#thread（线程）" class="headerlink" title="thread（线程）"></a>thread（线程）</h2><p>在 Lua 里，最主要的线程是协同程序（coroutine）。它跟线程（thread）差不多，拥有自己独立的栈、局部变量和指令指针，可以跟其他协同程序共享全局变量和其他大部分东西。</p><p><strong>线程跟协程的区别：线程可以同时多个运行，而协程任意时刻只能运行一个，并且处于运行状态的协程只有被挂起（suspend）时才会暂停。</strong></p><h2 id="userdata（自定义类型）"><a href="#userdata（自定义类型）" class="headerlink" title="userdata（自定义类型）"></a>userdata（自定义类型）</h2><p>userdata 是一种用户自定义数据，用于表示一种由应用程序或 C/C++ 语言库所创建的类型，可以将任意 C/C++ 的任意数据类型的数据（通常是 struct 和 指针）存储到 Lua 变量中调用。</p><h1 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h1><p>Lua 变量有三种类型：全局变量、局部变量、表中的域。</p><p><strong>Lua 中的变量默认为全局变量且默认值均为 nil</strong>，哪怕是语句块或是函数里，除非用 local 显式声明为局部变量。</p><h2 id="赋值"><a href="#赋值" class="headerlink" title="赋值"></a>赋值</h2><p>Lua 可以对多个变量同时赋值，变量列表和值列表的各个元素用逗号分开，赋值语句右边的值会依次赋给左边的变量。</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">a, b = <span class="number">10</span>, <span class="number">2</span>*x       <span class="comment">--&gt;       a=10; b=2*x</span></span><br></pre></td></tr></table></figure><p>遇到赋值语句Lua会先计算右边所有的值然后再执行赋值操作，所以我们可以这样进行交换变量的值：</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">x, y = y, x                     <span class="comment">-- swap &#x27;x&#x27; for &#x27;y&#x27;</span></span><br></pre></td></tr></table></figure><p>但变量个数大于值的个数时，会用nil补足；若小于值的个数则多余的值会被忽略</p><h1 id="流程控制"><a href="#流程控制" class="headerlink" title="流程控制"></a>流程控制</h1><h2 id="循环"><a href="#循环" class="headerlink" title="循环"></a>循环</h2><h3 id="for"><a href="#for" class="headerlink" title="for"></a>for</h3><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> var=exp1,exp2,exp3 <span class="keyword">do</span>  </span><br><span class="line">    &lt;执行体&gt;  </span><br><span class="line"><span class="keyword">end</span>  </span><br><span class="line"><span class="comment">-- var 从 exp1 变化到 exp2，每次变化以 exp3 为步长递增 var，并执行一次 &quot;执行体&quot;。exp3 是可选的，如果不指定，默认为1。</span></span><br></pre></td></tr></table></figure><p>三个表达式都只会在循环开始前执行一次求值，之后不再求值</p><p><strong>泛型：</strong></p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">a = &#123;<span class="string">&quot;one&quot;</span>, <span class="string">&quot;two&quot;</span>, <span class="string">&quot;three&quot;</span>&#125;</span><br><span class="line"><span class="keyword">for</span> i, v <span class="keyword">in</span> <span class="built_in">ipairs</span>(a) <span class="keyword">do</span></span><br><span class="line">    <span class="built_in">print</span>(i, v)</span><br><span class="line"><span class="keyword">end</span> </span><br></pre></td></tr></table></figure><blockquote><p>在lua中pairs与ipairs两个迭代器的用法相近，但有一点是不一样的：</p><p>pairs可以遍历表中所有的key，并且除了迭代器本身以及遍历表本身还可以返回nil;</p><p>但是ipairs则不能返回nil,只能返回数字0，如果遇到nil则退出。它只能遍历到表中出现的第一个不是整数的key</p></blockquote><h3 id="repeat"><a href="#repeat" class="headerlink" title="repeat"></a>repeat</h3><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">repeat</span></span><br><span class="line">   statements</span><br><span class="line"><span class="keyword">until</span>( condition )</span><br></pre></td></tr></table></figure><p>条件进行判断前循环体都会执行一次。</p><p>如果条件判断为 false，循环会重新开始执行，直到为 true 才会停止执行</p><h2 id="判断"><a href="#判断" class="headerlink" title="判断"></a>判断</h2><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(布尔表达式)</span><br><span class="line"><span class="keyword">then</span></span><br><span class="line">   <span class="comment">--[ 在布尔表达式为 true 时执行的语句 --]</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">   <span class="comment">--[ 布尔表达式为 false 时执行该语句块 --]</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><h1 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h1><p><strong>函数定义格式：</strong></p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">optional_function_scope <span class="function"><span class="keyword">function</span> <span class="title">function_name</span><span class="params">( argument1, argument2, argument3..., argumentn)</span></span></span><br><span class="line">    function_body</span><br><span class="line">    <span class="keyword">return</span> result_params_comma_separated</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><ul><li><strong>optional_function_scope:</strong> 未设置该参数默认为全局函数，如果你需要设置函数为局部函数需要使用关键字 <strong>local</strong>。</li><li><strong>function_name:</strong> 指定函数名称。</li><li><strong>argument1, argument2, argument3…, argumentn:</strong> 函数参数，多个参数以逗号隔开，函数也可以不带参数。</li><li><strong>function_body:</strong> 函数体，函数中需要执行的代码语句块。</li><li><strong>result_params_comma_separated:</strong> 函数返回值，<strong>Lua语言函数可以返回多个值，每个值以逗号隔开。</strong></li></ul><h2 id="多返回值"><a href="#多返回值" class="headerlink" title="多返回值"></a>多返回值</h2><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">maximum</span> <span class="params">(a)</span></span></span><br><span class="line">    <span class="keyword">local</span> mi = <span class="number">1</span>             <span class="comment">-- 最大值索引</span></span><br><span class="line">    <span class="keyword">local</span> m = a[mi]          <span class="comment">-- 最大值</span></span><br><span class="line">    <span class="keyword">for</span> i,val <span class="keyword">in</span> <span class="built_in">ipairs</span>(a) <span class="keyword">do</span></span><br><span class="line">       <span class="keyword">if</span> val &gt; m <span class="keyword">then</span></span><br><span class="line">           mi = i</span><br><span class="line">           m = val</span><br><span class="line">       <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">return</span> m, mi</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(maximum(&#123;<span class="number">8</span>,<span class="number">10</span>,<span class="number">23</span>,<span class="number">12</span>,<span class="number">5</span>&#125;))</span><br><span class="line"><span class="comment">--输出23   3</span></span><br></pre></td></tr></table></figure><h2 id="可变参数"><a href="#可变参数" class="headerlink" title="可变参数"></a>可变参数</h2><p>Lua 函数可以接受可变数目的参数，<strong>在函数参数列表中使用三点 … 表示函数有可变的参数。</strong></p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span><span class="params">(...)</span></span>  </span><br><span class="line"><span class="keyword">local</span> s = <span class="number">0</span>  </span><br><span class="line">  <span class="keyword">for</span> i, v <span class="keyword">in</span> <span class="built_in">ipairs</span>&#123;...&#125; <span class="keyword">do</span>   <span class="comment">--&gt; &#123;...&#125; 表示一个由所有变长参数构成的数组  </span></span><br><span class="line">    s = s + v  </span><br><span class="line">  <span class="keyword">end</span>  </span><br><span class="line">  <span class="keyword">return</span> s  </span><br><span class="line"><span class="keyword">end</span>  </span><br><span class="line"><span class="built_in">print</span>(add(<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>))  <span class="comment">---&gt;25</span></span><br></pre></td></tr></table></figure><p>通常在遍历变长参数的时候只需要使用 <strong>{…}</strong>，然而变长参数可能会包含一些 <strong>nil</strong>，那么就可以用 <strong>select</strong> 函数来访问变长参数了：<strong>select(‘#’, …)</strong> 或者 <strong>select(n, …)</strong></p><ul><li><strong>select(‘#’, …)</strong> 返回可变参数的长度</li><li><strong>select(n, …)</strong> 用于返回从起点 <strong>n</strong> 开始到结束位置的所有参数列表。</li></ul><p><strong>来获取可变参数的数量:</strong></p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">test</span><span class="params">(...)</span></span></span><br><span class="line">   <span class="built_in">print</span>(<span class="string">&quot;总共传入 &quot;</span> .. <span class="built_in">select</span>(<span class="string">&quot;#&quot;</span>,...) .. <span class="string">&quot; 个数&quot;</span>)</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(test(<span class="number">10</span>,<span class="number">5</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>))</span><br><span class="line"><span class="comment">-- 总共传入 6 个数</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span><span class="params">(...)</span></span></span><br><span class="line">    a = <span class="built_in">select</span>(<span class="number">3</span>,...)  <span class="comment">--&gt;从第三个位置开始，变量 a 对应右边变量列表的第一个参数</span></span><br><span class="line">    <span class="built_in">print</span> (a)</span><br><span class="line">    <span class="built_in">print</span> (<span class="built_in">select</span>(<span class="number">3</span>,...)) <span class="comment">--&gt;打印所有列表参数</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">f(<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>)</span><br><span class="line"><span class="comment">--[[ 输出结果：</span></span><br><span class="line"><span class="comment">2</span></span><br><span class="line"><span class="comment">2 3 4 5--]]</span></span><br></pre></td></tr></table></figure><h1 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h1><p>Lua 语言中字符串可以使用以下三种方式来表示：</p><ul><li>单引号间的一串字符。</li><li>双引号间的一串字符。</li><li><strong>[[</strong> 与 <strong>]]</strong> 间的一串字符。</li></ul><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">string1 = <span class="string">&quot;Lua&quot;</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;\&quot;字符串 1 是\&quot;&quot;</span>,string1)</span><br><span class="line">string2 = <span class="string">&#x27;runoob.com&#x27;</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;字符串 2 是&quot;</span>,string2)</span><br><span class="line"></span><br><span class="line">string3 = <span class="string">[[&quot;Lua 教程&quot;]]</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;字符串 3 是&quot;</span>,string3)</span><br><span class="line"><span class="comment">--[[&quot;字符串 1 是&quot;    Lua</span></span><br><span class="line"><span class="comment">字符串 2 是    runoob.com</span></span><br><span class="line"><span class="comment">字符串 3 是    &quot;Lua 教程&quot;--]]</span></span><br></pre></td></tr></table></figure><h2 id="字符串操作"><a href="#字符串操作" class="headerlink" title="字符串操作"></a>字符串操作</h2><div class="table-container"><table><thead><tr><th>方法</th><th>用途</th></tr></thead><tbody><tr><td>string.upper(argument)</td><td>全部转为大写字母</td></tr><tr><td>string.lower(argument)</td><td>全部转为小写字母</td></tr><tr><td><strong>string.gsub(mainString,findString,replaceString,num)</strong></td><td>mainString 为要操作的字符串， findString 为被替换的字符，replaceString 要替换的字符，num 替换次数（可以忽略，则全部替换）</td></tr><tr><td><strong>string.find (str, substr, [init, [plain]])</strong></td><td>在一个指定字符串 str 中搜索指定内容 substr，如果找到了匹配子串，就会返回这个子串的起始索引和结束索引，不存在则返回 nil。</td></tr><tr><td>string.sub(s, i [, j])</td><td>用于截取字符串，  <strong>s：</strong>要截取的字符串。 <strong>i：</strong>截取开始位置。 <strong>j：</strong>截取结束位置，默认为 -1，最后一个字符。</td></tr><tr><td><strong>string.rep(string, n)</strong></td><td>返回字符串string的n个拷贝，&gt; string.rep(“abcd”,2) 输出abcdabcd</td></tr><tr><td><strong>string.len(arg)</strong></td><td>计算字符串长度</td></tr></tbody></table></div><h1 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h1><p>Lua 数组的索引键值可以使用整数表示，<strong>数组的大小不是固定的。</strong></p><h2 id="一维数组"><a href="#一维数组" class="headerlink" title="一维数组"></a>一维数组</h2><p>其逻辑结构是线性表。一维数组可以用for循环出数组中的元素</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">array = &#123;<span class="string">&quot;Lua&quot;</span>, <span class="string">&quot;Tutorial&quot;</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i= <span class="number">0</span>, <span class="number">2</span> <span class="keyword">do</span></span><br><span class="line">   <span class="built_in">print</span>(array[i])</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="comment">--以上代码执行输出结果为：</span></span><br><span class="line"></span><br><span class="line"><span class="literal">nil</span> <span class="comment">-- 因为lua下标从1开始，所以0下标元素为nil</span></span><br><span class="line">Lua</span><br><span class="line">Tutorial</span><br></pre></td></tr></table></figure><p>我们还能指定负数为索引</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">array = &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i= <span class="number">-2</span>, <span class="number">2</span> <span class="keyword">do</span></span><br><span class="line">   array[i] = i *<span class="number">2</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i = <span class="number">-2</span>,<span class="number">2</span> <span class="keyword">do</span></span><br><span class="line">   <span class="built_in">print</span>(array[i])</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><h2 id="多维数组"><a href="#多维数组" class="headerlink" title="多维数组"></a>多维数组</h2><p>一维数组的索引键对应一个数组</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 初始化数组</span></span><br><span class="line">array = &#123;&#125;</span><br><span class="line"><span class="keyword">for</span> i=<span class="number">1</span>,<span class="number">3</span> <span class="keyword">do</span></span><br><span class="line">   array[i] = &#123;&#125;</span><br><span class="line">      <span class="keyword">for</span> j=<span class="number">1</span>,<span class="number">3</span> <span class="keyword">do</span></span><br><span class="line">         array[i][j] = i*j</span><br><span class="line">      <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><h1 id="table（表）-1"><a href="#table（表）-1" class="headerlink" title="table（表）"></a>table（表）</h1><p>Lua table 使用关联型数组，你可以用任意类型的值来作数组的索引，但这个值不能是 nil。</p><p>Lua table 是不固定大小的，你可以根据自己需要进行扩容。</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 初始化表</span></span><br><span class="line">mytable = &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 指定值</span></span><br><span class="line">mytable[<span class="number">1</span>]= <span class="string">&quot;Lua&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 移除引用</span></span><br><span class="line">mytable = <span class="literal">nil</span></span><br><span class="line"><span class="comment">-- lua 垃圾回收会释放内存</span></span><br></pre></td></tr></table></figure><h2 id="Table-操作"><a href="#Table-操作" class="headerlink" title="Table 操作"></a>Table 操作</h2><div class="table-container"><table><thead><tr><th>方法</th><th>用途</th></tr></thead><tbody><tr><td><strong>table.insert (table, [pos,] value）</strong></td><td>在table的数组部分指定位置(pos)插入值为value的一个元素. pos参数可选, 默认为数组部分末尾.</td></tr><tr><td><strong>table.remove (table [, pos])</strong></td><td>返回table数组部分位于pos位置的元素. 其后的元素会被前移. pos参数可选, 默认为table长度, 即从最后一个元素删起。</td></tr><tr><td><strong>table.sort (table [, comp])</strong></td><td>对给定的table进行升序排序。</td></tr><tr><td><strong>table.concat (table [, sep [, start [, end]]]):</strong></td><td>concat是concatenate(连锁, 连接)的缩写. table.concat()函数列出参数中指定table的数组部分从start位置到end位置的所有元素, 元素间以指定的分隔符(sep)隔开。</td></tr></tbody></table></div><blockquote><p>当我们获取 table 的长度的时候无论是使用 <strong>#</strong> 还是 <strong>table.getn</strong> 其都会在索引中断的地方停止计数，而导致无法正确取得 table 的长度。</p><p>可以使用以下方法来代替：</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">table_leng</span><span class="params">(t)</span></span></span><br><span class="line"><span class="keyword">local</span> leng=<span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> k, v <span class="keyword">in</span> <span class="built_in">pairs</span>(t) <span class="keyword">do</span></span><br><span class="line"> leng=leng+<span class="number">1</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"><span class="keyword">return</span> leng;</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure></blockquote><h1 id="Metatable（元表）"><a href="#Metatable（元表）" class="headerlink" title="Metatable（元表）"></a>Metatable（元表）</h1><p>Lua无法对两个table进行操作（比如相加），<strong>因此lua提供了metatable，允许我们改变table的行为</strong>。</p><p>任何表变量都可以作为另一个表变量的元表，当我们在表中进行一些特定操作的时候会执行元表当中的内容</p><blockquote><p>当 Lua 试图对两个表进行相加时，先检查两者之一是否有元表，之后检查是否有一个叫 <strong>__add</strong> 的字段，若找到，则调用对应的值。 <strong>__add</strong> 等即时字段，其对应的值（往往是一个函数或是 table）就是”元方法”。</p></blockquote><p>有两个重要函数来处理元表：</p><ul><li><strong>setmetatable(table,metatable):</strong> 对指定 table 设置元表(metatable)，如果元表(metatable)中存在 __metatable 键值，setmetatable 会失败。</li><li><strong>getmetatable(table):</strong> 返回对象的元表(metatable)。</li></ul><p>代码示例：</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">myTable1 = &#123;&#125;                          <span class="comment">-- 普通表</span></span><br><span class="line">meta1 = &#123;&#125;                      <span class="comment">-- 元表</span></span><br><span class="line"><span class="built_in">setmetatable</span>(myTable1,meta1)     <span class="comment">-- 把 meta1 设为 myTable1 的元表</span></span><br><span class="line"><span class="built_in">getmetatable</span>(myTable1)                 <span class="comment">-- meta1</span></span><br></pre></td></tr></table></figure><h2 id="tostring元方法"><a href="#tostring元方法" class="headerlink" title="__tostring元方法"></a>__tostring元方法</h2><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">meta2 = &#123;</span><br><span class="line"><span class="comment">-- 当要被当做字符串使用时，会默认调用该方法</span></span><br><span class="line">    <span class="built_in">__tostring</span> = <span class="function"><span class="keyword">function</span><span class="params">(t)</span></span></span><br><span class="line">        <span class="keyword">return</span> t.name</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">&#125;</span><br><span class="line">myTable2 =&#123;</span><br><span class="line">    name = <span class="string">&quot;Name&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">setmetatable</span>(myTable2, meta2)</span><br><span class="line"><span class="built_in">print</span>(myTable2)</span><br></pre></td></tr></table></figure><h2 id="call元方法"><a href="#call元方法" class="headerlink" title="__call元方法"></a>__call元方法</h2><p>__call 元方法会在表被当作函数使用的时候调用                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          </p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">meta3 = &#123;</span><br><span class="line">    <span class="comment">-- 注意第一个参数是表本身，类似于 : 调用</span></span><br><span class="line"><span class="built_in">__call</span> = <span class="function"><span class="keyword">function</span><span class="params">(a,b)</span></span></span><br><span class="line">        <span class="built_in">print</span>(a)</span><br><span class="line">        <span class="built_in">print</span>(b)</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;__call被调用&quot;</span>)</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">&#125;</span><br><span class="line">myTable3 = &#123;&#125;</span><br><span class="line"><span class="built_in">setmetatable</span>(myTable3, meta3)</span><br><span class="line"></span><br><span class="line">myTable3(<span class="number">1</span>)</span><br><span class="line"><span class="comment">--[[输出结果</span></span><br><span class="line"><span class="comment">table: 00A89640</span></span><br><span class="line"><span class="comment">1</span></span><br><span class="line"><span class="comment">__call被调用</span></span><br><span class="line"><span class="comment">--]]</span></span><br></pre></td></tr></table></figure><h2 id="index元方法"><a href="#index元方法" class="headerlink" title="__index元方法"></a>__index元方法</h2><p>当你通过键来访问 table 的时候，<strong>如果这个键没有值，那么Lua就会寻找该table的metatable（假定有metatable）中的index 键。</strong></p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">meta = &#123;</span><br><span class="line">    <span class="built_in">__index</span> = &#123;age = <span class="number">1</span>&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">-- 注意!如果表找不到某一属性是去 元表的__index 查找</span></span><br><span class="line"><span class="comment">-- 也可以在外面写 meta.__index = &#123;age = 1&#125;</span></span><br><span class="line"></span><br><span class="line">myTable = &#123;&#125;</span><br><span class="line"><span class="built_in">setmetatable</span>(myTable, meta)</span><br><span class="line"><span class="built_in">print</span>(myTable.age)</span><br></pre></td></tr></table></figure><p><strong>总结</strong></p><p>Lua 查找一个表元素时的规则，其实就是如下 3 个步骤:</p><ul><li>1.在表中查找，如果找到，返回该元素，找不到则继续</li><li>2.判断该表是否有元表，如果没有元表，返回 nil，有元表则继续。</li><li>3.判断元表有没有 <strong>index 方法，如果 </strong>index 方法为 nil，则返回 nil；如果 <strong>index 方法是一个表，则重复 1、2、3；如果 </strong>index 方法是一个函数，则返回该函数的返回值。</li></ul><h2 id="newindex-元方法"><a href="#newindex-元方法" class="headerlink" title="__newindex 元方法"></a>__newindex 元方法</h2><p><strong>newindex 元方法用来对表更新，</strong>index则用来对表访问 。</p><p>当你给表的一个缺少的索引赋值，解释器就会查找__newindex 元方法：如果存在则将这个值赋值到newindex所指向的表中，不会修改自己</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">meta = &#123;&#125;</span><br><span class="line">meta.<span class="built_in">__newindex</span> = &#123;&#125;</span><br><span class="line">myTable = &#123;&#125;</span><br><span class="line"><span class="built_in">setmetatable</span>(myTable, meta)</span><br><span class="line"></span><br><span class="line">myTable.age = <span class="number">1</span></span><br><span class="line"><span class="built_in">print</span>(myTable.age)</span><br><span class="line"><span class="comment">-- 输出 nil</span></span><br></pre></td></tr></table></figure><p>此外，可以使用 <code>rawset</code> 和 <code>rawget</code>来设置和获取当前表的变量，而不在元表中获取</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span>(<span class="built_in">rawget</span>(myTable, <span class="string">&quot;age&quot;</span>)) <span class="comment">-- 输出nil</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">rawset</span>(myTable, <span class="string">&quot;age&quot;</span>, <span class="number">2</span>) </span><br><span class="line"><span class="built_in">print</span>(myTable.age) <span class="comment">-- 输出 2</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">rawget</span>(myTable, <span class="string">&quot;age&quot;</span>)) <span class="comment">-- 输出2</span></span><br></pre></td></tr></table></figure><h2 id="运算符元方法"><a href="#运算符元方法" class="headerlink" title="运算符元方法"></a>运算符元方法</h2><div class="table-container"><table><thead><tr><th style="text-align:left">模式</th><th style="text-align:left">描述</th></tr></thead><tbody><tr><td style="text-align:left">__add</td><td style="text-align:left">对应的运算符 ‘+’.</td></tr><tr><td style="text-align:left">__sub</td><td style="text-align:left">对应的运算符 ‘-‘.</td></tr><tr><td style="text-align:left">__mul</td><td style="text-align:left">对应的运算符 ‘*’.</td></tr><tr><td style="text-align:left">__div</td><td style="text-align:left">对应的运算符 ‘/‘.</td></tr><tr><td style="text-align:left">__mod</td><td style="text-align:left">对应的运算符 ‘%’.</td></tr><tr><td style="text-align:left">__unm</td><td style="text-align:left">对应的运算符 ‘-‘.</td></tr><tr><td style="text-align:left">__concat</td><td style="text-align:left">对应的运算符 ‘..’.</td></tr><tr><td style="text-align:left">__eq</td><td style="text-align:left">对应的运算符 ‘==’.</td></tr><tr><td style="text-align:left">__lt</td><td style="text-align:left">对应的运算符 ‘&lt;’.</td></tr><tr><td style="text-align:left">__le</td><td style="text-align:left">对应的运算符 ‘&lt;=’.</td></tr></tbody></table></div><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">meta = &#123;</span><br><span class="line"><span class="built_in">__add</span> = <span class="function"><span class="keyword">function</span><span class="params">(t1,t2)</span></span></span><br><span class="line"><span class="keyword">return</span> t1.age + t2.age</span><br><span class="line"><span class="keyword">end</span>, <span class="comment">-- 注意用 , 隔开 </span></span><br><span class="line"><span class="built_in">__sub</span> = <span class="function"><span class="keyword">function</span><span class="params">(t1,t2)</span></span></span><br><span class="line"><span class="keyword">return</span> t1.age - t2.age</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">myTable1 = &#123;age = <span class="number">1</span>&#125;</span><br><span class="line"><span class="built_in">setmetatable</span>(myTable1, meta)</span><br><span class="line">myTable2 = &#123;age = <span class="number">2</span>&#125;</span><br><span class="line"><span class="built_in">setmetatable</span>(myTable2, meta)</span><br></pre></td></tr></table></figure><p>注意如果要重载比较预算符的话，要两个表的元表都相同才是能做比较</p><h1 id="模块与包"><a href="#模块与包" class="headerlink" title="模块与包"></a>模块与包</h1><p>可以把一些公用的代码放在一个文件里，以 API 接口的形式在其他地方调用，有利于代码的重用和降低代码耦合度。</p><p>Lua 的模块是由变量、函数等已知元素组成的 table，因此创建一个模块很简单，就是创建一个 table，然后把需要导出的常量、函数放入其中，最后返回这个 table 就行。</p><p>创建自定义模块 <code>module.lua</code></p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 文件名为 module.lua</span></span><br><span class="line"><span class="comment">-- 定义一个名为 module 的模块</span></span><br><span class="line"><span class="built_in">module</span> = &#123;&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">-- 定义一个常量</span></span><br><span class="line"><span class="built_in">module</span>.constant = <span class="string">&quot;这是一个常量&quot;</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">-- 定义一个函数</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">module.func1</span><span class="params">()</span></span></span><br><span class="line">    <span class="built_in">io</span>.<span class="built_in">write</span>(<span class="string">&quot;这是一个公有函数！\n&quot;</span>)</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">local</span> <span class="function"><span class="keyword">function</span> <span class="title">func2</span><span class="params">()</span></span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;这是一个私有函数！&quot;</span>)</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">module.func3</span><span class="params">()</span></span></span><br><span class="line">    func2()</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="built_in">module</span></span><br></pre></td></tr></table></figure><p>func2 声明为程序块的局部变量，即表示一个私有函数</p><h2 id="加载"><a href="#加载" class="headerlink" title="加载"></a>加载</h2><p>Lua提供了一个名为require的函数用来加载模块。 <code>require(&quot;&lt;模块名&gt;&quot;)</code></p><p>可以直接使用<code>module.constant</code>，也可以使用别名</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- test_module2.lua 文件</span></span><br><span class="line"><span class="comment">-- module 模块为上文提到到 module.lua</span></span><br><span class="line"><span class="comment">-- 别名变量 m</span></span><br><span class="line"><span class="keyword">local</span> m = <span class="built_in">require</span>(<span class="string">&quot;module&quot;</span>)</span><br><span class="line"> </span><br><span class="line"><span class="built_in">print</span>(m.constant)</span><br><span class="line"> </span><br><span class="line">m.func3()</span><br></pre></td></tr></table></figure><h2 id="加载路径"><a href="#加载路径" class="headerlink" title="加载路径"></a>加载路径</h2><p>对于自定义的模块，模块文件不是放在哪个文件目录都行，函数 require 有它自己的文件路径加载策略，它会尝试从 Lua 文件或 C 程序库中加载模块。</p><p>Lua和C是很容易结合的，与Lua中写包不同，C包在使用以前必须首先加载并连接，在大多数系统中最容易的实现方式是通过动态连接库机制。</p><p>loadlib 函数加载指定的库并且连接到 Lua，然而它并不打开库（也就是说没有调用初始化函数），反之他返回初始化函数作为 Lua 的一个函数，这样我们就可以直接在Lua中调用他。</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">local</span> <span class="built_in">path</span> = <span class="string">&quot;/usr/local/lua/lib/libluasocket.so&quot;</span></span><br><span class="line"><span class="comment">-- 或者 path = &quot;C:\\windows\\luasocket.dll&quot;，这是 Window 平台下</span></span><br><span class="line"><span class="keyword">local</span> f = <span class="built_in">assert</span>(<span class="built_in">loadlib</span>(<span class="built_in">path</span>, <span class="string">&quot;luaopen_socket&quot;</span>))</span><br><span class="line">f()  <span class="comment">-- 真正打开库</span></span><br></pre></td></tr></table></figure><h1 id="协同程序"><a href="#协同程序" class="headerlink" title="协同程序"></a>协同程序</h1><p>Lua 协同程序(coroutine)与线程比较类似：拥有独立的堆栈，独立的局部变量，独立的指令指针，同时又与其它协同程序共享全局变量和其它大部分东西。</p><h2 id="线程和协同程序区别"><a href="#线程和协同程序区别" class="headerlink" title="线程和协同程序区别"></a>线程和协同程序区别</h2><p>线程与协同程序的主要区别在于，一个具有多个线程的程序可以同时运行几个线程，而协同程序却需要彼此协作的运行。</p><p>在任一指定时刻只有一个协同程序在运行，并且这个正在运行的协同程序只有在明确的被要求挂起的时候才会被挂起。</p><p>协同程序有点类似同步的多线程，在等待同一个线程锁的几个线程有点类似协同。</p><h2 id="基本语法"><a href="#基本语法" class="headerlink" title="基本语法"></a>基本语法</h2><div class="table-container"><table><thead><tr><th style="text-align:left">方法</th><th style="text-align:left">描述</th></tr></thead><tbody><tr><td style="text-align:left">coroutine.create()</td><td style="text-align:left">创建 coroutine，返回 coroutine， 参数是一个函数，当和 resume 配合使用的时候就唤醒函数调用</td></tr><tr><td style="text-align:left">coroutine.resume()</td><td style="text-align:left">重启 coroutine，和 create 配合使用</td></tr><tr><td style="text-align:left">coroutine.yield()</td><td style="text-align:left">挂起 coroutine，将 coroutine 设置为挂起状态，这个和 resume 配合使用能有很多有用的效果</td></tr><tr><td style="text-align:left">coroutine.status()</td><td style="text-align:left">查看 coroutine 的状态 注：coroutine 的状态有三种：dead，suspended，running</td></tr><tr><td style="text-align:left">coroutine.wrap（）</td><td style="text-align:left">创建 coroutine，返回一个函数，一旦你调用这个函数，就进入 coroutine，和 create 功能重复</td></tr><tr><td style="text-align:left">coroutine.running()</td><td style="text-align:left">返回正在跑的 coroutine，一个 coroutine 就是一个线程，当使用running的时候，就是返回一个 corouting 的线程号</td></tr></tbody></table></div><p>coroutine.running就可以看出来,coroutine在底层实现就是一个线程。</p><p>当create一个coroutine的时候就是在新线程中注册了一个事件。</p><p>当使用resume触发事件的时候，create的coroutine函数就被执行了，当遇到yield的时候就代表挂起当前线程，等候再次resume触发事件。</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">co = <span class="built_in">coroutine</span>.<span class="built_in">create</span>(<span class="function"><span class="keyword">function</span> <span class="params">(a)</span></span></span><br><span class="line">    <span class="keyword">local</span> r = <span class="built_in">coroutine</span>.<span class="built_in">yield</span>(a+<span class="number">1</span>)       <span class="comment">-- yield()返回a+1给调用它的resume()函数，即2</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;r=&quot;</span> ..r)                       <span class="comment">-- r的值是第2次resume()传进来的，100</span></span><br><span class="line"><span class="keyword">end</span>)</span><br><span class="line"><span class="built_in">status</span>, r = <span class="built_in">coroutine</span>.<span class="built_in">resume</span>(co, <span class="number">1</span>)     <span class="comment">-- resume()返回两个值，一个是自身的状态true，一个是yield的返回值2</span></span><br><span class="line"><span class="built_in">coroutine</span>.<span class="built_in">resume</span>(co, <span class="number">100</span>)     <span class="comment">--resume()返回true</span></span><br><span class="line"></span><br><span class="line"><span class="comment">------------输出结果</span></span><br><span class="line">r=<span class="number">100</span> <span class="comment">--只会打印一次</span></span><br></pre></td></tr></table></figure><ul><li><p>调用resume，将协同程序唤醒,resume操作成功返回true，否则返回false；           </p></li><li><p>resume处于主程中，它将外部状态（数据）传入到协同程序内部；而yield则将内部的状态（数据）返回到主程中。</p></li></ul><p>更详细的一个实例</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span> <span class="params">(a)</span></span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;foo 函数输出&quot;</span>, a)</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">coroutine</span>.<span class="built_in">yield</span>(<span class="number">2</span> * a) <span class="comment">-- 返回  2*a 的值</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"> </span><br><span class="line">co = <span class="built_in">coroutine</span>.<span class="built_in">create</span>(<span class="function"><span class="keyword">function</span> <span class="params">(a , b)</span></span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;第一次协同程序执行输出&quot;</span>, a, b) <span class="comment">-- co-body 1 10</span></span><br><span class="line">    <span class="keyword">local</span> r = foo(a + <span class="number">1</span>)</span><br><span class="line">     </span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;第二次协同程序执行输出&quot;</span>, r)</span><br><span class="line">    <span class="keyword">local</span> r, s = <span class="built_in">coroutine</span>.<span class="built_in">yield</span>(a + b, a - b)  <span class="comment">-- a，b的值为第一次调用协同程序时传入</span></span><br><span class="line">     </span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;第三次协同程序执行输出&quot;</span>, r, s)</span><br><span class="line">    <span class="keyword">return</span> b, <span class="string">&quot;结束协同程序&quot;</span>                   <span class="comment">-- b的值为第二次调用协同程序时传入</span></span><br><span class="line"><span class="keyword">end</span>)</span><br><span class="line">       </span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;main&quot;</span>, <span class="built_in">coroutine</span>.<span class="built_in">resume</span>(co, <span class="number">1</span>, <span class="number">10</span>)) <span class="comment">-- true, 4</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;--分割线----&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;main&quot;</span>, <span class="built_in">coroutine</span>.<span class="built_in">resume</span>(co, <span class="string">&quot;r&quot;</span>)) <span class="comment">-- true 11 -9</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;---分割线---&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;main&quot;</span>, <span class="built_in">coroutine</span>.<span class="built_in">resume</span>(co, <span class="string">&quot;x&quot;</span>, <span class="string">&quot;y&quot;</span>)) <span class="comment">-- true 10 end</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;---分割线---&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;main&quot;</span>, <span class="built_in">coroutine</span>.<span class="built_in">resume</span>(co, <span class="string">&quot;x&quot;</span>, <span class="string">&quot;y&quot;</span>)) <span class="comment">-- cannot resume dead coroutine</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;---分割线---&quot;</span>)</span><br></pre></td></tr></table></figure><p>输出结果</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">第一次协同程序执行输出    1    10</span><br><span class="line">foo 函数输出    2</span><br><span class="line">main    true    4</span><br><span class="line">--分割线----</span><br><span class="line">第二次协同程序执行输出    r</span><br><span class="line">main    true    11    -9</span><br><span class="line">---分割线---</span><br><span class="line">第三次协同程序执行输出    x    y</span><br><span class="line">main    true    10    结束协同程序</span><br><span class="line">---分割线---</span><br><span class="line">main    false    cannot resume dead coroutine</span><br><span class="line">---分割线---</span><br></pre></td></tr></table></figure><h1 id="迭代器"><a href="#迭代器" class="headerlink" title="迭代器"></a>迭代器</h1><p>迭代器（iterator）是一种对象，它能够用来遍历标准模板库容器中的部分或全部元素，每个迭代器对象代表容器中的确定的地址。</p><h2 id="ipairs-和-pairs"><a href="#ipairs-和-pairs" class="headerlink" title="ipairs 和 pairs"></a>ipairs 和 pairs</h2><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">t = &#123;[<span class="number">0</span>] = <span class="number">1</span>, <span class="number">2</span>, [<span class="number">-1</span>] = <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, [<span class="number">5</span>] = <span class="number">6</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- ipairs遍历</span></span><br><span class="line"><span class="comment">-- ipairs遍历还是从1开始往后遍历， &lt;= 0的值都无法遍历，而且如果不连续中断，也无法遍历后面的值</span></span><br><span class="line"><span class="keyword">for</span> k, v <span class="keyword">in</span> <span class="built_in">ipairs</span>(t) <span class="keyword">do</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;ipairs遍历&quot;</span>..k..<span class="string">&quot;-&quot;</span>..v)</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"><span class="comment">-- 只能得到 2，4，5</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- pairs遍历</span></span><br><span class="line"><span class="comment">-- 能够把所有的键都找到，通过键也就能得到值</span></span><br><span class="line"><span class="keyword">for</span> k, v <span class="keyword">in</span> <span class="built_in">pairs</span>(t) <span class="keyword">do</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;pairs遍历&quot;</span>..k..<span class="string">&quot;-&quot;</span>..v)</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><p>上面代码中，i,k, v分别为变量列表的索引、键、值；pairs(t)为表达式列表。</p><p>在Lua中我们常常使用函数来描述迭代器，每次调用该函数就返回集合的下一个元素。Lua 的迭代器包含以下两种类型：</p><ul><li>无状态的迭代器</li><li>多状态的迭代器</li></ul><h2 id="无状态的迭代器"><a href="#无状态的迭代器" class="headerlink" title="无状态的迭代器"></a>无状态的迭代器</h2><p>无状态的迭代器是指不保留任何状态的迭代器，因此在循环中我们可以利用无状态迭代器避免创建闭包花费额外的代价。</p><p>每一次迭代，迭代函数都是用两个变量（状态常量和控制变量）的值作为参数被调用，一个无状态的迭代器只利用这两个值可以获取下一个元素。</p><p>这种无状态迭代器的典型的简单的例子是 ipairs，它遍历数组的每一个元素，元素的索引需要是数值。</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 函数定义</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">square</span><span class="params">(iteratorMaxCount,currentNumber)</span></span></span><br><span class="line">   <span class="keyword">if</span> currentNumber&lt;iteratorMaxCount</span><br><span class="line">   <span class="keyword">then</span></span><br><span class="line">      currentNumber = currentNumber+<span class="number">1</span></span><br><span class="line">   <span class="keyword">return</span> currentNumber, currentNumber*currentNumber</span><br><span class="line">   <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 迭代器遍历</span></span><br><span class="line"><span class="keyword">for</span> i,n <span class="keyword">in</span> square,<span class="number">3</span>,<span class="number">0</span></span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">   <span class="built_in">print</span>(i,n)</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><p><strong>迭代的状态包括被遍历的表（循环过程中不会改变的状态常量）和当前的索引下标（控制变量）</strong></p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">iter</span> <span class="params">(a, i)</span></span></span><br><span class="line">    i = i + <span class="number">1</span></span><br><span class="line">    <span class="keyword">local</span> v = a[i]</span><br><span class="line">    <span class="keyword">if</span> v <span class="keyword">then</span></span><br><span class="line">       <span class="keyword">return</span> i, v</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">ipairs</span> <span class="params">(a)</span></span></span><br><span class="line">    <span class="keyword">return</span> iter, a, <span class="number">0</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><p>当 Lua 调用 ipairs(a) 开始循环时，他获取三个值：迭代函数 iter、状态常量 a、控制变量初始值 0；</p><p>然后 Lua 调用 iter(a,0) 返回 1, a[1]（除非 a[1]=nil）；</p><p>第二次迭代调用 iter(a,1) 返回 2, a[2]……直到第一个 nil 元素。</p><h2 id="多状态的迭代器"><a href="#多状态的迭代器" class="headerlink" title="多状态的迭代器"></a>多状态的迭代器</h2><p>迭代器需要保存多个状态信息而不是简单的状态常量和控制变量</p><p>一种方法就是将所有的状态信息封装到 table 内，将 table 作为迭代器的状态常量，因为这种情况下可以将所有的信息存放在 table 内，所以迭代函数通常不需要第二个参数。</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">array = &#123;<span class="string">&quot;Google&quot;</span>, <span class="string">&quot;Runoob&quot;</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">elementIterator</span> <span class="params">(collection)</span></span></span><br><span class="line">   <span class="keyword">local</span> index = <span class="number">0</span></span><br><span class="line">   <span class="keyword">local</span> count = #collection</span><br><span class="line">   <span class="comment">-- 闭包函数</span></span><br><span class="line">   <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> <span class="params">()</span></span></span><br><span class="line">      index = index + <span class="number">1</span></span><br><span class="line">      <span class="keyword">if</span> index &lt;= count</span><br><span class="line">      <span class="keyword">then</span></span><br><span class="line">         <span class="comment">--  返回迭代器的当前元素</span></span><br><span class="line">         <span class="keyword">return</span> collection[index]</span><br><span class="line">      <span class="keyword">end</span></span><br><span class="line">   <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> element <span class="keyword">in</span> elementIterator(array)</span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">   <span class="built_in">print</span>(element)</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="comment">--输出</span></span><br><span class="line">Google</span><br><span class="line">Runoob</span><br></pre></td></tr></table></figure><h1 id="垃圾回收"><a href="#垃圾回收" class="headerlink" title="垃圾回收"></a>垃圾回收</h1><p>Lua 采用了自动内存管理。 这意味着你不用操心新创建的对象需要的内存如何分配出来， 也不用考虑在对象不再被使用后怎样释放它们所占用的内存。</p><p>Lua 运行了一个<strong>垃圾收集器</strong>来收集所有<strong>死对象</strong> （即在 Lua 中不可能再访问到的对象）来完成自动内存管理的工作。 Lua 中所有用到的内存，都服从自动管理。</p><h2 id="工作原理"><a href="#工作原理" class="headerlink" title="工作原理"></a>工作原理</h2><p>Lua 实现了一个增量标记-扫描收集器。 它使用这两个数字来控制垃圾收集循环： <strong>垃圾收集器间歇率和垃圾收集器步进倍率</strong>。 这两个数字都使用百分数为单位 （例如：值 100 在内部表示 1 ）。</p><ul><li>垃圾收集器间歇率控制着收集器需要在开启新的循环前要等待多久。 增大这个值会减少收集器的积极性。 当这个值比 100 小的时候，收集器在开启新的循环前不会有等待。 设置这个值为 200 就会让收集器等到总内存使用量达到 之前的两倍时才开始新的循环。</li><li>垃圾收集器步进倍率控制着收集器运作速度相对于内存分配速度的倍率。 增大这个值不仅会让收集器更加积极，还会增加每个增量步骤的长度。 不要把这个值设得小于 100 ， 那样的话收集器就工作的太慢了以至于永远都干不完一个循环。 默认值是 200 ，这表示收集器以内存分配的”两倍”速工作。</li></ul><h2 id="相关函数"><a href="#相关函数" class="headerlink" title="相关函数"></a>相关函数</h2><p><strong>collectgarbage ([opt [, arg]])</strong>用来控制自动内存管理</p><ul><li><strong>collectgarbage(“collect”):</strong> 做一次完整的垃圾收集循环。通过参数 opt 它提供了一组不同的功能：</li><li><p><strong>collectgarbage(“count”):</strong> 以 K 字节数为单位返回 Lua 使用的总内存数。 这个值有小数部分，所以只需要乘上 1024 就能得到 Lua 使用的准确字节数（除非溢出）</p></li><li><p><strong>collectgarbage(“setpause”):</strong> 将 arg 设为收集器的 间歇率。 返回 间歇率 的前一个值。</p></li><li><strong>collectgarbage(“setstepmul”):</strong> 返回 步进倍率 的前一个值。</li></ul><blockquote><p><strong>collectgarbage(“setpause”, 200)</strong> ： 内存增大 2 倍（200/100）时自动释放一次内存 （200 是默认值）。</p><p><strong>collectgarbage(“setstepmul”, 200)</strong> ：收集器单步收集的速度相对于内存分配速度的倍率，设置 200 的倍率等于 2 倍（200/100）。（200 是默认值）</p></blockquote>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;数据类型&quot;&gt;&lt;a href=&quot;#数据类型&quot; class=&quot;headerlink&quot; title=&quot;数据类型&quot;&gt;&lt;/a&gt;数据类型&lt;/h1&gt;&lt;p&gt;lua是动态语言类型，变量不需要类型定义，只需要为变量赋值&lt;/p&gt;
&lt;p&gt;lua有8个基本类型：&lt;/p&gt;
&lt;div class=&quot;table-container&quot;&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th style=&quot;text-align:left&quot;&gt;数据类型&lt;/th&gt;
&lt;th style=&quot;text-align:left&quot;&gt;描述&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td style=&quot;text-align:left&quot;&gt;nil&lt;/td&gt;
&lt;td style=&quot;text-align:left&quot;&gt;这个最简单，只有值nil属于该类，表示一个无效值（在条件表达式中相当于false）。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&quot;text-align:left&quot;&gt;boolean&lt;/td&gt;
&lt;td style=&quot;text-align:left&quot;&gt;包含两个值：false和true。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&quot;text-align:left&quot;&gt;number&lt;/td&gt;
&lt;td style=&quot;text-align:left&quot;&gt;表示双精度类型的实浮点数&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&quot;text-align:left&quot;&gt;string&lt;/td&gt;
&lt;td style=&quot;text-align:left&quot;&gt;字符串由一对双引号或单引号来表示&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&quot;text-align:left&quot;&gt;function&lt;/td&gt;
&lt;td style=&quot;text-align:left&quot;&gt;由 C 或 Lua 编写的函数&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&quot;text-align:left&quot;&gt;userdata&lt;/td&gt;
&lt;td style=&quot;text-align:left&quot;&gt;表示任意存储在变量中的C数据结构&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&quot;text-align:left&quot;&gt;thread&lt;/td&gt;
&lt;td style=&quot;text-align:left&quot;&gt;表示执行的独立线路，用于执行协同程序&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&quot;text-align:left&quot;&gt;table&lt;/td&gt;
&lt;td style=&quot;text-align:left&quot;&gt;Lua 中的表（table）其实是一个”关联数组”（associative arrays），数组的索引可以是数字、字符串或表类型。在 Lua 里，table 的创建是通过”构造表达式”来完成，最简单构造表达式是{}，用来创建一个空表。&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;/div&gt;</summary>
    
    
    
    
    <category term="lua" scheme="https://ycy666666.github.io/tags/lua/"/>
    
  </entry>
  
  <entry>
    <title>Unity + Mirror实现局域网联机自制卡牌游戏</title>
    <link href="https://ycy666666.github.io/2022/12/05/Unity-Mirror%E5%AE%9E%E7%8E%B0%E5%B1%80%E5%9F%9F%E7%BD%91%E8%81%94%E6%9C%BA%E8%87%AA%E5%88%B6%E5%8D%A1%E7%89%8C%E6%B8%B8%E6%88%8F/"/>
    <id>https://ycy666666.github.io/2022/12/05/Unity-Mirror%E5%AE%9E%E7%8E%B0%E5%B1%80%E5%9F%9F%E7%BD%91%E8%81%94%E6%9C%BA%E8%87%AA%E5%88%B6%E5%8D%A1%E7%89%8C%E6%B8%B8%E6%88%8F/</id>
    <published>2022-12-05T09:30:49.000Z</published>
    <updated>2022-12-09T10:58:22.435Z</updated>
    
    <content type="html"><![CDATA[<h1 id="资源下载地址"><a href="#资源下载地址" class="headerlink" title="资源下载地址"></a>资源下载地址</h1><p>局域网联机插件 Mirror：<a href="https://assetstore.unity.com/packages/tools/network/mirror-129321">Mirror | 网络 | Unity Asset Store</a></p><p>本地客户端测试多人游戏（不用打包）插件 ： <a href="https://github.com/VeriorPies/ParrelSync">ParrelSync</a></p><p>Mirror官方文档：<a href="https://mirror-networking.gitbook.io/docs/general">General - Mirror (gitbook.io)</a></p><h1 id="Mirror使用"><a href="#Mirror使用" class="headerlink" title="Mirror使用"></a>Mirror使用</h1><h2 id="前置准备"><a href="#前置准备" class="headerlink" title="前置准备"></a>前置准备</h2><ol><li>导入Mirror Package</li><li>创建空物体，添加 <code>Network Manager</code>， <code>Network Manager HUD</code>以及 <code>KCP Transport</code>（也可以选择其他网络连接方式）</li><li>导入<code>ParrelSync</code>， 并为其clone当前项目，在此之后clone后的项目能同步你在本项目的所有修改</li></ol><span id="more"></span><h3 id="演示场景"><a href="#演示场景" class="headerlink" title="演示场景"></a>演示场景</h3><p>点击开始之后会看到如下界面，需要其中一台电脑作为Host，其他玩家点击Client就可以直接连接</p><p><img src="/2022/12/05/Unity-Mirror%E5%AE%9E%E7%8E%B0%E5%B1%80%E5%9F%9F%E7%BD%91%E8%81%94%E6%9C%BA%E8%87%AA%E5%88%B6%E5%8D%A1%E7%89%8C%E6%B8%B8%E6%88%8F/image-20221128153741347.png" alt="image-20221128153741347"></p><p>Mirror演示场景连接成功效果：</p><p><img src="/2022/12/05/Unity-Mirror%E5%AE%9E%E7%8E%B0%E5%B1%80%E5%9F%9F%E7%BD%91%E8%81%94%E6%9C%BA%E8%87%AA%E5%88%B6%E5%8D%A1%E7%89%8C%E6%B8%B8%E6%88%8F/image-20221128154024366.png" alt="image-20221128154024366"></p><h3 id="同步"><a href="#同步" class="headerlink" title="同步"></a>同步</h3><p>首先需要注意的事情：</p><ul><li>在你需要用到联网功能的脚本中都要添加 <code>use Mirror</code>来使用相应Api，并且继承自 <code>NetWorkBehavior</code>而不是 <code>MonoBehavior</code></li><li>在涉及到玩家输入时，首先先要进行 <code>isLocalPlayer</code>的判断</li><li>如果游戏玩家有 <code>Prefab</code>，需要在<code>prefab</code>添加 <code>NetworkIdentity</code>组件并将其拖入到 <code>NetworkManager</code>组件的 <code>PlayerPrefab</code>中</li></ul><h2 id="服务端与客户端通信"><a href="#服务端与客户端通信" class="headerlink" title="服务端与客户端通信"></a>服务端与客户端通信</h2><h3 id="概念含义"><a href="#概念含义" class="headerlink" title="概念含义"></a>概念含义</h3><h4 id="Network-Identity"><a href="#Network-Identity" class="headerlink" title="Network Identity"></a>Network Identity</h4><p>该组件控制着游戏物体在网络中的独特ID，他的 <code>Server Only</code>选项表示是否确保物体只生成在服务端。</p><blockquote><p><strong>注意：Mirror不支持嵌套的 <code>Network Identity</code>，确保父物体是唯一一个具有该组件的物体，子物体通过 <code>GetComponentInParent</code>去查找</strong></p></blockquote><p>在每一个运行过程中生成的预制体都需要添加该组件。</p><h4 id="Network-Authority"><a href="#Network-Authority" class="headerlink" title="Network Authority"></a>Network Authority</h4><p>Authority（权限）决定着谁拥有并控制着这个物体，默认情况下服务器拥有所有物体的权限</p><p>但有时候我们需要客户端拥有权限，比如玩家输入，我们有以下方法将权限给到客户端：</p><ul><li><p><strong><code>NetworkServer.Spawn</code></strong>： 在创建物体时给出权限</p></li><li><p><strong><code>NetworkServer.AddPlayerForConnection</code></strong>，生成玩家物体时自动添加权限</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">GameObject go = Instantiate(prefab);</span><br><span class="line">NetworkServer.Spawn(go, connectionToClient);</span><br></pre></td></tr></table></figure></li><li><p><strong><code>AssignClientAuthority</code></strong>： 在任何时候添加权限</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">identity.AssignClientAuthority(conn);</span><br></pre></td></tr></table></figure></li></ul><p>给物体赋予权限后，我们就能在ClientRpc中根据<code>IsOwn</code>来根据是否是自己的物体来执行不同函数，比如本游戏中，将卡牌放置在不同区域</p><h3 id="回调函数"><a href="#回调函数" class="headerlink" title="回调函数"></a>回调函数</h3><p>在需要使用服务端、客户端开始结束时回调的脚本中继承自NetworkBehavior，本例子继承自Network Manager是为了方便不再添加一个Network Manager组件</p><h4 id="仅在server上执行"><a href="#仅在server上执行" class="headerlink" title="仅在server上执行"></a>仅在server上执行</h4><p>Server Only ——</p><ul><li>OnStartServer:在服务端上生成时调用</li><li>OnStopServer:在服务器上销毁或者取消生成时调用</li><li>OnSerialize:在他在发送到客户端序列化之前调用， 同时确保调用 <code>base.OnSerialize</code></li></ul><h4 id="仅在Client-上执行"><a href="#仅在Client-上执行" class="headerlink" title="仅在Client 上执行"></a>仅在Client 上执行</h4><p>Client Only ——</p><ul><li>OnStartClient: 在客户端上生成时调用</li><li>OnStartLocalPlayer: 仅在client执行,当脚本所在物体为玩家角色时调用，用来设置跟踪相机等</li><li>OnStopClient: 当对象在客户端上被<code>ObjectDestroyMessage</code>或<code>ObjectHideMessage</code>消息销毁时调用</li><li>OnstartAuthority() 仅在client执行，当物体生产时，同时在该客户端有权限时执行</li><li>OnStopAuthority()仅在client执行，当客户端失去该物体权限时调用</li></ul><p>Awake() 最先无论client还是server。<br>Start() 顺序不定，通常在最后但不保证每次都是，所以不建议将网络数据放这里处理。</p><p><img src="/2022/12/05/Unity-Mirror%E5%AE%9E%E7%8E%B0%E5%B1%80%E5%9F%9F%E7%BD%91%E8%81%94%E6%9C%BA%E8%87%AA%E5%88%B6%E5%8D%A1%E7%89%8C%E6%B8%B8%E6%88%8F/image-20221129181141214.png" alt="image-20221129181141214"></p><h3 id="能够传输的数据类型"><a href="#能够传输的数据类型" class="headerlink" title="能够传输的数据类型"></a>能够传输的数据类型</h3><ul><li>C#基本类型——int, char, float 等</li><li>Untiy 数学类型——Vector3, Rect等</li><li>NetworlIdentity ——这就是为什么要给预制体添加这个组件</li><li>只包含上述类型的class、ScriptableObject（这两个会在接收端重新实例化从而产生垃圾）以及数组</li></ul><h3 id="特性"><a href="#特性" class="headerlink" title="特性"></a>特性</h3><p>知道何时以及如何使用以下特性，首先要明确你要同步什么变量，应该服务端执行还是客户端执行，以及传递的参数（尤其是涉及到GameObject的isOwned）在不同客户端下的不同执行情况</p><h4 id="Command"><a href="#Command" class="headerlink" title="[Command]"></a>[Command]</h4><p>拥有这个特性下的函数从客户端发送，由服务端执行。函数开头需要加上 <code>Cmd</code>前缀</p><p>避免每一帧都调用Cmd方法，这会产生巨大的流量</p><h4 id="ClientRpc"><a href="#ClientRpc" class="headerlink" title="[ClientRpc]"></a>[ClientRpc]</h4><p>服务端发送该函数，到客户端执行函数。开头需要加上 <code>Rpc</code>前缀</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Player</span> : <span class="title">NetworkBehaviour</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">int</span> health;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">TakeDamage</span>(<span class="params"><span class="built_in">int</span> amount</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (!isServer) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">        health -= amount;</span><br><span class="line">        RpcDamage(amount);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    [<span class="meta">ClientRpc</span>]</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">RpcDamage</span>(<span class="params"><span class="built_in">int</span> amount</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        Debug.Log(<span class="string">&quot;Took damage:&quot;</span> + amount);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用本地客户端作为主机运行游戏时，将在本地客户端上调用 ClientRpc 调用，即使它与服务器处于同一进程中</p><h4 id="TargetRpc"><a href="#TargetRpc" class="headerlink" title="[TargetRpc]"></a>[TargetRpc]</h4><p>clientRpc是会向所有client回调这个方法，有时候我们想让特定的client接受特定的回调，于是就有了回调特定client的方法</p><p>TargetRpc 函数由服务器上的用户代码调用，然后在指定网络连接的客户端上的相应客户端对象上调用。函数开头需要加上 <code>Target</code>前缀</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">public <span class="class"><span class="keyword">class</span> <span class="title">Player</span> :</span> NetworkBehaviour</span><br><span class="line">&#123;</span><br><span class="line">    public <span class="type">int</span> health;</span><br><span class="line"></span><br><span class="line">    [Command]</span><br><span class="line">    <span class="type">void</span> <span class="title function_">CmdMagic</span><span class="params">(GameObject target, <span class="type">int</span> damage)</span></span><br><span class="line">    &#123;</span><br><span class="line">        target.GetComponent&lt;Player&gt;().health -= damage;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 重点，尽管target没有在TargetDoMagic中使用，但必须传入</span></span><br><span class="line">        NetworkIdentity opponentIdentity = target.GetComponent&lt;NetworkIdentity&gt;();</span><br><span class="line">        TargetDoMagic(opponentIdentity.connectionToClient, damage);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    [TargetRpc]</span><br><span class="line">    public <span class="type">void</span> <span class="title function_">TargetDoMagic</span><span class="params">(NetworkConnection target, <span class="type">int</span> damage)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 这会出现在对手的客户端中，而不是攻击者的</span></span><br><span class="line">        Debug.Log($<span class="string">&quot;Magic Damage = &#123;damage&#125;&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 治疗自己</span></span><br><span class="line">    [Command]</span><br><span class="line">    public <span class="type">void</span> <span class="title function_">CmdHealMe</span><span class="params">()</span></span><br><span class="line">    &#123;</span><br><span class="line">        health += <span class="number">10</span>;</span><br><span class="line">        TargetHealed(<span class="number">10</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    [TargetRpc]</span><br><span class="line">    public <span class="type">void</span> <span class="title function_">TargetHealed</span><span class="params">(<span class="type">int</span> amount)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 没有指定NetworkConnection变量，因此出现在物体拥有者中</span></span><br><span class="line">        Debug.Log($<span class="string">&quot;Health increased by &#123;amount&#125;&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="SyncVar"><a href="#SyncVar" class="headerlink" title="[SyncVar]"></a>[SyncVar]</h4><p>SyncVar 是从 NetworkBehavior 继承的类的属性，这些类从服务器同步到客户端。当生成游戏对象或新玩家加入正在进行的游戏时，将向他们发送对他们可见的网络对象上所有 SyncVar 的最新状态。使用[SyncVar]指定脚本中要同步的变量。</p><p>能用Hook指定变量发生变量时将要调用的函数</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[<span class="meta">SyncVar(hook = nameof(OnHolaCountChanged))</span>]</span><br><span class="line"><span class="built_in">int</span> holaCount = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">OnHolaCountChanged</span>(<span class="params"><span class="built_in">int</span> oldCount, <span class="built_in">int</span> newCount</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    Debug.Log(<span class="string">$&quot;We had <span class="subst">&#123;oldCount&#125;</span> holas, but now we have <span class="subst">&#123;newCount&#125;</span> holas!&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>假设您正在制作一个库存系统。假设玩家 A、B 和 C 位于同一区域。整个网络中总共有 12 个对象：</p><ul><li>客户端 A 有玩家 A（他自己）、玩家 B 和玩家 C</li><li>客户端 B 有玩家 A、玩家 B（他自己）和玩家 C</li><li>客户端 C 有玩家 A、玩家 B 和玩家 C（他自己）</li><li>服务器有玩家 A、玩家 B、玩家 C</li></ul><p>除了服务器和客户端A之外，其他人没必要也不应该知道A的库存，典型用例包括任务、玩家在纸牌游戏中的手牌、技能、经验或您不需要与其他玩家共享的任何其他数据。</p><h3 id="演示"><a href="#演示" class="headerlink" title="演示"></a>演示</h3><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Update</span>()</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (!isLocalPlayer) <span class="keyword">return</span>;</span><br><span class="line">    HandleMovement();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (Input.GetKeyDown(KeyCode.X))</span><br><span class="line">    &#123;</span><br><span class="line">        Debug.Log(<span class="string">&quot;Sending Hola to Server!&quot;</span>);</span><br><span class="line">        CmdHola();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">[<span class="meta">Command</span>]</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">CmdHola</span>()</span></span><br><span class="line">&#123;</span><br><span class="line">    Debug.Log(<span class="string">&quot;Received Hola from Client!&quot;</span>);</span><br><span class="line">    TargetReplyHola();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">[<span class="meta">TargetRpc</span>]</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">TargetReplyHola</span>()</span></span><br><span class="line">&#123;</span><br><span class="line">    Debug.Log(<span class="string">&quot;Received Hola from Server!&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>客户端点击X：</p><p><img src="/2022/12/05/Unity-Mirror%E5%AE%9E%E7%8E%B0%E5%B1%80%E5%9F%9F%E7%BD%91%E8%81%94%E6%9C%BA%E8%87%AA%E5%88%B6%E5%8D%A1%E7%89%8C%E6%B8%B8%E6%88%8F/image-20221129145336669.png" alt="image-20221129145336669"></p><p>Host端点击X</p><p><img src="/2022/12/05/Unity-Mirror%E5%AE%9E%E7%8E%B0%E5%B1%80%E5%9F%9F%E7%BD%91%E8%81%94%E6%9C%BA%E8%87%AA%E5%88%B6%E5%8D%A1%E7%89%8C%E6%B8%B8%E6%88%8F/image-20221129145422279.png" alt="image-20221129145422279"></p><h1 id="游戏编写"><a href="#游戏编写" class="headerlink" title="游戏编写"></a>游戏编写</h1><h2 id="PlayPrefab"><a href="#PlayPrefab" class="headerlink" title="PlayPrefab"></a>PlayPrefab</h2><p>我们如果想要获取当前玩家的一些参数，需要按照以下代码获取——PlayerManger挂载在playerPrefab上</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 获取玩家预制体的NetworkIdentity</span></span><br><span class="line">NetworkIdentity networkIdentity = NetworkClient.connection.identity;</span><br><span class="line">playerManager = networkIdentity.GetComponent&lt;PlayerManager&gt;();</span><br></pre></td></tr></table></figure><p>这样我们调用 <code>PlayerManager.Function</code>时就是调用当前玩家的方法，记住这个方法在 <code>ClientRpc</code>中会很有用，比如给特定ID的玩家设定称号，就需要获取当前ID是否与特定ID相等</p><p>因为你必须确定是当前玩家的PlayerManager触发的函数，所以Cmd方法最好写在PlayerManager中，这个肯定会涉及到耦合。如果不想这样，可以自己新建一个类，但必须确认你调用的时候是当前玩家控制下的对应实例</p><h2 id="是否添加NetworkBehavior"><a href="#是否添加NetworkBehavior" class="headerlink" title="是否添加NetworkBehavior"></a>是否添加NetworkBehavior</h2><p>不是所有的物体都添加该组件，本游戏中比如玩家手牌，以及一些Manger管理器都是不用通信交互的，因为他们没必要让其他玩家知道。</p><p>但是呢，我们可以通过网络通信方法，TargetRpc、ClientRpc来改变这些没有networkBehavior的实例。</p><p>需要添加的一般有其中一个特征：</p><ul><li>连接之后创建的物体</li><li>需要进行同步的物体，比如玩家本身或者跟随其的宠物</li></ul><p>如果添加了这个组件都要拖拽到NetworkManager组件中的 <code>Registered Spawnable Prefab</code>中，这代表NetworkManager会同步这个物体的状态</p><h2 id="创建物体"><a href="#创建物体" class="headerlink" title="创建物体"></a>创建物体</h2><p>在服务器上“生成”游戏对象意味着在连接到服务器的客户端上创建游戏对象，并由生成系统管理。</p><p>使用此系统生成游戏对象后，只要服务器上的游戏对象发生更改，状态更新就会发送到客户端。当 Mirror 销毁服务器上的游戏对象时，也会销毁客户端上的游戏对象。服务器将生成的游戏对象与所有其他联网游戏对象一起管理，以便在其他客户端稍后加入游戏时，服务器可以在该客户端上生成游戏对象。这些生成的游戏对象具有称为“netId”的唯一网络实例 ID，该 ID 在每个游戏对象的服务器和客户端上都是相同的。</p><h2 id="游戏演示视频"><a href="#游戏演示视频" class="headerlink" title="游戏演示视频"></a>游戏演示视频</h2><p><a href="https://www.bilibili.com/video/BV1s44y1Q7VT/?vd_source=19c97c7473d6fc1c378d64079dda7638">Good Lock 演示视频_哔哩哔哩_bilibili</a></p><h2 id="模型锚点"><a href="#模型锚点" class="headerlink" title="模型锚点"></a>模型锚点</h2><p>网上找到的.fbx模型，一般里面的模型中心不在锚点上，这种一般的处理方法就是创建一个空的父物体，父物体的锚点控制在模型中心，但这样一个个改太慢了</p><p>写了一个脚本自动化改，放在Assets\Editor文件夹下</p><details>       <summary>具体代码：点击查看详细内容</summary>       <pre><code>using UnityEngine;using System.Collections;using System.Collections.Generic;using UnityEditor;public static class PivotEazier&#123;    [MenuItem("GameObject/Pivot/Create Pivot", false, 0)]    static void CreatePivotObject()    &#123;        if (Selection.activeGameObject != null)        &#123;            var pivot = CreatePivotObject(Selection.activeGameObject);            Selection.activeGameObject = pivot;        &#125;    &#125;    [MenuItem("GameObject/Pivot/Create Pivot (Local Zero)", false, 0)]    static void CreatePivotObjectAtParentPos()    &#123;        if (Selection.activeGameObject != null)        &#123;            var pivot = CreatePivotObjectAtParentPos(Selection.activeGameObject);            Selection.activeGameObject = pivot;        &#125;    &#125;    [MenuItem("GameObject/Pivot/Delete Pivot", false, 0)]    static void DeletePivotObject()    &#123;        GameObject objSelectionAfter = null;        if (Selection.activeGameObject != null)        &#123;            if (Selection.activeGameObject.transform.childCount > 0)            &#123;                objSelectionAfter = Selection.activeGameObject.transform.GetChild(0).gameObject;            &#125;            else if (Selection.activeGameObject.transform.parent != null)            &#123;                objSelectionAfter = Selection.activeGameObject.transform.parent.gameObject;            &#125;            DeletePivotObject(Selection.activeGameObject);            Selection.activeGameObject = objSelectionAfter;        &#125;    &#125;    private static GameObject CreatePivotObjectAtParentPos(GameObject current)    &#123;        if (current == null)        &#123;            return null;        &#125;        int siblingIndex = current.transform.GetSiblingIndex();        GameObject newObject = new GameObject(current.name);        newObject.transform.SetParent(current.transform.parent);        newObject.transform.localPosition = Vector3.zero;        newObject.transform.localScale = Vector3.one;        newObject.transform.localRotation = Quaternion.identity;        newObject.transform.SetSiblingIndex(siblingIndex);        current.transform.SetParent(newObject.transform);        return newObject;    &#125;    private static GameObject CreatePivotObject(GameObject current)    &#123;        if (current == null)        &#123;            return null;        &#125;        int siblingIndex = current.transform.GetSiblingIndex();        GameObject newObject = new GameObject("Pivot");        newObject.transform.SetParent(current.transform.parent);        newObject.transform.position = current.transform.position;        newObject.transform.localScale = current.transform.localScale;        newObject.transform.rotation = current.transform.rotation;        newObject.transform.SetSiblingIndex(siblingIndex);        current.transform.SetParent(newObject.transform);        return newObject;    &#125;    private static GameObject DeletePivotObject(GameObject current)    &#123;        Transform parent = current.transform.parent;        int childrenCount = current.transform.childCount;        int siblingIndex = current.transform.GetSiblingIndex();        Transform[] children = new Transform[childrenCount];        for (int i = 0; i < childrenCount; i++)        &#123;            children[i] = current.transform.GetChild(i);        &#125;        for (int i = 0; i < childrenCount; i++)        &#123;            children[i].SetParent(parent);            children[i].SetSiblingIndex(siblingIndex + i);        &#125;        if (Application.isPlaying)        &#123;            GameObject.Destroy(current);        &#125;        else        &#123;            GameObject.DestroyImmediate(current);        &#125;        if (children.Length > 0)        &#123;            return children[0].gameObject;        &#125;        else        &#123;            return null;        &#125;    &#125;&#125;</code></pre> </details><p>使用方法是将模式中心对齐其父物体中心，在Hierarchy窗口中右键<code>Create Pivot (Local Zero)</code>就可以</p>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;资源下载地址&quot;&gt;&lt;a href=&quot;#资源下载地址&quot; class=&quot;headerlink&quot; title=&quot;资源下载地址&quot;&gt;&lt;/a&gt;资源下载地址&lt;/h1&gt;&lt;p&gt;局域网联机插件 Mirror：&lt;a href=&quot;https://assetstore.unity.com/packages/tools/network/mirror-129321&quot;&gt;Mirror | 网络 | Unity Asset Store&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;本地客户端测试多人游戏（不用打包）插件 ： &lt;a href=&quot;https://github.com/VeriorPies/ParrelSync&quot;&gt;ParrelSync&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Mirror官方文档：&lt;a href=&quot;https://mirror-networking.gitbook.io/docs/general&quot;&gt;General - Mirror (gitbook.io)&lt;/a&gt;&lt;/p&gt;
&lt;h1 id=&quot;Mirror使用&quot;&gt;&lt;a href=&quot;#Mirror使用&quot; class=&quot;headerlink&quot; title=&quot;Mirror使用&quot;&gt;&lt;/a&gt;Mirror使用&lt;/h1&gt;&lt;h2 id=&quot;前置准备&quot;&gt;&lt;a href=&quot;#前置准备&quot; class=&quot;headerlink&quot; title=&quot;前置准备&quot;&gt;&lt;/a&gt;前置准备&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;导入Mirror Package&lt;/li&gt;
&lt;li&gt;创建空物体，添加 &lt;code&gt;Network Manager&lt;/code&gt;， &lt;code&gt;Network Manager HUD&lt;/code&gt;以及 &lt;code&gt;KCP Transport&lt;/code&gt;（也可以选择其他网络连接方式）&lt;/li&gt;
&lt;li&gt;导入&lt;code&gt;ParrelSync&lt;/code&gt;， 并为其clone当前项目，在此之后clone后的项目能同步你在本项目的所有修改&lt;/li&gt;
&lt;/ol&gt;</summary>
    
    
    
    
    <category term="Unity" scheme="https://ycy666666.github.io/tags/Unity/"/>
    
  </entry>
  
  <entry>
    <title>游戏优化之空间划分</title>
    <link href="https://ycy666666.github.io/2022/11/20/%E6%B8%B8%E6%88%8F%E4%BC%98%E5%8C%96%E4%B9%8B%E7%A9%BA%E9%97%B4%E5%88%92%E5%88%86/"/>
    <id>https://ycy666666.github.io/2022/11/20/%E6%B8%B8%E6%88%8F%E4%BC%98%E5%8C%96%E4%B9%8B%E7%A9%BA%E9%97%B4%E5%88%92%E5%88%86/</id>
    <published>2022-11-20T13:19:24.000Z</published>
    <updated>2022-11-21T04:10:12.724Z</updated>
    
    <content type="html"><![CDATA[<h1 id="使用的动机"><a href="#使用的动机" class="headerlink" title="使用的动机"></a>使用的动机</h1><p><strong>定义：将对象根据它们的位置存储在数据结构中，来高效地定位对象。</strong></p><p>在游戏中，AI向最近的敌人攻击是很常见的，但如果有很多单位的话，他们AI需要频繁的查找单位，然后在检测是不是距离最近的单位，时间复杂度是o(n ^ 2)</p><p>之所以会出现这个问题，是因为我们没有指明潜在的对象顺序。假如我们游戏的所有单位都只在一条直线上，我们只需要二分查找就可以找到最近对象了。操作系统中，有着局部性原理，我们也可以根据游戏物体的位置来存储对象，这样就能更快的找到他们</p><p><strong>注意事项：</strong></p><p>空间分区的存在是为了将<em>O(n)</em>或者<em>O(n²)</em> 的操作降到更加可控的数量级。 你拥有的对象<em>越多</em>，这就越重要。相反的，如果<em>n</em>足够小，也许不需要担心这个</p><p>这不仅能够用于存储可移动的游戏对象，还可用于静态美术等场景资源。如果对象发生移动，我们需要在数据结构中重新追踪该对象，这也会增加CPU消耗。</p><span id="more"></span><h1 id="实现方法"><a href="#实现方法" class="headerlink" title="实现方法"></a>实现方法</h1><p>实现模式有很多种，都有各自的性能优势</p><h2 id="固定网格"><a href="#固定网格" class="headerlink" title="固定网格"></a>固定网格</h2><p>将整个游戏战场分割为固定大小的网格中，每个格子分别存储一组单位，对象在网格中的存储方式应该是双向链表，因为他增删结点比较迅速</p><p><img src="/2022/11/20/%E6%B8%B8%E6%88%8F%E4%BC%98%E5%8C%96%E4%B9%8B%E7%A9%BA%E9%97%B4%E5%88%92%E5%88%86/spatial-partition-grid.png" alt="spatial-partition-grid"></p><p>在单位移动需要改变位置时，我们需要先判断是否穿越了格子的边界，如果穿越，我们需要先移除再添加到网格中</p><p>对于近距离攻击来说，只运算网格中的单位相互攻击是没啥大问题的。但是对于其他的攻击方式形成了新的问题，比如有一个远距离攻击的法师单位或者是能够冲锋的骑兵单位，就不能只判断单一网格。</p><p><img src="/2022/11/20/%E6%B8%B8%E6%88%8F%E4%BC%98%E5%8C%96%E4%B9%8B%E7%A9%BA%E9%97%B4%E5%88%92%E5%88%86/spatial-partition-adjacent.png" alt="spatial-partition-adjacent"></p><p>这时候我们不仅需要比较同一网格，还需要比较邻近网格对象</p><h1 id="空间划分依据"><a href="#空间划分依据" class="headerlink" title="空间划分依据"></a>空间划分依据</h1><h2 id="层次和平面划分"><a href="#层次和平面划分" class="headerlink" title="层次和平面划分"></a>层次和平面划分</h2><p><strong>层次划分：</strong></p><p><img src="/2022/11/20/%E6%B8%B8%E6%88%8F%E4%BC%98%E5%8C%96%E4%B9%8B%E7%A9%BA%E9%97%B4%E5%88%92%E5%88%86/2020062721372651.png" alt="2020062721372651"></p><p>层次空间划分将空间分成几个区域。 然后，如果其中一个区域还包含多个对象，再划分它。 这个过程递归进行，直到每个区域都有少于最大数量的对象在其中。</p><ul><li>处理空区域时更有效率，大片的空区域在单个划分上，不需要遍历很多个空的小空间</li><li>处理密集空间时也更有效率，当对象都聚集在一起时，每个网格仍然只有少量单位。</li></ul><p><strong>平面划分：</strong></p><p>内存使用量确定，因为划分不会有增删，分区的内存使用量固定</p><p>在对象改变位置时更新得更快，层次更新则需要多层级调整，甚至改变层次划分</p><h2 id="是否与对象有关"><a href="#是否与对象有关" class="headerlink" title="是否与对象有关"></a>是否与对象有关</h2><p><strong>与对象有关：</strong></p><p>固定划分中，移动单位意味着只需要从网格中删除，在加入到另一个网格中就可以了，但不是固定划分的话就需要改变边界，<strong>对象可以增量添加</strong>。 添加对象意味着找到正确的划分然后放入，这点可以一次性完成，没有任何性能问题。</p><p><strong>与对象无关：</strong></p><p>在BSP和KD树中这样各地适应对象划分世界，可以让每个部分都包含接近数目的对象，划分边界时需要考虑每一边各有多少对象。</p><p><img src="/2022/11/20/%E6%B8%B8%E6%88%8F%E4%BC%98%E5%8C%96%E4%B9%8B%E7%A9%BA%E9%97%B4%E5%88%92%E5%88%86/image-20221120192931583.png" alt="image-20221120192931583"></p><p>Oct-Tree：八叉树，对于三维空间中的一个场景将其横竖切三刀，切成八块，在二维空间表现为四叉。。</p><p>KD-Tree：k-d树每次只会选取一个基轴方向进行分割，比如二维空间中先沿x方向分割，然后再沿y轴方向分割。</p><p>BSP-Tree：也是每次划分选择一个方向将空间分成两部分，与KD-Tree相比它不是横平竖直的划分，不好计算</p><p><strong>其中八叉树可以拥有两者的优点：对象能够批量增加马，移动对象很快，分区是平衡的</strong></p><h2 id="存储是否唯一"><a href="#存储是否唯一" class="headerlink" title="存储是否唯一"></a>存储是否唯一</h2><p>空间划分还有一个值得注意的问题，空间分区是否是游戏对象存储的唯一地方</p><p><strong>如果唯一:</strong>这能够减少内存消耗</p><p><strong>如果不是：</strong>如果我们需要用除了位置关系外其他的方式来访问对象，比如特定种类的兵种，有了其他的数据保存结构我们能够更快的访问</p><h2 id="使用的数据结构"><a href="#使用的数据结构" class="headerlink" title="使用的数据结构"></a>使用的数据结构</h2><p>选择一套数据结构来存储网格及对象，这里要考虑静态场景和动态场景的区别</p><p><img src="/2022/11/20/%E6%B8%B8%E6%88%8F%E4%BC%98%E5%8C%96%E4%B9%8B%E7%A9%BA%E9%97%B4%E5%88%92%E5%88%86/image-20221121120551536.png" alt="image-20221121120551536"></p><p>方案a就是用的之前讲的双向链表，但其会造成内存浪费也会降低cpu cache命中</p><p>方案b用数组取代了链表来存储场景中的对象。<strong>数组是一块连续的内存地址，可以提高cpu cache的命中</strong>，而且相对于链表可以节省内存空间。每一个网格需要记录存储对象的其实位置，以及所属对象的个数。这需要遍历两次场景第一次确定每个网格的对象数量及对象的总数，第二次遍历分配场景对象。方案b适合静态场景，并且可以离线预处理</p><p>还有种方案是，如果场景很大但是游戏角色并不多，比如Apex等吃鸡游戏，那么就可以使用哈希表来存储，避免了大量检索空的网格</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>每种空间分区数据结构基本上都是将一维数据结构扩展成更高维度的数据结构。 </p><ul><li>网格是连续的桶排序</li><li>BSPs，k-d trees和包围盒是线性搜索树</li><li>四叉树和八叉树是多叉树</li></ul>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;使用的动机&quot;&gt;&lt;a href=&quot;#使用的动机&quot; class=&quot;headerlink&quot; title=&quot;使用的动机&quot;&gt;&lt;/a&gt;使用的动机&lt;/h1&gt;&lt;p&gt;&lt;strong&gt;定义：将对象根据它们的位置存储在数据结构中，来高效地定位对象。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;在游戏中，AI向最近的敌人攻击是很常见的，但如果有很多单位的话，他们AI需要频繁的查找单位，然后在检测是不是距离最近的单位，时间复杂度是o(n ^ 2)&lt;/p&gt;
&lt;p&gt;之所以会出现这个问题，是因为我们没有指明潜在的对象顺序。假如我们游戏的所有单位都只在一条直线上，我们只需要二分查找就可以找到最近对象了。操作系统中，有着局部性原理，我们也可以根据游戏物体的位置来存储对象，这样就能更快的找到他们&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;注意事项：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;空间分区的存在是为了将&lt;em&gt;O(n)&lt;/em&gt;或者&lt;em&gt;O(n²)&lt;/em&gt; 的操作降到更加可控的数量级。 你拥有的对象&lt;em&gt;越多&lt;/em&gt;，这就越重要。相反的，如果&lt;em&gt;n&lt;/em&gt;足够小，也许不需要担心这个&lt;/p&gt;
&lt;p&gt;这不仅能够用于存储可移动的游戏对象，还可用于静态美术等场景资源。如果对象发生移动，我们需要在数据结构中重新追踪该对象，这也会增加CPU消耗。&lt;/p&gt;</summary>
    
    
    
    
    <category term="Unity" scheme="https://ycy666666.github.io/tags/Unity/"/>
    
  </entry>
  
  <entry>
    <title>Unity 资源热更新</title>
    <link href="https://ycy666666.github.io/2022/11/17/Unity-%E8%B5%84%E6%BA%90%E7%83%AD%E6%9B%B4%E6%96%B0/"/>
    <id>https://ycy666666.github.io/2022/11/17/Unity-%E8%B5%84%E6%BA%90%E7%83%AD%E6%9B%B4%E6%96%B0/</id>
    <published>2022-11-17T12:25:44.000Z</published>
    <updated>2022-12-09T10:40:07.807Z</updated>
    
    <content type="html"><![CDATA[<h1 id="热更新流程"><a href="#热更新流程" class="headerlink" title="热更新流程"></a>热更新流程</h1><ol><li>启动游戏</li><li>根据当前版本号，和平台号去<strong>版本服务器</strong>上检查是否有热更</li><li>从<strong>热更服务器</strong>上下载md5文件，比对需要热更的具体文件列表</li><li>从<strong>热更服务器</strong>上下载需要热更的资源，解压到热更资源目录</li><li>游戏运行加载资源，优先到热更目录中加载，再到母包资源目录加载</li></ol><p>这些目录包含着不同版本的资源文件，以及用于版本控制的<code>Files.txt</code>，里面存放着资源文件的名称和md5码。</p><blockquote><p>客户端版本号我们是4位来标识，假设是X.Y.Z.W</p><p>X：【巨大版本号】这一位其实就是1，没事一般不会动他，除非有太巨大的变化，目前反正还是1；<br>Y：【整包更新版本号】：我们游戏一般一个月会有一个比较大的版本迭代，这种版本会走商店，每次提交Y值+1；<br>Z：【服务器协议版本号】，一个月度版本周期内，万一SDK有问题或者C#层有发现bug，需要更新商店，这一位会+1，这里单独留一个Z处理这种商店版本号，是因为不想影响Y值，而商店提交新包要求版本号必须有增加，buildNum也是商店要求必须要升的；<br>W：【编译版本号\热更版本号】，每次热更都+1 。<br>【第2位加1之后，3、4位全部清0】</p></blockquote><span id="more"></span><h2 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h2><p>相对于Resources下的资源，AB包可以更好地管理资源，更灵活方便，更易于做热更新相关工作</p><p><img src="/2022/11/17/Unity-%E8%B5%84%E6%BA%90%E7%83%AD%E6%9B%B4%E6%96%B0/image-20221117200824511.png" alt="image-20221117200824511"></p><h1 id="AssetBundle"><a href="#AssetBundle" class="headerlink" title="AssetBundle"></a>AssetBundle</h1><p><strong>AssetBundle</strong> 是一个存档文件，包含可在运行时由 Unity 加载的特定于平台的非代码资源（比如模型、纹理、预制件、音频剪辑甚至整个场景）。AssetBundle 可以表示彼此之间的依赖关系；例如，一个 AssetBundle 中的材质可以引用另一个 AssetBundle 中的纹理。</p><p><strong>AssetBundle对于可下载内容(DLC)、减少初始安装大小、加载针对最终用户平台优化的资产以及减少运行时内存压力都很有用</strong></p><p><strong>AssetBundle里面包含了什么？</strong></p><ul><li>首先是磁盘上的实际文件，这称为AssetBundle archive。AssetBundle archive是一个容器，就像一个文件夹一样，其中包含了额外的文件。这些额外的文件包括两类:<ul><li>序列化文件，其中包含分解为各个对象并写入此单个文件的资源。</li><li>资源文件，这是为某些资源（纹理和音频）单独存储的二进制数据块，允许 Unity 高效地在另一个线程上从磁盘加载它们。</li></ul></li><li>也可以指：通过代码进行交互以便从特定 AssetBundle 存档加载资源的实际 AssetBundle 对象。该对象包含添加到此存档文件的资源的所有文件路径的映射</li></ul><h1 id="游戏资源目录"><a href="#游戏资源目录" class="headerlink" title="游戏资源目录"></a>游戏资源目录</h1><ul><li><strong>Resources</strong>：全部资源都会被压缩，转化成二进制。打包后该路径不存在，不可写也不可读。只能使用<code>Resources.Load</code>加载资源。</li><li><strong>Streaming Assets</strong>：全部资源原封不动打包。<strong>在移动平台下，是只读的</strong>，不能写入数据，其他平台下可以使用<code>System.File</code>类进行读写。在任意平台都可以使用<code>AssetBundle.LoadFromFile</code>来从此文件夹读取加载ab包。</li></ul><h1 id="AssetBundle管理"><a href="#AssetBundle管理" class="headerlink" title="AssetBundle管理"></a>AssetBundle管理</h1><p><img src="/2022/11/17/Unity-%E8%B5%84%E6%BA%90%E7%83%AD%E6%9B%B4%E6%96%B0/v2-530769033485f56fde4dd46f8e5fc78d_720w.jpg" alt="v2-530769033485f56fde4dd46f8e5fc78d_720w"></p><h2 id="打包资源"><a href="#打包资源" class="headerlink" title="打包资源"></a>打包资源</h2><p>将需要同时加载的资源放在同一个包里，各个包之间会保存相互依赖的信息</p><p>分组依据：</p><ul><li>逻辑实体分组：是指根据资源所代表的项目功能部分将资源分配给 AssetBundle。这包括各种不同部分，比如一组角色的所有模型和动画、多个关卡之间共享的景物的纹理和模型</li><li>类型分组：要构建供多个平台使用的 AssetBundle，类型分组是最佳策略之一。如果音频压缩设置在 Windows 和 Mac 平台上完全相同，则可以将所有音频数据打包到 AssetBundle 并重复使用，而着色器往往使用更多特定于平台的选项进行编译</li><li>并发内容分组： 将需要同时加载和使用的资源捆绑在一起。可以将这些类型的捆绑包用于基于关卡的游戏（其中每个关卡包含完全独特的角色、纹理、音乐等）。</li></ul><h2 id="卸载资源"><a href="#卸载资源" class="headerlink" title="卸载资源"></a>卸载资源</h2><p>在管理Asset和AssetBundle时，最重要的一点是调用<code>AssetBundle.unload</code>时的方式，unload参数为true或false。</p><blockquote><p>此API将卸载正在调用的AssetBundle的包头信息。unload参数决定是否也卸载从此AssetBundle实例化的所有对象。如果设置为true，那么从AssetBundle创建的所有对象也将立即卸载，即使它们目前正在活动场景中被引用。</p></blockquote><p><img src="/2022/11/17/Unity-%E8%B5%84%E6%BA%90%E7%83%AD%E6%9B%B4%E6%96%B0/image-20221117193014125.png" alt="image-20221117193014125"></p><p>如果调用了<code>AssetBundle.Unload(True)</code>，则M将从场景中移除，销毁并卸载。但是，如果调用<code>AssetBundle.Unload(False)</code>，则AB的包头信息将被卸载，但M将保持在场景中，并且仍然是可用的。</p><p>调用<code>AssetBundle.Unload(False)</code>破坏了M和AB之间的链接。如果AB稍后再次加载，则AB中包含的对象的新副本将会被加载到内存中。此后如果再次加载AB，将再次加载这个包头信息的新副本，但是M和这个包并不会重新建立连接。如果此时调用<code>AssetBundle.LoadAsset()</code>来重新加载M，将会有两个相同的副本M在现场。</p><p><img src="/2022/11/17/Unity-%E8%B5%84%E6%BA%90%E7%83%AD%E6%9B%B4%E6%96%B0/image-20221117193416358.png" alt="image-20221117193416358"></p><p>为了避免这种情况，应该使用<code>AssetBundle.Unload(True)</code>，并来确保对象不被复制，具体做法是：</p><ol><li>在应用程序的生命周期内定义一个合适的节点，并在此期间卸载不需要的AssetBundle，例如<strong>在关卡切换或加载屏幕期间</strong>。这是最简单和最常见的选择。</li><li>维护单个对象的引用计数，并<strong>仅当所有组成对象都未使用时才卸载AssetBundle</strong>。这允许应用程序在不重复内存的情况下卸载和重新加载单个对象</li></ol><p>另一个问题是：如果AssetBundle卸载后重新加载一个对象，重新加载将失败，该对象将以（Missing）对象的形式出现在Unity编辑器的层次结构中，材质会呈现洋红色。主要会发生在Unity失去并试图恢复对其图形上下文的控制时，例如当移动应用程序被挂起或用户锁定他们的PC时</p><h2 id="加载AssetBundles"><a href="#加载AssetBundles" class="headerlink" title="加载AssetBundles"></a>加载AssetBundles</h2><p>AssetBundles可以通过四个不同的API进行加载。但受限于两个标准，这四个API的行为是不同的。两个标准如下：</p><ul><li>AssetBundles的压缩方式：LZMA、LZ4、还是未压缩的。</li><li>AssetBundles的加载平台。</li></ul><p>而四个API分别是：</p><ul><li><code>AssetBundle.LoadFromMemory(Async optional)</code>：<strong>不要使用这个API</strong>，因为他会冗余多次</li><li><code>AssetBundle.LoadFromFile(Async optional)</code>：用于从本地存储（如硬盘或SD卡）加载<strong>未压缩或LZ4压缩格式</strong>的AssetBundle。</li><li><code>UnityWebRequest&#39;s DownloadHandlerAssetBundle</code></li><li><code>WWW.LoadFromCacheOrDownload</code> (on Unity 5.6 or older)</li></ul><p>一般来说，只要有可能，就应该使用<code>AssetBundle.LoadFromFile</code>。这个API在速度、磁盘使用和运行时内存使用方面是最有效的。</p><h2 id="从AssetBundles中加载Assets"><a href="#从AssetBundles中加载Assets" class="headerlink" title="从AssetBundles中加载Assets"></a>从AssetBundles中加载Assets</h2><p>Unity提供了三个不同的API从AssetBundles加载<code>UnityEngine.Objects</code>，这些API都绑定到AssetBundle对象上，并且这些API具有同步和异步变体，这些API的<strong>同步版本总是比异步版本快至少一个帧</strong>（因为异步版本为了确保异步，都至少延迟了1帧）：</p><ul><li><code>LoadAsset (LoadAssetAsync)</code></li><li><code>LoadAllAssets (LoadAllAssetsAsync)</code></li><li><code>LoadAssetWithSubAssets (LoadAssetWithSubAssetsAsync)</code></li></ul><blockquote><p>加载多个独立的<code>UnityEngine.Objects</code>时应使用<code>LoadAllAsset</code>。并且只有在需要加载AssetBundle中的大多数或所有对象时，才应该使用它。<code>LoadAllAsset</code>比对<code>LoadAsset</code>的多个单独调用略快一些</p></blockquote><p><strong>Object加载是在主线程上执行，但数据从工作线程上的存储中读取</strong>。任何不触碰Unity系统中线程敏感部分（脚本、图形）的工作都将在工作线程上转换。例如，VBO将从网格创建，纹理将被解压等等。<strong>当一个Object完成加载时，它的Awake回调将被调用，该对象的其余部分将在下一个帧中对UnityEngine可用。</strong></p>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;热更新流程&quot;&gt;&lt;a href=&quot;#热更新流程&quot; class=&quot;headerlink&quot; title=&quot;热更新流程&quot;&gt;&lt;/a&gt;热更新流程&lt;/h1&gt;&lt;ol&gt;
&lt;li&gt;启动游戏&lt;/li&gt;
&lt;li&gt;根据当前版本号，和平台号去&lt;strong&gt;版本服务器&lt;/strong&gt;上检查是否有热更&lt;/li&gt;
&lt;li&gt;从&lt;strong&gt;热更服务器&lt;/strong&gt;上下载md5文件，比对需要热更的具体文件列表&lt;/li&gt;
&lt;li&gt;从&lt;strong&gt;热更服务器&lt;/strong&gt;上下载需要热更的资源，解压到热更资源目录&lt;/li&gt;
&lt;li&gt;游戏运行加载资源，优先到热更目录中加载，再到母包资源目录加载&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;这些目录包含着不同版本的资源文件，以及用于版本控制的&lt;code&gt;Files.txt&lt;/code&gt;，里面存放着资源文件的名称和md5码。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;客户端版本号我们是4位来标识，假设是X.Y.Z.W&lt;/p&gt;
&lt;p&gt;X：【巨大版本号】这一位其实就是1，没事一般不会动他，除非有太巨大的变化，目前反正还是1；&lt;br&gt;Y：【整包更新版本号】：我们游戏一般一个月会有一个比较大的版本迭代，这种版本会走商店，每次提交Y值+1；&lt;br&gt;Z：【服务器协议版本号】，一个月度版本周期内，万一SDK有问题或者C#层有发现bug，需要更新商店，这一位会+1，这里单独留一个Z处理这种商店版本号，是因为不想影响Y值，而商店提交新包要求版本号必须有增加，buildNum也是商店要求必须要升的；&lt;br&gt;W：【编译版本号\热更版本号】，每次热更都+1 。&lt;br&gt;【第2位加1之后，3、4位全部清0】&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    
    <category term="Unity" scheme="https://ycy666666.github.io/tags/Unity/"/>
    
  </entry>
  
  <entry>
    <title>浅析GC-垃圾回收</title>
    <link href="https://ycy666666.github.io/2022/11/14/%E6%B5%85%E6%9E%90GC-%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/"/>
    <id>https://ycy666666.github.io/2022/11/14/%E6%B5%85%E6%9E%90GC-%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/</id>
    <published>2022-11-14T14:05:51.000Z</published>
    <updated>2022-11-22T12:17:41.172Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前置知识"><a href="#前置知识" class="headerlink" title="前置知识"></a>前置知识</h1><h2 id="CLR：公共语言运行时"><a href="#CLR：公共语言运行时" class="headerlink" title="CLR：公共语言运行时"></a>CLR：公共语言运行时</h2><p>CLR（Common Language Runtime）：CLR的核心功能包括<strong>内存管理，程序集加载，类型安全，异常处理和线程同步</strong>，而且还负责对代码实施严格的类型安全检查，保证代码的准确性，这些功能都可以提供给面向CLR的所有语言</p><p>CLR并不关心是使用何种语言进行编程开发，只要编译器是面向CLR而进行编译的即可，这个中间的结果，就是IL(Intermediate Language), 最终面向CLR编译得到的结果是：IL语句以及托管数据(元数据)组成的托管模块</p><p><img src="/2022/11/14/%E6%B5%85%E6%9E%90GC-%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/image-20221114185011460.png" alt="image-20221114185011460"></p><span id="more"></span><h2 id="托管资源与非托管资源"><a href="#托管资源与非托管资源" class="headerlink" title="托管资源与非托管资源"></a>托管资源与非托管资源</h2><p>托管就是.net framework 负责帮你管理内存及资源释放，不需要自己控制。</p><p>对于引用类型，栈上保存着一个地址而已，当栈释放后， 即使对象已经没有用了，但<strong>堆上分配的内存还在</strong>，只能等<strong>GC收集时才能真正释放</strong>。但对于值类型，GC会<strong>自动释放</strong>他们占用的内存，不需要GC来<strong>回收释放</strong></p><ul><li>托管资源指的是.NET可以自动进行回收的资源，主要是指托管堆上分配的内存资源。托管资源的回收工作是不需要人工干预的，由.NET运行时在适当的时候调用垃圾回收器进行回收。例如程序中分配的对象,作用域内的变量等</li><li>非托管资源指的是.NET不知道如何回收的资源，最常见的一类非托管资源如文件、窗口、网络连接、数据库连接等。这类资源，垃圾回收器在清理的时候会调用<code>Object.Finalize()</code>方法。默认情况下，方法是空的，<strong>对于非托管对象，需要在此方法中编写回收非托管资源的代码</strong>，以便垃圾回收器正确回收资源</li></ul><blockquote><p>托管代码和非托管代码</p><p>托管代码：由公共语言运行库环境（而不是直接由操作系统）执行的代码。托管代码应用程序可以获得公共语言运行库服务，例如自动垃圾回收、运行库类型检查和安全支持等。</p><p>非托管代码：<strong>在公共语言运行库环境的外部，由操作系统直接执行的代码</strong>。非托管代码必须提供自己的垃圾回收、类型检查、安全支持等服务。</p></blockquote><h1 id="内存管理机制"><a href="#内存管理机制" class="headerlink" title="内存管理机制"></a>内存管理机制</h1><h2 id="值数据类型的内存管理"><a href="#值数据类型的内存管理" class="headerlink" title="值数据类型的内存管理"></a>值数据类型的内存管理</h2><p>在进程的虚拟内存中，有一个区域称为栈。C#的值类型数据、传递给方法的参数副本都存储在这个栈中。在栈中存储数据时，是从高内存地址向低内存地址填充的。操作系统维护一个变量，称为栈指针，栈指针总是会指向栈中下一个空闲存储单元的地址。</p><p>函数调用在执行时，首先要在栈中为形参和局部变量分配存储空间，然后还要将实参的值复制给形参，接下来还要将函数的返回地址（该地址指明了函数执行结束后，程序应该回到哪里继续执行）放入栈中，最后才跳转到函数内部执行。这个过程是要耗费时间的。<strong>C# 函数执行 return 语句返回时，需要从栈中回收形参和局部变量占用的存储空间，然后从栈中取出返回地址</strong>，再跳转到该地址继续执行，这个过程也要耗费时间。</p><h2 id="如何垃圾回收"><a href="#如何垃圾回收" class="headerlink" title="如何垃圾回收"></a>如何垃圾回收</h2><p><strong>当满足以下条件之一时CLR将发生垃圾回收：</strong></p><ol><li>系统具有低的物理内存。</li><li><strong>由托管堆上已分配的对象使用的内存超出了可接受的阈值（涉及到代的概念）</strong>。随着进程的运行，此阈值会不断地进行调整。</li><li>强制调用 <code>GC.Collect</code> 方法。</li><li>CLR正在卸载应用程序域（<code>AppDomain</code>）</li><li>CLR正在关闭。</li></ol><h3 id="具体流程："><a href="#具体流程：" class="headerlink" title="具体流程："></a>具体流程：</h3><p>GC是一种<strong>分代式垃圾回收器</strong>，使用引用计数算法，该算法只关心引用类型变量</p><blockquote><p>根对象：相当于是当前存活对象的合集，GC去搜索能被该集合直接或者是间接指向的对象</p></blockquote><ul><li>GC的准备阶段：<pre><code>在这个阶段，CLR会暂停进程中的所有线程，这是为了防止线程在CLR检查根期间访问堆。</code></pre></li><li>GC的标记阶段：<br>当GC开始运行时，它会假设托管堆上的所有对象都是垃圾。然后GC开始遍历根对象并让所有与之有引用关系的对象构成一个<strong>对象图</strong>，假如一个根对象指向null，GC会忽略这个根并继续检查下个根。</li></ul><p>下图是<strong>回收之前的托管堆模型</strong>，根直接引用了对象A，C，D，F。标记对象D时，垃圾回收器发现这个对象含有一个引用对象H的字段，所以H也会被标记，整个过程一直持续到所有根检查完毕。<code>NextObjPtr</code>对象始终保持指向最后一个对象放入托管堆的地址</p><p><strong>如果GC发现一个对象已经在图中就会换一个路径继续遍历。这样做有两个目的：一是提高性能，二是避免无限循环。</strong></p><p><img src="/2022/11/14/%E6%B5%85%E6%9E%90GC-%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/image-20221114193614095.png" alt="image-20221114193614095"></p><ul><li>GC的碎片整理阶段<br>托管堆上所有不在这个图上的对象就是要做回收的垃圾对象了。同时，CLR会使堆中非垃圾对象覆盖占用连续的内存空间（还伴随着对根返回新的内存地址的行为），这样一方面恢复了引用的“局部化”，也解决了本机堆的空间碎片化问题。</li></ul><p><img src="/2022/11/14/%E6%B5%85%E6%9E%90GC-%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/image-20221114195707900.png" alt="image-20221114195707900"></p><ul><li>GC恢复阶段<br>恢复暂停的所有线程，使这些线程可以继续访问对象。</li></ul><p>值得注意的是，将引用赋值为null并不意味着强制GC立即启动并把对象从堆上移除，唯一完成的事情是显式取消了引用和之前 引用所指向对象之间的连接</p><h2 id="代数概念（Generation）"><a href="#代数概念（Generation）" class="headerlink" title="代数概念（Generation）"></a>代数概念（Generation）</h2><p>代的分代式垃圾回收器，而代就是一种为了降低GC对性能影响的机制，垃圾回收有两个基本原理：</p><ol><li>对象越新，生命周期越短，反之也成立</li><li>回收托管堆的一部分，速度快于回收整个堆</li></ol><p>托管堆中的每个对象都可以被分为0、1、2三个代，表示他们经历了几次GC仍没有被回收</p><ul><li>低一代的GC触发，移动到高一代后，未必会触发高一代的GC，只有高一代的内存不足时才会触发高一代的GC</li><li>不同代的自动GC频率是可以设置的</li></ul><p><img src="/2022/11/14/%E6%B5%85%E6%9E%90GC-%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/image-20221114200653061.png" alt="image-20221114200653061"></p><p>第 0 代满的时候触发GC，GC后第 0 代对象不包括任何对象，并且第一代对象也已经被压缩整理到连续的地址空间中<img src="/2022/11/14/%E6%B5%85%E6%9E%90GC-%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/image-20221114200703105.png" alt="image-20221114200703105"></p><p>超过第 0 代预算时再次触发GC，<strong>假如第 1 代占用内存远少于预算，GC将只检查第 0 代对象，即便此时原来的第 1 代对象中也出现了垃圾对象</strong></p><p><img src="/2022/11/14/%E6%B5%85%E6%9E%90GC-%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/image-20221114200713580.png" alt="image-20221114200713580"></p><h2 id="非托管对象资源回收"><a href="#非托管对象资源回收" class="headerlink" title="非托管对象资源回收"></a>非托管对象资源回收</h2><p>大多数类型只要分配了内存就能够正常工作，但有的类型除了内存还需要本机资源，比如说常用的FileStream，便需要打开一个文件（本机资源）并保存文件句柄，或者是数据库连接信息，那么我们就需要显式释放非托管对象，因为GC仅能跟踪托管堆上的内存资源</p><h3 id="可终结对象（Finalize）"><a href="#可终结对象（Finalize）" class="headerlink" title="可终结对象（Finalize）"></a>可终结对象（Finalize）</h3><p>Finalize方法（C#中是析构函数），允许对象在判定为垃圾之后，在对象内存在回收之前执行一些代码。当一个对象被判定不可达后，对象将终结它自己，并释放包装着的本机资源，之后，GC再从托管堆中回收对象。</p><p>Finalize虽然看似手动清除非托管资源，其实还是由垃圾回收器维护，它的最大作用是确保非托管资源一定被释放</p><p><strong>Finalize方法的执行时间无法控制，所以原则上并不提倡使用终结器机制</strong></p><h3 id="可处置对象（IDisposable）"><a href="#可处置对象（IDisposable）" class="headerlink" title="可处置对象（IDisposable）"></a>可处置对象（IDisposable）</h3><p>为了更快更具操作性进行释放，而非让垃圾回收器（即不可预知）来进行，可以使用Dispose，即实现IDispose接口</p><p>结构和类类型都可以实现IDispose（与重写Finalize不同，Finalize只适用于类类型），<strong>因为不是垃圾回收器来调用Dispose方法，而是对象本身释放非托管资源</strong>，这也意味着如果没有调用Dispose（）方法，非托管资源永远得不到释放</p><p>同样的，Dispose方法也不会将托管对象从托管堆中删除，<strong>我们要记住在正常情况下，只有在GC之后，托管堆中的内存才能得以释放</strong>。习惯用法是将Dispose方法放入try finally的finally块中，以确保代码的顺利执行</p><h2 id="Unity内存管理"><a href="#Unity内存管理" class="headerlink" title="Unity内存管理"></a>Unity内存管理</h2><p><strong>Unity自动内存管理机制</strong></p><ol><li>unity内部有两个内存管理池：堆内存和栈内存。栈内存(stack)主要用来存储较小的和短暂的数据，堆内存(heap)主要用来存储较大的和存储时间较长的数据。</li><li>unity中的变量只会在堆栈或者堆内存上进行内存分配，变量要么存储在堆栈内存上，要么处于堆内存上。</li><li>只要变量处于激活状态，则其占用的内存会被标记为使用状态，则该部分的内存处于被分配的状态。</li><li>一旦变量不再激活，则其所占用的内存不再需要，该部分内存可以被回收到内存池中被再次使用，这样的操作就是内存回收。处于栈上的内存回收极其快速，处于堆上的内存并不是及时回收的，此时其对应的内存依然会被标记为使用状态。</li><li>垃圾回收主要是指堆上的内存分配和回收，unity中会定时对堆内存进行GC操作。</li></ol><p><strong>利用profiler window 来检测堆内存分配</strong></p><p>在CPU usage分析窗口中，我们可以检测任何一帧cpu的内存分配情况。其中一个选项是GC Alloc，通过分析其来定位是什么函数造成大量的堆内存分配操作</p><h1 id="如何减少GC副作用"><a href="#如何减少GC副作用" class="headerlink" title="如何减少GC副作用"></a>如何减少GC副作用</h1><p>主要有三种方法降低影响：</p><ul><li>减少GC的运行次数；</li><li>减少单次GC的运行时间；</li><li>将GC的运行时间延迟，避免在关键时候触发，比如可以在场景加载的时候调用GC</li></ul><p>分别对应着三个策略：</p><ul><li></li><li><p>对游戏进行重构，减少堆内存的分配和引用的分配。更少的变量和引用会减少GC操作中的检测个数从而提高GC的运行效率。</p></li><li>降低堆内存分配和回收的频率，尤其是在关键时刻。也就是说更少的事件触发GC操作，同时也降低堆内存的碎片化。</li><li>我们可以试着按照可预测的顺序执行。当然这样操作的难度极大</li></ul><h2 id="缓存变量"><a href="#缓存变量" class="headerlink" title="缓存变量"></a>缓存变量</h2><p>如果在代码中反复调用某些造成堆内存分配的函数但是其返回结果并没有使用，这就会造成不必要的内存垃圾，我们可以缓存这些变量来重复利用</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 下面的代码每次调用的时候就会新分配一个数组，造成堆内存分配</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">OnTriggerEnter</span>(<span class="params">Collider other</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">     Renderer[] allRenderers = FindObjectsOfType&lt;Renderer&gt;();</span><br><span class="line">     ExampleFunction(allRenderers);      </span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// --------修改为---------</span></span><br><span class="line"><span class="keyword">private</span> Renderer[] allRenderers;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Start</span>()</span></span><br><span class="line">&#123;</span><br><span class="line">   allRenderers = FindObjectsOfType&lt;Renderer&gt;();</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">OnTriggerEnter</span>(<span class="params">Collider other</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    ExampleFunction(allRenderers);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果是链表等数据结构，记得需要先调用 <code>Clear()</code>函数</p><p>同时也要避免在 <code>Update</code>等函数中反复进行堆内存分配</p><h2 id="对象池方法"><a href="#对象池方法" class="headerlink" title="对象池方法"></a>对象池方法</h2><p>如果游戏有大量的对象需要产生和销毁依然会造成GC。对象池技术可以通过重复使用对象来降低堆内存的分配和回收频率。对象池在游戏中广泛的使用，特别是在游戏中需要频繁的创建和销毁相同的游戏对象的时候，例如枪的子弹</p><p>更进一步，可以不将整个游戏物体 <code>SetActive(false)</code>而是只取消掉他的关键组件</p><h2 id="字符串调用"><a href="#字符串调用" class="headerlink" title="字符串调用"></a>字符串调用</h2><p>在c#中，字符串是引用类型变量而不是值类型变量。</p><p>c#中的字符串在创建后是不可变更的。每次在对字符串进行操作的时候（例如运“加”操作），会新建一个字符串用来存储新的字符串，使得旧的字符串被废弃，这样就会造成内存垃圾</p><p>在Text文本组件中，我们可以分离常量字符串和需要修改的字符串（尤其是表示UI数字的Text），去除 + 操作符，实施创建的字符串还可以使用 <code>StringBuilder</code> </p><h2 id="Unity函数调用"><a href="#Unity函数调用" class="headerlink" title="Unity函数调用"></a>Unity函数调用</h2><h3 id="迭代器"><a href="#迭代器" class="headerlink" title="迭代器"></a>迭代器</h3><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 下面的代码中对于每个迭代器都会产生一个新的数组</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ExampleFunction</span>()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="built_in">int</span> i=<span class="number">0</span>; i &lt; myMesh.normals.Length;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        Vector3 normal = myMesh.normals[i];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// ----修改为---------</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ExampleFunction</span>()</span></span><br><span class="line">&#123;</span><br><span class="line">    Vector3[] meshNormals = myMesh.normals;</span><br><span class="line">    <span class="keyword">for</span>(<span class="built_in">int</span> i=<span class="number">0</span>; i &lt; meshNormals.Length;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        Vector3 normal = meshNormals[i];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="协程"><a href="#协程" class="headerlink" title="协程"></a>协程</h3><p>调用 StartCoroutine()会产生少量的内存垃圾，因为unity会生成实体来管理协程。所以在游戏的关键时刻应该限制该函数的调用</p><p>yield在协程中不会产生堆内存分配，但是如果yield带有参数返回，则会造成不必要的内存垃圾，比如应该将 <code>yield return 0</code> 改为 <code>yield return null</code>,否则会引发装箱</p><p>也尽量少返回一个新创建的变量</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span>(!isComplete)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">yield</span> <span class="keyword">return</span> <span class="keyword">new</span> <span class="title">WaitForSeconds</span>(<span class="params"><span class="number">1f</span></span>)</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 我们可以采用缓存来避免这样的内存垃圾产生：</span></span><br><span class="line"></span><br><span class="line">WaitForSeconds delay = <span class="keyword">new</span> WaiForSeconds(<span class="number">1f</span>);</span><br><span class="line"><span class="keyword">while</span>(!isComplete)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">yield</span> <span class="keyword">return</span> delay;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h3><ul><li>LINQ和常量表达式以装箱的方式实现，所以在使用的时候最好进行性能测试</li><li>struct是值类型的变量，但是如果struct中包含有引用类型的变量，那么GC就必须检测整个struct。</li></ul>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;前置知识&quot;&gt;&lt;a href=&quot;#前置知识&quot; class=&quot;headerlink&quot; title=&quot;前置知识&quot;&gt;&lt;/a&gt;前置知识&lt;/h1&gt;&lt;h2 id=&quot;CLR：公共语言运行时&quot;&gt;&lt;a href=&quot;#CLR：公共语言运行时&quot; class=&quot;headerlink&quot; title=&quot;CLR：公共语言运行时&quot;&gt;&lt;/a&gt;CLR：公共语言运行时&lt;/h2&gt;&lt;p&gt;CLR（Common Language Runtime）：CLR的核心功能包括&lt;strong&gt;内存管理，程序集加载，类型安全，异常处理和线程同步&lt;/strong&gt;，而且还负责对代码实施严格的类型安全检查，保证代码的准确性，这些功能都可以提供给面向CLR的所有语言&lt;/p&gt;
&lt;p&gt;CLR并不关心是使用何种语言进行编程开发，只要编译器是面向CLR而进行编译的即可，这个中间的结果，就是IL(Intermediate Language), 最终面向CLR编译得到的结果是：IL语句以及托管数据(元数据)组成的托管模块&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/2022/11/14/%E6%B5%85%E6%9E%90GC-%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/image-20221114185011460.png&quot; alt=&quot;image-20221114185011460&quot;&gt;&lt;/p&gt;</summary>
    
    
    
    
    <category term="C#" scheme="https://ycy666666.github.io/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>帧同步和状态同步</title>
    <link href="https://ycy666666.github.io/2022/11/09/%E5%B8%A7%E5%90%8C%E6%AD%A5%E5%92%8C%E7%8A%B6%E6%80%81%E5%90%8C%E6%AD%A5/"/>
    <id>https://ycy666666.github.io/2022/11/09/%E5%B8%A7%E5%90%8C%E6%AD%A5%E5%92%8C%E7%8A%B6%E6%80%81%E5%90%8C%E6%AD%A5/</id>
    <published>2022-11-09T11:22:52.000Z</published>
    <updated>2022-11-09T11:23:48.049Z</updated>
    
    <content type="html"><![CDATA[<h1 id="网络同步"><a href="#网络同步" class="headerlink" title="网络同步"></a>网络同步</h1><p>网络同步主要目的在于保证各个端口的游戏表现一致，<strong>网络同步就在于实时的多段数据同步和实时的多端表现。</strong></p><p>而对于大多数游戏，不仅客户端的表现要一致，而且需要客户端和服务端的数据是一致的。所以，同步是一个网络游戏概念，只有网络游戏才需要同步，而单机游戏是不需要同步的。</p><h1 id="帧同步与状态同步的区别"><a href="#帧同步与状态同步的区别" class="headerlink" title="帧同步与状态同步的区别"></a>帧同步与状态同步的区别</h1><h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><ul><li><strong>帧同步（Lock Step）</strong>：同步的是客户端的操作指令。客户端上传操作到服务器，并且服务器并不做过多的处理，然后将当前帧间隔内收集到的操作指令广播给每一个客户端，各个客户端在一致环境下，处理同样的操作输入，则会得到同样的结果。</li></ul><p><img src="/2022/11/09/%E5%B8%A7%E5%90%8C%E6%AD%A5%E5%92%8C%E7%8A%B6%E6%80%81%E5%90%8C%E6%AD%A5/image-20221109171737311.png" alt="image-20221109171737311"></p><ul><li><p><strong>状态同步（State Synchronization）</strong>：同步的是游戏中的各种状态。一般的流程是客户端上传操作到服务器，服务器收到后计算游戏行为的结果，然后以广播的方式下发游戏中各种状态，客户端收到状态后再根据状态显示内容。</p><p><img src="/2022/11/09/%E5%B8%A7%E5%90%8C%E6%AD%A5%E5%92%8C%E7%8A%B6%E6%80%81%E5%90%8C%E6%AD%A5/image-20221109180036949.png" alt="image-20221109180036949"></p></li></ul><span id="more"></span><h2 id="逻辑计算"><a href="#逻辑计算" class="headerlink" title="逻辑计算"></a>逻辑计算</h2><p>战斗逻辑在帧同步中是在客户端计算，在状态同步中是由服务端计算的。</p><p>帧同步下服务端只进行转发操作，不进行逻辑处理。但是计算逻辑必须知道涉及计算的实例情况，因此大型多人游戏（MMO）就必须交给服务端计算，因为远距离的单位以及场景都不显示，客户端没有足够信息计算全图的行为</p><p>状态同步下，客户端只是对服务器传来的数据进行显示而已，并不能改变它。具体场景中：空护短检测到玩家开枪发射子弹 —— 服务端通知子弹的发射方向和模型数据 —— 客户端根据信息创建游戏物体，本地计算子弹接下来的位置 —— 碰撞检测后服务端通知客户端 —— 客户端播放敌人受击效果等视觉效果</p><p>因此，状态同步流量消耗更大，因为他每次都要同步并通知所有的属性，帧同步只需要转发就够</p><h2 id="实时性"><a href="#实时性" class="headerlink" title="实时性"></a>实时性</h2><p>帧同步中因为逻辑一般是客户端执行，这样能更快的转发消息。客户端需要将指令同步后在固定间隔内进行逻辑计算，而不能计算好之后再发送给其他客户端。因为在不知道其他玩家的操作下进行计算会造成结果不一致，比如AB同时攻击了对方，可能在自己客户端视角都认为是对方先死，但是同步计算之后会根据最先攻击时间来计算，确保结果唯一。<strong>但要实现结果唯一就要求所有客户端都有相同的随机种子，也就是客户端随机出同一结果，这也要求指令不能丢失，所以要用TCP等可靠传输协议。</strong></p><p>状态同步其实不是严谨的同步，因为不同客户端的表现不一致在他看来是可以容忍的，只需要每次操作的结果相同即可。因此他对网络延迟的要求并不高，所以广泛用于回合制游戏当中。</p><p>由于不可能保证百分百的实时同步，开发过程中都会用一些技巧来掩饰：</p><ul><li><p>根据游戏的具体情况，加一些前摇动画来掩盖延迟</p></li><li><p>客户端只负责一些模型、动画，它会根据绑定的逻辑对象状态来进行一个插值，这样可以做到逻辑帧率和渲染帧率不一样，但是做了插值平滑和逻辑表现分离，画面不抖了</p></li><li>把远端数据缓存在一个buffer里面，然后按照固定频率从buffer里面取，可以解决客户端卡顿以及网络抖动问题。</li></ul><h2 id="断线重连以及回放系统"><a href="#断线重连以及回放系统" class="headerlink" title="断线重连以及回放系统"></a>断线重连以及回放系统</h2><p>帧同步的回放比状态同步好做得多，因为只需要保存每局所有人的操作就好了。但是实时回放的话（比如死亡回放），客户端需要本地对全场状态进行序列化，才能回到目标时间。播完回放后还需要加速追上实时游戏状态</p><p>而状态同步的回访，需要有一个回放服务器，当一局战斗打响，战斗服务器在给客户端发送消息的同时，还需要把这些消息发给回放服务器，回放服务器做储存，如果有其他客户端请求回放或者观战，则回放服务器把储存起来的消息按时间发给客户端。守望先锋的死亡回放、全场最佳、赛后回放使用了另一个EntityAdmin（ECS的术语）</p><p>但是断线重连则相反，因为帧同步将数据大多放在客户端，重连时倍速播放服务端同步的帧数据来跟上正常进度。状态同步只需要根据服务端记录下的状态信息创建对象并同步就行了</p><h1 id="客户端帧与逻辑帧"><a href="#客户端帧与逻辑帧" class="headerlink" title="客户端帧与逻辑帧"></a>客户端帧与逻辑帧</h1><ul><li>逻辑帧：逻辑帧一般是处理一些跟服务器需要交互的数据，是各个客户端同步的关键数据，如玩家的移动指令，释放技能操作等。逻辑帧的帧率一般推荐1秒10帧，要考虑操作响应及时、数据吞吐能力、网络稳定性等因素。</li><li>客户端帧：客户端帧是依赖于逻辑帧下，表示当前逻辑帧内，依据当前的数据环境中，客户端依据客户端帧去计算逻辑。很多逻辑判断都是在客户端帧中去进行，逻辑帧更多是同步一些操作指令等，是处理数据上传、分发。客户端帧跟逻辑帧是严格对应的，且同样是有序，客户端帧率一般是逻辑帧的整数倍，客户端帧是受逻辑帧驱动的，逻辑帧增加，才会触发客户端的触发，从而推动游戏的逻辑计算。</li></ul><p>如果设定的逻辑帧能满足自己游戏的逻辑运算需求，可以不需要客户端帧</p>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;网络同步&quot;&gt;&lt;a href=&quot;#网络同步&quot; class=&quot;headerlink&quot; title=&quot;网络同步&quot;&gt;&lt;/a&gt;网络同步&lt;/h1&gt;&lt;p&gt;网络同步主要目的在于保证各个端口的游戏表现一致，&lt;strong&gt;网络同步就在于实时的多段数据同步和实时的多端表现。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;而对于大多数游戏，不仅客户端的表现要一致，而且需要客户端和服务端的数据是一致的。所以，同步是一个网络游戏概念，只有网络游戏才需要同步，而单机游戏是不需要同步的。&lt;/p&gt;
&lt;h1 id=&quot;帧同步与状态同步的区别&quot;&gt;&lt;a href=&quot;#帧同步与状态同步的区别&quot; class=&quot;headerlink&quot; title=&quot;帧同步与状态同步的区别&quot;&gt;&lt;/a&gt;帧同步与状态同步的区别&lt;/h1&gt;&lt;h2 id=&quot;概念&quot;&gt;&lt;a href=&quot;#概念&quot; class=&quot;headerlink&quot; title=&quot;概念&quot;&gt;&lt;/a&gt;概念&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;帧同步（Lock Step）&lt;/strong&gt;：同步的是客户端的操作指令。客户端上传操作到服务器，并且服务器并不做过多的处理，然后将当前帧间隔内收集到的操作指令广播给每一个客户端，各个客户端在一致环境下，处理同样的操作输入，则会得到同样的结果。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&quot;/2022/11/09/%E5%B8%A7%E5%90%8C%E6%AD%A5%E5%92%8C%E7%8A%B6%E6%80%81%E5%90%8C%E6%AD%A5/image-20221109171737311.png&quot; alt=&quot;image-20221109171737311&quot;&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;状态同步（State Synchronization）&lt;/strong&gt;：同步的是游戏中的各种状态。一般的流程是客户端上传操作到服务器，服务器收到后计算游戏行为的结果，然后以广播的方式下发游戏中各种状态，客户端收到状态后再根据状态显示内容。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/2022/11/09/%E5%B8%A7%E5%90%8C%E6%AD%A5%E5%92%8C%E7%8A%B6%E6%80%81%E5%90%8C%E6%AD%A5/image-20221109180036949.png&quot; alt=&quot;image-20221109180036949&quot;&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;</summary>
    
    
    
    
    <category term="Unity" scheme="https://ycy666666.github.io/tags/Unity/"/>
    
  </entry>
  
  <entry>
    <title>游戏设计模式杂谈（一）</title>
    <link href="https://ycy666666.github.io/2022/11/07/%E6%B8%B8%E6%88%8F%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E6%9D%82%E8%B0%88%EF%BC%88%E4%B8%80%EF%BC%89/"/>
    <id>https://ycy666666.github.io/2022/11/07/%E6%B8%B8%E6%88%8F%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E6%9D%82%E8%B0%88%EF%BC%88%E4%B8%80%EF%BC%89/</id>
    <published>2022-11-07T08:58:28.000Z</published>
    <updated>2022-11-07T08:59:00.678Z</updated>
    
    <content type="html"><![CDATA[<h1 id="设计模式简介"><a href="#设计模式简介" class="headerlink" title="设计模式简介"></a>设计模式简介</h1><p>设计模式的主要目的就在于解耦，也就是今后处理改动的时候<strong>最小化在编写代码前需要了解的信息</strong></p><p>任何设计模式都需要遵循基本原则，让类与类之间减少耦合</p><h2 id="设计模式的类型"><a href="#设计模式的类型" class="headerlink" title="设计模式的类型"></a>设计模式的类型</h2><p><strong>创建型模式</strong>： 这些设计模式提供了一种在创建对象的同时隐藏创建逻辑的方式，而不是使用 new 运算符直接实例化对象。这使得程序在判断针对某个给定实例需要创建哪些对象时更加灵活。</p><p><strong>结构型模式</strong>： 这些设计模式关注类和对象的组合。继承的概念被用来组合接口和定义组合对象获得新功能的方式。</p><p><strong>行为型模式</strong>：这些设计模式特别关注对象之间的通信。</p><span id="more"></span><h1 id="命令模式"><a href="#命令模式" class="headerlink" title="命令模式"></a>命令模式</h1><p>准确定义：<strong>将一个请求封装为一个对象，从而使你可用不同的请求对客户进行参数化； 对请求排队或记录请求日志，以及支持可撤销的操作。</strong></p><p>这太难理解了，简化后就是： <strong>命令是具现化的方法调用</strong>，就是函数调用被存储在对象之中</p><p><strong>什么时候使用？</strong></p><p>游戏中比较常见一种场景就是实现用户自定义配置按键，要实现这样的话我们就不能在代码中将用户输入和将执行的方法一一对应。</p><p>我们需要将游戏行为作为一个<strong>对象</strong>来传递， 将每个行为都继承同一个基类，这样的话就能通过基类调用函数。我们还能在基类中要求实现行为执行的虚函数的同时实现他对应的撤销方法虚函数，这就是如何支持他可撤销的操作</p><p>我们可以给游戏行为指定游戏对象，比如 <code>execute(GameObject go)</code>这样的话不仅<strong>能够复用代码在玩家或者是NPC上</strong>，还能实现本地双人游戏的按键映射</p><p>这样还有个好处，我们能够在选择命令的AI和执行命令的角色之间解耦，这样我们能够为了不同的行为混合AI或者是对同一角色执行不同AI，这样我们就能分模块编写巡逻AI，不同难度的战斗AI，控制AI等</p><h1 id="享元模式"><a href="#享元模式" class="headerlink" title="享元模式"></a>享元模式</h1><p>享元模式，利用先前创建的已有对象，判断当前所需对象是否能够通过原有对象做一定修改后获得</p><p>比如在游戏中出现了一片森林，需要大量的时间渲染，但是每棵树之间只是位置、颜色、大小等可调节差异。那么我们就可以将共有的数据分离到另一个类中</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">TreeModel</span></span><br><span class="line">&#123;</span><br><span class="line">  Mesh mesh_;</span><br><span class="line">  Texture bark_;</span><br><span class="line">  Texture leaves_;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其余的修改数据放到另一个类中，保留对这个类的引用就行了</p><p><img src="/2022/11/07/%E6%B8%B8%E6%88%8F%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E6%9D%82%E8%B0%88%EF%BC%88%E4%B8%80%EF%BC%89/image-20221106200402976.png" alt="image-20221106200402976"></p><p>同时，我们只用发送后每个模型的独特数据后在告诉GPU，用同一模型渲染每一个实例，这样也能减少Drawcall</p><p>更近一步，我们对于游戏中的地形也能采用这样的模式。所有地形都是一个类的不同实例，只是属性不同而已，比如纹理，能够在上面生成的生物类型等。水域，草地，沙漠一系列地形，我们提前创建好他们的范式实例。</p><p><img src="/2022/11/07/%E6%B8%B8%E6%88%8F%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E6%9D%82%E8%B0%88%EF%BC%88%E4%B8%80%EF%BC%89/image-20221106201556447.png" alt="image-20221106201556447"></p><p>我们需要获取某一区块属性的时候就可以直接从那个区块获得</p><p><code>int id = world.getTile(2, 3).getID();</code></p><p>这样相较于在每个函数中判断地形的枚举值，做许多的分支跳转好得多</p><h1 id="观察者模式"><a href="#观察者模式" class="headerlink" title="观察者模式"></a>观察者模式</h1><p>大概思路就是：让代码宣称某个事件触发了，而不必关心谁接受了这个通知。C#甚至专门设定了event关键词来方便我们开发观察者模式</p><p>比如游戏中成就系统，各种全局的管理系统都和各种各样的模块有交互。当我们不想这些模块了解彼此，那样会写出非常不明所以的代码</p><p>比如MC中有一个成就就是把猪摔死，我们总不能在地面每次检测到有东西落地时判断下落物体是不是猪而且有没有摔死，这样的判断放在物理碰撞的代码之后太诡异了。</p><p>我们可以在落地的时候加一个通知，成就系统注册他自己为观察者就行了，具体的判断交给成就系统自己去做。这样的话我们之后修改了成就的具体要求或者是删除了整个成就系统也不会对物理引擎造成丝毫的影响。此外物体落地时的订阅者还可能包含血量减少，音效播放等，这些代码都不应该出现在物理模块中，而是应该传递给对应的模块去处理</p><p><strong>值得注意的地方：</strong></p><p>我们移除了被观察者的时候如果没有取消观察者的注册，有可能这时候他没有被垃圾回收，这个时候事件仍然会被传递，这个问题在通知系统中被称为：<strong>失效监听者问题</strong></p><h1 id="原型模式"><a href="#原型模式" class="headerlink" title="原型模式"></a>原型模式</h1><p>和之前的享元模式不同，原型模式是一种创建型模式，它是根据某种规则去根据原型创建实例</p><p>所有怪物子类都继承基类，并实现他的clone方法来依据模板生成更多一样的怪物。</p><p>这不仅能复制原型的类还能复制他的状态，不需要硬编码修改独特值，只需要有对应的原型就行了</p><h1 id="单例模式"><a href="#单例模式" class="headerlink" title="单例模式"></a>单例模式</h1><p>单例模式算是日常开发中解决问题最容易想到的设计模式，<strong>他保证一个类只有一个实例，并且提供了访问该实例的全局访问点</strong>，这带来了极大的便利，<strong>但是通常他弊大于利</strong></p><ul><li><strong>他是一个全局变量</strong></li></ul><p>这意味着不同模块的代码会相互耦合，比如我们在击打怪物的时候需要播放音乐，而恰好有个全局可见的音乐模板，我们很难抵制诱惑最终在战斗模块中加入有关音频的代码</p><p>同时他对并行操作很难兼容，我们并不知道其他线程是否正在使用单例，很容易造成死锁以及数据同步问题</p><ul><li><strong>我们不能控制初始化</strong></li></ul><p>单例通常都是需要调用时在初始化他，因为这样就不用考虑生命周期的问题。但是如果初始化需要消耗比较多的时间，这就会影响游戏体验。</p><p><strong>如何不使用单例模式？</strong></p><p>很多游戏中的单例类都是作为管理器这个角色，也就是“XXXManager”。很多时候我们都可以删去这些manager，把他们移到单例管理的类当中，让对象管理好自己</p><p>比如有可能我们拥有 <code>Bullet</code>和 <code>BulletManager</code>， <code>BulletManager</code>中拥有生成子弹，移动子弹等方法，但是呢这些都可以让 <code>Bullet</code>自己实现。设计糟糕的单例会让另一个类反而增加代码</p><p>此外，很多时候我们使用单例就是为了方便地获取所需的对象。但是代价就是我们不想要对象的地方也能轻易的使用。我们需要在完成功能的同时，将对象影响的范围改变的尽量小，于是解决方案就有以下几种：</p><ul><li>我们不让方法自己去获取对象，而是将对象传入方法，这是最简单的方法，但是呢，我们在调用攻击怪物的函数时还要传入一个音频的参数，这并没有改善代码的耦合程度</li><li>从基类中获得，我们可以在武器基类中加入<code>protected</code>音频对象，使得不同的武器子类拥有不同的打击音效，每个派生的实体都能调用自己的播放音频方法</li><li>从已经是全局的东西中获取，我们可以将整个游戏世界作为一个单例，将音频，log类作为这个单例的属性，能访问Game这个单例的类才能访问音频，从而限定了范围</li></ul><h1 id="状态模式"><a href="#状态模式" class="headerlink" title="状态模式"></a>状态模式</h1><p>状态模式简单来说可以认为是FSM——有限状态机</p><p>有限状态机在编写玩家控制逻辑的时候经常使用，根据当前角色的状态：下落过程，在地上等过程对同一操作有不同的反应。</p><p>展开来讲状态机就是：<strong>拥有状态机所有可能状态的集合</strong>，<strong>状态机同时只能在一个状态</strong>，<strong>每个状态都有一系列的转移，每个转移与输入和另一状态相关</strong></p><p>更近一步，如果我们允许玩家能拿起武器，这样的话状态就会翻倍：站立，持械站立等等。这可不符合我们的预期，为了改进我们不能使用大量的switch，而是将每个状态都封装为一个类。这样的话每个状态独有的字段都只出现在对应的状态当中，每次输入或者游戏循环都交给当前状态去执行。</p><p>这样有了个新的问题，我们切换状态的时候需要删除之前的状态，而且不同状态切换到同一状态的效果几乎是差不多的。因此我们可以给所有状态添加一个入口方法，这样避免了重复代码而且不用关心从哪个状态转换而来。</p><p>当然如果遇到更复杂的状态编写，我们可以实现分层状态机，使状态之间可以继承来实现层级。或者是遇到需要记录上一个状态的场景，我们可以使用栈来记录，这样就不用为了追踪之前的状态定义很多相似的类：比如站立开火，跑步开火等</p><p><img src="/2022/11/07/%E6%B8%B8%E6%88%8F%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E6%9D%82%E8%B0%88%EF%BC%88%E4%B8%80%EF%BC%89/image-20221107165309628.png" alt="image-20221107165309628"></p><p>当然由于状态机各种各样的限制，如今的AI已经发展成了行为树，规划系统等领域。</p><p>但是他还有有用的，我们可以在下列场景愉快的使用FSM</p><ul><li>你有个实体，它的行为基于一些内在状态。</li><li>状态可以被严格地分割为相对较少的不相干项目。</li><li>实体响应一系列输入或事件。</li></ul>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;设计模式简介&quot;&gt;&lt;a href=&quot;#设计模式简介&quot; class=&quot;headerlink&quot; title=&quot;设计模式简介&quot;&gt;&lt;/a&gt;设计模式简介&lt;/h1&gt;&lt;p&gt;设计模式的主要目的就在于解耦，也就是今后处理改动的时候&lt;strong&gt;最小化在编写代码前需要了解的信息&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;任何设计模式都需要遵循基本原则，让类与类之间减少耦合&lt;/p&gt;
&lt;h2 id=&quot;设计模式的类型&quot;&gt;&lt;a href=&quot;#设计模式的类型&quot; class=&quot;headerlink&quot; title=&quot;设计模式的类型&quot;&gt;&lt;/a&gt;设计模式的类型&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;创建型模式&lt;/strong&gt;： 这些设计模式提供了一种在创建对象的同时隐藏创建逻辑的方式，而不是使用 new 运算符直接实例化对象。这使得程序在判断针对某个给定实例需要创建哪些对象时更加灵活。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;结构型模式&lt;/strong&gt;： 这些设计模式关注类和对象的组合。继承的概念被用来组合接口和定义组合对象获得新功能的方式。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;行为型模式&lt;/strong&gt;：这些设计模式特别关注对象之间的通信。&lt;/p&gt;</summary>
    
    
    
    
    <category term="其他" scheme="https://ycy666666.github.io/tags/%E5%85%B6%E4%BB%96/"/>
    
  </entry>
  
  <entry>
    <title>ECS框架浅析</title>
    <link href="https://ycy666666.github.io/2022/10/31/ECS%E6%A1%86%E6%9E%B6%E6%B5%85%E6%9E%90/"/>
    <id>https://ycy666666.github.io/2022/10/31/ECS%E6%A1%86%E6%9E%B6%E6%B5%85%E6%9E%90/</id>
    <published>2022-10-31T09:30:58.000Z</published>
    <updated>2022-10-31T09:32:18.798Z</updated>
    
    <content type="html"><![CDATA[<h1 id="关于ECS"><a href="#关于ECS" class="headerlink" title="关于ECS"></a>关于ECS</h1><h2 id="为何需要ECS"><a href="#为何需要ECS" class="headerlink" title="为何需要ECS"></a>为何需要ECS</h2><p>在传统的面向对象设计中（OOP）,进行框架设计首先就要进行类的层次结构，而在这一过程中就会出现多重继承困难、层次结构不易改动的现象。</p><p>而且游戏开发中一种比较常见的现象就是，由于操作和数据没分离，A对B造成了伤害，是A去打了B，还是B受到了A的伤害，函数应该放在哪里？ECS就没有这种疑惑，数据存放在Component类、逻辑计算直接由System负责</p><span id="more"></span><p>这和传统的面向对象或是 Actor 模型是截然不同的。OO 或 Actor 强调的是对象自身处理自身的业务，然后框架去管理对象的集合，负责用消息驱动它们。而在 ECS 中，每个系统关注的是不同的对象集合，它处理的对象中有共性的切片。</p><h2 id="ECS的基本概念"><a href="#ECS的基本概念" class="headerlink" title="ECS的基本概念"></a>ECS的基本概念</h2><h3 id="Component：由数据组成"><a href="#Component：由数据组成" class="headerlink" title="Component：由数据组成"></a>Component：由数据组成</h3><p>Component是数据的集合，只有变量，只有Get，Set相应函数或者是对应的属性，<strong>Component之间不能直接通信</strong></p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> Component&#123;</span><br><span class="line"><span class="comment">//子类将会有大量变量，以供System利用</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在定义一个Component时最好先搞清楚它的数据是System数据还是Entity数据。<strong>如果是System的数据，一般设计成单例Component</strong>。例如存放玩家键盘输入的 Component ，全局只需要一个，很多 System 都需要去读这个唯一的 Component 中的数据。</p><h3 id="Entity：-由多个Component组成"><a href="#Entity：-由多个Component组成" class="headerlink" title="Entity： 由多个Component组成"></a>Entity： 由多个Component组成</h3><p>Entity就可以代表我们的游戏物体，比如一个正方体就包含着Position，Rotation等一系列Component，Unity中的GameObject就是这样的存在</p><p>拥有全局唯一的ID来标识自身</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">Entity</span>&#123;</span><br><span class="line">Int32 ID;</span><br><span class="line">    <span class="comment">//通过观察者模式将自己注册到System可以提升System遍历的速度，因为只需要遍历已经注册的entity</span></span><br><span class="line">List&lt;Component&gt; components;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Entity需要遵循立即创建和延迟销毁原则，销毁放在帧末执行，不然很容易空引用</p><h3 id="System：由纯逻辑组成"><a href="#System：由纯逻辑组成" class="headerlink" title="System：由纯逻辑组成"></a>System：由纯逻辑组成</h3><p>System用来制定游戏的运行规则，只有函数，没有变量。System之间的执行顺序需要严格制定。<strong>System之间不可以直接通信</strong>。</p><p>一个 System只关心某一个固定的Component组合，这个组合集合称为tuple。</p><p><strong>各个System的Update顺序要根据具体情况设置好</strong>，System在Update时都会遍历所有的Entity，如果一个Entity拥有该System的tuple中指定的所有Component实例，则对该Entity进行处理。看到这里你可能会想每次update都遍历Entity，会不会太耗费时间，因此前面我们推荐使用观察者模式来注册</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">System</span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">Update</span>()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title">ASystem</span>:<span class="title">System</span>&#123;</span><br><span class="line">    Tuple tuple;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">override</span> <span class="keyword">void</span> <span class="title">Update</span>()</span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(Entity entity <span class="keyword">in</span> World.entitys)&#123;</span><br><span class="line">            <span class="keyword">if</span>(entity.components中有tuple指定的所有Component实例)&#123;</span><br><span class="line">                <span class="comment">//do something for Components</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="World-整个游戏世界"><a href="#World-整个游戏世界" class="headerlink" title="World:整个游戏世界"></a>World:整个游戏世界</h3><p>游戏通常情况下只会有一个world，但是守望先锋等游戏为了死亡回放等游戏内容创建了两个world（后面还会有很多次提到守望先锋，因为他是最早使用ECS框架的）</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">World</span>&#123;</span><br><span class="line">    List&lt;System&gt; systems;                   <span class="comment">//所有System</span></span><br><span class="line">    dictionary&lt;Int32, Entity&gt; entitys;      <span class="comment">//所有Entity，Int32是Entity.ID</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//由引擎帧循环驱动</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Update</span>()</span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(System sys <span class="keyword">in</span> systems)</span><br><span class="line">            sys.Update();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="ECS的优点"><a href="#ECS的优点" class="headerlink" title="ECS的优点"></a>ECS的优点</h1><h2 id="任意增删"><a href="#任意增删" class="headerlink" title="任意增删"></a>任意增删</h2><p>因为Component之间不可以直接访问，System之间也不可以直接访问，System和Component在设计原则上也不存在耦合。</p><p>对于System来说，Component只是放在一边的数据，Component提供的数据足够就update，数据不够就不update。所以随时增删任意Component和System都不会导致游戏崩溃报错</p><p>比如一个单位中了不能移动的Debuff，那么我们只需要去掉这个单位的Move Component就行了，如果是玩家那么再去掉一个Input Component就可以了</p><h2 id="优化性能"><a href="#优化性能" class="headerlink" title="优化性能"></a>优化性能</h2><p>因为数据都被统一存放到Component中，所以如果能够在内存中以合理的方式将所有Component聚合到连续的内存中，这样可以大幅度提升cpu cache命中率</p><p>Unity，在传统模式下，我们在场景中创建一个Cube，上面会有Transform，MeshRenderer，Collider等组件，而这些组件在内存中的排放都是无序的，这就会降低我们的缓存命中率</p><p>每个内存块我们称之为Chunk，ECS会将符合Chunk对应组合的Entity放在该Chunk当中。一个Chunk中，内存地址是连续的，大小固定为16KB</p><h2 id="避免不必要开销"><a href="#避免不必要开销" class="headerlink" title="避免不必要开销"></a>避免不必要开销</h2><p>守望先锋在GDC中移除不活跃用户时，AFK 处理系统遍历所有同时具备连接组件、输入组件等组件的对象，根据最近输入事件产生的时间强制下线。AI 控制的机器人，由于没有连接组件，就根本不会遍历到，也就不用在其上面浪费计算资源了</p><h1 id="ECS的实际运用"><a href="#ECS的实际运用" class="headerlink" title="ECS的实际运用"></a>ECS的实际运用</h1><h2 id="需要遵循的原则"><a href="#需要遵循的原则" class="headerlink" title="需要遵循的原则"></a>需要遵循的原则</h2><ol><li>设计并不是从Entity开始的，而是应该从System抽象出Component，最后组装到Entity中。</li><li>设计的过程中尽量确保每个System都依赖很多Component去运行，也就是说System和Component并不是一对一的关系，而是一对多的关系。<ul><li>System和Component的划分很难在一开始就确定好，一般都是在实现的过程中看情况一步一步地去划分System和Component。</li></ul></li><li>System<strong>尽量</strong>不改变Component的数据。<ul><li>可以读数据完成的功能就不要写数据来完成。因为写数据会影响到使用了这些数据的模块，如果对于其它模块不熟悉的话，就会产生Bug。如果只是读数据来增加功能的话，即使出Bug也只局限于新功能中，而不会影响其它模块。这样容易管理复杂度，而且给并行处理留下了优化空间</li></ul></li></ol><h2 id="处理一些复杂问题的常见手法"><a href="#处理一些复杂问题的常见手法" class="headerlink" title="处理一些复杂问题的常见手法"></a>处理一些复杂问题的常见手法</h2><h3 id="同类问题的处理方式"><a href="#同类问题的处理方式" class="headerlink" title="同类问题的处理方式"></a>同类问题的处理方式</h3><p>​    许多 System 中很可能会处理同一类问题，涉及的 Component 类型是相同的。<strong>如果这个有共性的问题只涉及一个 Entity ，那么直观的方法是设计一个 System ，迭代，逐个把结果计算出来，存为 Component 的状态</strong>，别的 System 可以在后续把这个结果作为一个状态读出来就可以了。</p><p>​    但如果<strong>这个行为涉及多个 Entity</strong> ，比如在不同的 System 中，都需要查询两个 Entity 的敌对关系。我们不可能用一个 System 计算出所有 Entity 间的敌对关系，这样必然产生了大量不必要的计算；又或者这个行为并不想额外修改 Component 的状态，希望对它保持无副作用，比如我想持续模拟一个对象随时间流逝的位置变化，就不能用一个 System 计算好，再从另一个 System 读出来。</p><p>​    这样，<strong>就引入了 Utility 函数的概念，来做上面这种类型的操作，再把 Utility 函数共享给不同的 System 调用（也就是单例组件）</strong>。为了降低系统复杂度，就要求要么这种函数是无副作用的，随便怎么调用都没问题，比如上面查询敌对关系的例子；要么就限制调用这种函数的地方，仅在很少的地方调用，由调用者小心的保证副作用的影响，比如上面那个持续位置变化的过程。</p><p>​    如果产生状态改变这种副作用的行为必须存在时，又在很多 System 中都会触发，那么为了减少调用的地方，就需要把真正产生副作用的点集中在一处了。这个技巧就是推迟行为的发生时机。就是把行为发生时需要的状态保存起来，放在队列里，由一个单独的 System 在独立的环节集中处理它们。集中在一起推迟到当前帧的末尾或下一帧的开头来做。    </p><h3 id="网络问题"><a href="#网络问题" class="headerlink" title="网络问题"></a>网络问题</h3><p>ECS 要解决的最复杂，最核心的问题，或许还是网络同步。我认为这也是设计一个状态和行为严格分离的框架的主要动机。因为一个好的网络同步系统必须实现预测、有预测就有预测失败的情况，发生后要解决冲突，回滚状态是必须支持的。而状态回滚还包括了只回滚部分状态，而不能简单回滚整个世界。</p><p>​    ECS 框架在这件事上可以做到只去回滚和重算相关的 Component ，一个 System 知道哪些 Entity 才是它真正关心的，该怎么回退它所关心的东西。这样开发的复杂度就减少了。游戏本身是复杂的，但是和网络同步相关的影响到游戏业务的 System 却很少，而且参与的 Component 几乎都是只读的。这样我们就尽可能的把这个复杂的问题和引擎其它部分解耦。</p>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;关于ECS&quot;&gt;&lt;a href=&quot;#关于ECS&quot; class=&quot;headerlink&quot; title=&quot;关于ECS&quot;&gt;&lt;/a&gt;关于ECS&lt;/h1&gt;&lt;h2 id=&quot;为何需要ECS&quot;&gt;&lt;a href=&quot;#为何需要ECS&quot; class=&quot;headerlink&quot; title=&quot;为何需要ECS&quot;&gt;&lt;/a&gt;为何需要ECS&lt;/h2&gt;&lt;p&gt;在传统的面向对象设计中（OOP）,进行框架设计首先就要进行类的层次结构，而在这一过程中就会出现多重继承困难、层次结构不易改动的现象。&lt;/p&gt;
&lt;p&gt;而且游戏开发中一种比较常见的现象就是，由于操作和数据没分离，A对B造成了伤害，是A去打了B，还是B受到了A的伤害，函数应该放在哪里？ECS就没有这种疑惑，数据存放在Component类、逻辑计算直接由System负责&lt;/p&gt;</summary>
    
    
    
    
    <category term="Unity" scheme="https://ycy666666.github.io/tags/Unity/"/>
    
  </entry>
  
  <entry>
    <title>A-Star寻路算法</title>
    <link href="https://ycy666666.github.io/2022/10/12/A-Star%E5%AF%BB%E8%B7%AF%E7%AE%97%E6%B3%95/"/>
    <id>https://ycy666666.github.io/2022/10/12/A-Star%E5%AF%BB%E8%B7%AF%E7%AE%97%E6%B3%95/</id>
    <published>2022-10-12T03:11:44.000Z</published>
    <updated>2022-10-12T03:12:22.923Z</updated>
    
    <content type="html"><![CDATA[<h1 id="各寻路算法之间的比较"><a href="#各寻路算法之间的比较" class="headerlink" title="各寻路算法之间的比较"></a>各寻路算法之间的比较</h1><p>深度优先算法（BFS）在所有方向上平等的探索，是最好写的寻路算法</p><p>Dijkstra算法优先考虑低成本的路径，在游戏中可以规定远离敌人、避开森林需要更高的成本，所以当移动成本发生变化的时候我们使用该算法而不是BFS</p><p>A*寻路是对Dijkstra算法的修改，针对单个目标时进行了优化，Dijkstra的算法可以找到所有位置的路径;A 查找到一个位置的路径，或多个位置中最近的路径。它优先考虑似乎更接近目标的路径。</p><p>下图依次表示他们的搜索区间估计范围</p><p><img src="/2022/10/12/A-Star%E5%AF%BB%E8%B7%AF%E7%AE%97%E6%B3%95/image-20221011155903860.png" alt="image-20221011155903860"></p><span id="more"></span><p>Dijkstra的算法可以很好地找到最短的路径，但它浪费了时间探索那些没有希望的方向。Greedy Best-First在有希望的方向上探索，但它可能不会找到最短的路径。A<em> 算法</em>同时*使用从起点开始的实际距离和到目标的估计距离。</p><p>不同算法情况下不同的搜索范围和最终路线</p><p><img src="/2022/10/12/A-Star%E5%AF%BB%E8%B7%AF%E7%AE%97%E6%B3%95/image-20221011160752165.png" alt="image-20221011160752165"></p><h1 id="A-寻路算法的过程"><a href="#A-寻路算法的过程" class="headerlink" title="A*寻路算法的过程"></a>A*寻路算法的过程</h1><p>对于任意一个格子n，其估价函数如下：</p><blockquote><p>f(n) = g(n) + h(n)</p></blockquote><p><strong>其中 g(n) 指的是从起始格子到格子n的实际代价，而 h(n) 指的是从格子n到终点格子的估计代价。</strong></p><ol><li>我们找到周围格子中f(n)值最小的各格子，在计算他周围格子的f(n)</li><li>一直找出边界格子中的f(n)最小的格子，直到找到与重点相邻的格子。</li></ol><h2 id="A-对启发式方法的使用"><a href="#A-对启发式方法的使用" class="headerlink" title="A*对启发式方法的使用"></a>A*对启发式方法的使用</h2><p>启发式算法，即<strong>优先搜索最有可能产生最佳路径的格子</strong>。</p><p>对于h（n）函数，不同的表示方法会导致最终结果的不同，比如如果采用曼哈顿距离（只能水平和垂直移动）和欧几里得距离（直线距离）</p><p>h(n)的具体影响为： </p><ul><li>在一个极端，如果是0,那么会漫无目的的寻找，A*变成Dijkstra的算法，它保证找到一个最短的路径。</li><li>如果始终低于到目标实际距离，则保证 A<em> 找到最短路径。越低，节点 A</em> 扩展得越多，速度越慢。</li><li>如果 正好等于到目标实际距离，则 A<em> 只会遵循最佳路径，从不扩展其他任何内容，使其非常快。虽然您无法在所有情况下都做到这一点，但在某些特殊情况下可以使其精确。很高兴知道，给定完美的信息，A </em>将表现完美。</li><li>如果大于到目标实际距离，则A *不能保证找到最短的路径，但它可以运行得更快。</li><li>在另一个极端，如果非常高，那么主要取决与h(n)，而A*变成了贪心算法</li></ul><p>使用具体的移动方式匹配地图：</p><ul><li>在允许 4 个方向移动<strong>的</strong>正方形网格上，使用曼哈顿距离 .</li><li>在允许 <strong>8 个方向移动的</strong>方形网格上，使用对角线距离 .</li></ul><h1 id="A-算法的具体实现"><a href="#A-算法的具体实现" class="headerlink" title="A*算法的具体实现"></a>A*算法的具体实现</h1><p>地图中允许8D运动，h（n）采用对角线加直线运动。我们就可以根据水平方向的差值与竖直方向的差值中较小的那个值，计算出对角线，然后再平移。</p><p>横向纵向的格子的单位消耗为10，对角单位消耗为14。</p><p>定义一个<code>OpenList</code>，用于存储和搜索当前最小值的格子。</p><p>定义一个<code>CloseList</code>，用于标记已经处理过的格子，以防止重复搜索。</p><p>将<code>OpenList</code>中f值最小的点作为当前点，加入邻居点到<code>OpenList</code></p><p>对于邻居点执行以下代码伪代码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">如果邻居点在OpenList中</span><br><span class="line">    计算当前值的G与该邻居点的G值</span><br><span class="line">    如果G值比该邻居点的G值小</span><br><span class="line">        将当前点设置为该邻居点的父节点</span><br><span class="line">        更新该邻居点的GF值</span><br><span class="line">若不在</span><br><span class="line">    计算并设置当前点与该邻居点的G值</span><br><span class="line">    计算并设置当前点与该邻居点的H值</span><br><span class="line">    计算并设置该邻居点的F值</span><br><span class="line">    将当前点设置为该邻居点的父节点</span><br></pre></td></tr></table></figure><p>判断终点是否在<code>OpenList</code>中，如果已在<code>OpenList</code>中，则返回该点，其父节点连起来的路径就是A*搜索的路径。如果不在，则重复执行2，3，4，5。直到找到终点，或者<code>OpenList</code>中节点数量为0。</p><h2 id="格子的记录值"><a href="#格子的记录值" class="headerlink" title="格子的记录值"></a>格子的记录值</h2><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Node</span></span><br><span class="line">&#123;</span><br><span class="line">    Int2 m_position;<span class="comment">//下标</span></span><br><span class="line">    <span class="keyword">public</span> Int2 position =&gt; m_position;</span><br><span class="line">    <span class="keyword">public</span> Node parent;<span class="comment">//上一个node</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//角色到该节点的实际距离</span></span><br><span class="line">    <span class="built_in">int</span> m_g;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span> g &#123;</span><br><span class="line">        <span class="keyword">get</span> =&gt; m_g;</span><br><span class="line">        <span class="keyword">set</span> &#123;</span><br><span class="line">            m_g = <span class="keyword">value</span>;</span><br><span class="line">            m_f = m_g + m_h;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//该节点到目的地的估价距离</span></span><br><span class="line">    <span class="built_in">int</span> m_h;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span> h &#123;</span><br><span class="line">        <span class="keyword">get</span> =&gt; m_h;</span><br><span class="line">        <span class="keyword">set</span> &#123;</span><br><span class="line">            m_h = <span class="keyword">value</span>;</span><br><span class="line">            m_f = m_g + m_h;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">int</span> m_f;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span> f =&gt; m_f;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Node</span>(<span class="params">Int2 pos, Node parent, <span class="built_in">int</span> g, <span class="built_in">int</span> h</span>)</span> &#123;</span><br><span class="line">        m_position = pos;</span><br><span class="line">        <span class="keyword">this</span>.parent = parent;</span><br><span class="line">        m_g = g;</span><br><span class="line">        m_h = h;</span><br><span class="line">        m_f = m_g + m_h;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="A-过程"><a href="#A-过程" class="headerlink" title="A*过程"></a>A*过程</h2><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">AStar</span> &#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="built_in">int</span> FACTOR = <span class="number">10</span>;<span class="comment">//水平竖直相邻格子的距离</span></span><br><span class="line">    <span class="keyword">static</span> <span class="built_in">int</span> FACTOR_DIAGONAL = <span class="number">14</span>;<span class="comment">//对角线相邻格子的距离</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">bool</span> m_isInit = <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">bool</span> isInit =&gt; m_isInit;</span><br><span class="line"></span><br><span class="line">    UIGridController[,] m_map;<span class="comment">//地图数据</span></span><br><span class="line">    Int2 m_mapSize;</span><br><span class="line">    Int2 m_player, m_destination;<span class="comment">//起始点和结束点坐标</span></span><br><span class="line">    EvaluationFunctionType m_evaluationFunctionType;<span class="comment">//估价方式</span></span><br><span class="line"></span><br><span class="line">    Dictionary&lt;Int2, Node&gt; m_openDic = <span class="keyword">new</span> Dictionary&lt;Int2, Node&gt;();<span class="comment">//准备处理的网格</span></span><br><span class="line">    Dictionary&lt;Int2, Node&gt; m_closeDic = <span class="keyword">new</span> Dictionary&lt;Int2, Node&gt;();<span class="comment">//完成处理的网格</span></span><br><span class="line"></span><br><span class="line">    Node m_destinationNode;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Init</span>(<span class="params">UIGridController[,] map, Int2 mapSize, Int2 player, Int2 destination, EvaluationFunctionType type = EvaluationFunctionType.Diagonal</span>)</span> &#123;</span><br><span class="line">        m_map = map;</span><br><span class="line">        m_mapSize = mapSize;</span><br><span class="line">        m_player = player;</span><br><span class="line">        m_destination = destination;</span><br><span class="line">        m_evaluationFunctionType = type;</span><br><span class="line"></span><br><span class="line">        m_openDic.Clear();</span><br><span class="line">        m_closeDic.Clear();</span><br><span class="line"></span><br><span class="line">        m_destinationNode = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//将起始点加入open中</span></span><br><span class="line">        AddNodeInOpenQueue(<span class="keyword">new</span> Node(m_player, <span class="literal">null</span>, <span class="number">0</span>, <span class="number">0</span>));</span><br><span class="line">        m_isInit = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//计算寻路</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> IEnumerator <span class="title">Start</span>()</span> &#123;</span><br><span class="line">        <span class="keyword">while</span>(m_openDic.Count &gt; <span class="number">0</span> &amp;&amp; m_destinationNode == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="comment">//按照f的值升序排列</span></span><br><span class="line">            m_openDic = m_openDic.OrderBy(kv =&gt; kv.Value.f).ToDictionary(p =&gt; p.Key, o =&gt; o.Value);</span><br><span class="line">            <span class="comment">//提取排序后的第一个节点</span></span><br><span class="line">            Node node = m_openDic.First().Value;</span><br><span class="line">            <span class="comment">//因为使用的不是Queue，因此要从open中手动删除该节点</span></span><br><span class="line">            m_openDic.Remove(node.position);</span><br><span class="line">            <span class="comment">//处理该节点相邻的节点</span></span><br><span class="line">            OperateNeighborNode(node);</span><br><span class="line">            <span class="comment">//处理完后将该节点加入close中</span></span><br><span class="line">            AddNodeInCloseDic(node);</span><br><span class="line">            <span class="keyword">yield</span> <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(m_destinationNode == <span class="literal">null</span>)</span><br><span class="line">            Debug.LogError(<span class="string">&quot;找不到可用路径&quot;</span>);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            ShowPath(m_destinationNode);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//处理相邻的节点</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">OperateNeighborNode</span>(<span class="params">Node node</span>)</span> &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="built_in">int</span> i = <span class="number">-1</span>; i &lt; <span class="number">2</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="built_in">int</span> j = <span class="number">-1</span>; j &lt; <span class="number">2</span>; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span>(i == <span class="number">0</span> &amp;&amp; j == <span class="number">0</span>)</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                Int2 pos = <span class="keyword">new</span> Int2(node.position.x + i, node.position.y + j);</span><br><span class="line">                <span class="comment">//超出地图范围</span></span><br><span class="line">                <span class="keyword">if</span>(pos.x &lt; <span class="number">0</span> || pos.x &gt;= m_mapSize.x || pos.y &lt; <span class="number">0</span> || pos.y &gt;= m_mapSize.y)</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                <span class="comment">//已经处理过的节点</span></span><br><span class="line">                <span class="keyword">if</span>(m_closeDic.ContainsKey(pos))</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                <span class="comment">//障碍物节点</span></span><br><span class="line">                <span class="keyword">if</span>(m_map[pos.x, pos.y].state == GridState.Obstacle)</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                <span class="comment">//将相邻节点加入open中</span></span><br><span class="line">                <span class="keyword">if</span>(i == <span class="number">0</span> || j == <span class="number">0</span>)</span><br><span class="line">                    AddNeighborNodeInQueue(node, pos, FACTOR);</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    AddNeighborNodeInQueue(node, pos, FACTOR_DIAGONAL);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//将节点加入到open中</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">AddNeighborNodeInQueue</span>(<span class="params">Node parentNode, Int2 position, <span class="built_in">int</span> g</span>)</span> &#123;</span><br><span class="line">        <span class="comment">//当前节点的实际距离g等于上个节点的实际距离加上自己到上个节点的实际距离</span></span><br><span class="line">        <span class="built_in">int</span> nodeG = parentNode.g + g;</span><br><span class="line">        <span class="comment">//如果该位置的节点已经在open中</span></span><br><span class="line">        <span class="keyword">if</span>(m_openDic.ContainsKey(position)) &#123;</span><br><span class="line">            <span class="comment">//比较实际距离g的值，用更小的值替换</span></span><br><span class="line">            <span class="keyword">if</span>(nodeG &lt; m_openDic[position].g) &#123;</span><br><span class="line">                m_openDic[position].g = nodeG;</span><br><span class="line">                m_openDic[position].parent = parentNode;</span><br><span class="line">                ShowOrUpdateAStarHint(m_openDic[position]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//生成新的节点并加入到open中</span></span><br><span class="line">            Node node = <span class="keyword">new</span> Node(position, parentNode, nodeG, GetH(position));</span><br><span class="line">            <span class="comment">//如果周边有一个是终点，那么说明已经找到了。</span></span><br><span class="line">            <span class="keyword">if</span>(position == m_destination)</span><br><span class="line">                m_destinationNode = node;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                AddNodeInOpenQueue(node);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//加入open中，并更新网格状态</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">AddNodeInOpenQueue</span>(<span class="params">Node node</span>)</span> &#123;</span><br><span class="line">        m_openDic[node.position] = node;</span><br><span class="line">        ShowOrUpdateAStarHint(node);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">ShowOrUpdateAStarHint</span>(<span class="params">Node node</span>)</span> &#123;</span><br><span class="line">        m_map[node.position.x, node.position.y].ShowOrUpdateAStarHint(node.g, node.h, node.f,</span><br><span class="line">            node.parent == <span class="literal">null</span> ? Vector2.zero : <span class="keyword">new</span> Vector2(node.parent.position.x - node.position.x, node.parent.position.y - node.position.y));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//加入close中，并更新网格状态</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">AddNodeInCloseDic</span>(<span class="params">Node node</span>)</span> &#123;</span><br><span class="line">        m_closeDic.Add(node.position, node);</span><br><span class="line">        m_map[node.position.x, node.position.y].ChangeInOpenStateToInClose();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//寻路完成，显示路径</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">ShowPath</span>(<span class="params">Node node</span>)</span> &#123;</span><br><span class="line">        <span class="keyword">while</span>(node != <span class="literal">null</span>) &#123;</span><br><span class="line">            m_map[node.position.x, node.position.y].ChangeToPathState();</span><br><span class="line">            node = node.parent;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//获取估价距离</span></span><br><span class="line">    <span class="function"><span class="built_in">int</span> <span class="title">GetH</span>(<span class="params">Int2 position</span>)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(m_evaluationFunctionType == EvaluationFunctionType.Manhattan)</span><br><span class="line">            <span class="keyword">return</span> GetManhattanDistance(position);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(m_evaluationFunctionType == EvaluationFunctionType.Diagonal)</span><br><span class="line">            <span class="keyword">return</span> GetDiagonalDistance(position);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">return</span> Mathf.CeilToInt(GetEuclideanDistance(position));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//获取对角线距离</span></span><br><span class="line">    <span class="function"><span class="built_in">int</span> <span class="title">GetDiagonalDistance</span>(<span class="params">Int2 position</span>)</span> &#123;</span><br><span class="line">        <span class="built_in">int</span> x = Mathf.Abs(m_destination.x - position.x);</span><br><span class="line">        <span class="built_in">int</span> y = Mathf.Abs(m_destination.y - position.y);</span><br><span class="line">        <span class="built_in">int</span> min = Mathf.Min(x, y);</span><br><span class="line">        <span class="keyword">return</span> min * FACTOR_DIAGONAL + Mathf.Abs(x - y) * FACTOR;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//获取曼哈顿距离</span></span><br><span class="line">    <span class="function"><span class="built_in">int</span> <span class="title">GetManhattanDistance</span>(<span class="params">Int2 position</span>)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> Mathf.Abs(m_destination.x - position.x) * FACTOR + Mathf.Abs(m_destination.y - position.y) * FACTOR;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Clear</span>()</span> &#123;</span><br><span class="line">        <span class="keyword">foreach</span>(<span class="keyword">var</span> pos <span class="keyword">in</span> m_openDic.Keys) &#123;</span><br><span class="line">            m_map[pos.x, pos.y].ClearAStarHint();</span><br><span class="line">        &#125;</span><br><span class="line">        m_openDic.Clear();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">foreach</span>(<span class="keyword">var</span> pos <span class="keyword">in</span> m_closeDic.Keys) &#123;</span><br><span class="line">            m_map[pos.x, pos.y].ClearAStarHint();</span><br><span class="line">        &#125;</span><br><span class="line">        m_closeDic.Clear();</span><br><span class="line">        m_destinationNode = <span class="literal">null</span>;</span><br><span class="line">        m_isInit = <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="最终结果"><a href="#最终结果" class="headerlink" title="最终结果"></a>最终结果</h1><h2 id="在unity中呈现效果"><a href="#在unity中呈现效果" class="headerlink" title="在unity中呈现效果"></a>在unity中呈现效果</h2><p>我们在生成的格子中添加显示F,G,H值的文本，在创建一个<code>MapController</code>来管理网格的属性、颜色等，暴露函数给按钮调用</p><p><img src="/2022/10/12/A-Star%E5%AF%BB%E8%B7%AF%E7%AE%97%E6%B3%95/image-20221012104733538.png" alt="image-20221012104733538"></p><p><img src="/2022/10/12/A-Star%E5%AF%BB%E8%B7%AF%E7%AE%97%E6%B3%95/image-20221012110933599.png" alt="image-20221012110933599"></p>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;各寻路算法之间的比较&quot;&gt;&lt;a href=&quot;#各寻路算法之间的比较&quot; class=&quot;headerlink&quot; title=&quot;各寻路算法之间的比较&quot;&gt;&lt;/a&gt;各寻路算法之间的比较&lt;/h1&gt;&lt;p&gt;深度优先算法（BFS）在所有方向上平等的探索，是最好写的寻路算法&lt;/p&gt;
&lt;p&gt;Dijkstra算法优先考虑低成本的路径，在游戏中可以规定远离敌人、避开森林需要更高的成本，所以当移动成本发生变化的时候我们使用该算法而不是BFS&lt;/p&gt;
&lt;p&gt;A*寻路是对Dijkstra算法的修改，针对单个目标时进行了优化，Dijkstra的算法可以找到所有位置的路径;A 查找到一个位置的路径，或多个位置中最近的路径。它优先考虑似乎更接近目标的路径。&lt;/p&gt;
&lt;p&gt;下图依次表示他们的搜索区间估计范围&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/2022/10/12/A-Star%E5%AF%BB%E8%B7%AF%E7%AE%97%E6%B3%95/image-20221011155903860.png&quot; alt=&quot;image-20221011155903860&quot;&gt;&lt;/p&gt;</summary>
    
    
    
    
    <category term="Unity" scheme="https://ycy666666.github.io/tags/Unity/"/>
    
  </entry>
  
  <entry>
    <title>unity任务系统</title>
    <link href="https://ycy666666.github.io/2022/09/25/unity%E4%BB%BB%E5%8A%A1%E7%B3%BB%E7%BB%9F/"/>
    <id>https://ycy666666.github.io/2022/09/25/unity%E4%BB%BB%E5%8A%A1%E7%B3%BB%E7%BB%9F/</id>
    <published>2022-09-25T15:51:37.000Z</published>
    <updated>2022-10-06T09:06:37.228Z</updated>
    
    <content type="html"><![CDATA[<h1 id="读取策划配置表"><a href="#读取策划配置表" class="headerlink" title="读取策划配置表"></a>读取策划配置表</h1><p>一般策划都是通过EXCEL来配置，如下图所示：</p><p><img src="/2022/09/25/unity%E4%BB%BB%E5%8A%A1%E7%B3%BB%E7%BB%9F/image-20220925124533325.png" alt="image-20220925124533325"></p><h2 id="Unity读取EXCEL"><a href="#Unity读取EXCEL" class="headerlink" title="Unity读取EXCEL"></a>Unity读取EXCEL</h2><p>游戏中并不是直接读取<code>Excel</code>配置，实际项目中一般都是将<code>Excel</code>转为<code>xml</code>、<code>json</code>、<code>lua</code>或自定义的文本格式的配置，这样不会让Excel打包时占据额外空间。</p><p>对于 <code>Json</code>格式，在 <code>Excel</code>中能够安装额外的插件，直接导出为 <code>Json</code>格式，当然也可以用 <code>Python</code>批量化处理，这里不赘述</p><span id="more"></span><h2 id="读取json"><a href="#读取json" class="headerlink" title="读取json"></a>读取json</h2><p><strong>我们将json文件都放入Resource文件夹中</strong>。但一般不推荐按这样做，因为Resource文件夹只读，而且打包时会全部进行压缩后打包。建议将资源打成<code>AssetBundle</code>放在<code>StreamingAssets</code>目录或服务器中，方便热更资源</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">string</span> txt = Resources.Load&lt;TextAsset&gt;(<span class="string">&quot;task_cfg&quot;</span>).text;</span><br></pre></td></tr></table></figure><p>引入<code>LitJson</code>能帮助我们更好的配置   地址：<a href="https://hub.fastgit.org/LitJSON/litjson">https://hub.fastgit.org/LitJSON/litjson</a></p><p>使用时引入命名空间： <code>using LitJson;</code></p><h3 id="任务配置读取"><a href="#任务配置读取" class="headerlink" title="任务配置读取"></a>任务配置读取</h3><p><code>LitJson</code>提供了一个<code>JsonMapper.ToObject&lt;T&gt;(jsonString)</code>方法，可以直接将<code>json</code>字符串转为类对象，前提是类的字段名要与<code>json</code>的字段相同</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> 任务配置结构</span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">TaskCfgItem</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span> task_chain_id;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span> task_sub_id;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">string</span> icon;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">string</span> desc;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">string</span> task_target;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span> target_amount;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">string</span> award;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">string</span> open_chain;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">TaskCfg</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// 任务配置，(链id : 子任务id : TaskCfgItem)</span></span><br><span class="line"><span class="keyword">private</span> Dictionary&lt;<span class="built_in">int</span>, Dictionary&lt;<span class="built_in">int</span>, TaskCfgItem&gt;&gt; m_cfg;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 单例模式</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> TaskCfg s_instance;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> TaskCfg instance</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">get</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (s_instance == <span class="literal">null</span>)</span><br><span class="line">                s_instance = <span class="keyword">new</span> TaskCfg();</span><br><span class="line">            <span class="keyword">return</span> s_instance;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 读取配置</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">LoadCfg</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        m_cfg = <span class="keyword">new</span> Dictionary&lt;<span class="built_in">int</span>, Dictionary&lt;<span class="built_in">int</span>, TaskCfgItem&gt;&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">var</span> txt = Resources.Load&lt;TextAsset&gt;(<span class="string">&quot;task_cfg&quot;</span>).text;</span><br><span class="line">        <span class="comment">// 直接转换为类对象</span></span><br><span class="line">        <span class="keyword">var</span> jd = JsonMapper.ToObject&lt;JsonData&gt;(txt);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 根据转换之后的类对象的个数循环</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>, cnt = jd.Count; i &lt; cnt; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 读取每个类对象，将其视作JsonData格式 </span></span><br><span class="line">            <span class="keyword">var</span> itemJd = jd[i] <span class="keyword">as</span> JsonData;</span><br><span class="line">            <span class="comment">// 转换为任务配置对象</span></span><br><span class="line">            TaskCfgItem cfgItem = JsonMapper.ToObject&lt;TaskCfgItem&gt;(itemJd.ToJson());</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 任务配置中字典的相应操作</span></span><br><span class="line">            <span class="keyword">if</span> (!m_cfg.ContainsKey(cfgItem.task_chain_id))</span><br><span class="line">            &#123;</span><br><span class="line">                m_cfg[cfgItem.task_chain_id] = <span class="keyword">new</span> Dictionary&lt;<span class="built_in">int</span>, TaskCfgItem&gt;();</span><br><span class="line">            &#125;</span><br><span class="line">            m_cfg[cfgItem.task_chain_id].Add(cfgItem.task_sub_id, cfgItem);</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 获取任务配置</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> TaskCfgItem <span class="title">GetCfgItem</span>(<span class="params"><span class="built_in">int</span> chainId, <span class="built_in">int</span> taskSubId</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (m_cfg.ContainsKey(chainId) &amp;&amp; m_cfg[chainId].ContainsKey(taskSubId))</span><br><span class="line">            <span class="keyword">return</span> m_cfg[chainId][taskSubId];</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><img src="/2022/09/25/unity%E4%BB%BB%E5%8A%A1%E7%B3%BB%E7%BB%9F/image-20220925151702813.png" alt="image-20220925151702813"></p><h1 id="任务数据的更新"><a href="#任务数据的更新" class="headerlink" title="任务数据的更新"></a>任务数据的更新</h1><p>目前只考虑客户端进行任务数据的管理，与服务端进行交互不在本篇的介绍范围内</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">TaskDataItem</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 链id</span></span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span> task_chain_id;</span><br><span class="line">    <span class="comment">// 任务子id</span></span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span> task_sub_id;</span><br><span class="line">    <span class="comment">// 进度</span></span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span> progress;</span><br><span class="line">    <span class="comment">// 奖励是否被领取了，0：未被领取，1：已被领取</span></span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">short</span> award_is_get;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>打算采用的是<code>PlayerPrefs</code>进行持久化储存，虽说这会污染注册表，当时我们将所有任务的数据编写在一个string中，这样产生的影响就会少很多</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">TaskData</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">TaskData</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        m_taskDatas = <span class="keyword">new</span> List&lt;TaskDataItem&gt;();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> List&lt;TaskDataItem&gt; taskDatas</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">get</span> &#123; <span class="keyword">return</span> m_taskDatas; &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 定义存储数据的容器</span></span><br><span class="line">    <span class="keyword">private</span> List&lt;TaskDataItem&gt; m_taskDatas;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 从数据库读取任务数据</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">GetTaskDataFromDB</span>(<span class="params">Action cb</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 正规是与服务端通信，从数据库中读取，这里纯客户端进行模拟，直接使用PlayerPrefs从客户端本地读取</span></span><br><span class="line">        <span class="keyword">var</span> jsonStr = PlayerPrefs.GetString(<span class="string">&quot;TASK_DATA&quot;</span>);</span><br><span class="line">        <span class="keyword">var</span> taskList = JsonMapper.ToObject&lt; List&lt;TaskDataItem&gt; &gt;(jsonStr);</span><br><span class="line">        <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>, cnt = taskList.Count; i &lt; cnt; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            AddOrUpdateData(taskList[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        cb();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取某个任务数据</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> TaskDataItem <span class="title">GetData</span>(<span class="params"><span class="built_in">int</span> chainId, <span class="built_in">int</span> subId</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>, cnt = m_taskDatas.Count; i &lt; cnt; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">var</span> item = m_taskDatas[i];</span><br><span class="line">            <span class="keyword">if</span> (chainId == item.task_chain_id &amp;&amp; subId == item.task_sub_id)</span><br><span class="line">                <span class="keyword">return</span> item;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 添加或更新任务</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">AddOrUpdateData</span>(<span class="params">TaskDataItem itemData</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">bool</span> isUpdate = <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>, cnt = m_taskDatas.Count; i &lt; cnt; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">var</span> item = m_taskDatas[i];</span><br><span class="line">            <span class="keyword">if</span> (itemData.task_chain_id == item.task_chain_id &amp;&amp; itemData.task_sub_id == item.task_sub_id)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">// 更新数据</span></span><br><span class="line">                m_taskDatas[i] = itemData;</span><br><span class="line">                isUpdate = <span class="literal">true</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(!isUpdate)</span><br><span class="line">            m_taskDatas.Add(itemData);</span><br><span class="line">        <span class="comment">// 排序，确保主线在最前面</span></span><br><span class="line">        m_taskDatas.Sort((a, b) =&gt; </span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> a.task_chain_id.CompareTo(b.task_chain_id);</span><br><span class="line">        &#125;);</span><br><span class="line">        SaveDataToDB();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/2022/09/25/unity%E4%BB%BB%E5%8A%A1%E7%B3%BB%E7%BB%9F/image-20220926153721624.png" alt="image-20220926153721624"></p><h1 id="任务逻辑"><a href="#任务逻辑" class="headerlink" title="任务逻辑"></a>任务逻辑</h1><p>使用<code>Action cb</code>回调是为了模拟实际场景中从服务端数据库读取数据（异步）的过程, 仅在客户端交互的情况可以直接忽略</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">TaskLogic</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">TaskLogic</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        m_taskData = <span class="keyword">new</span> TaskData();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 先把TaskData作为成员变量，并提供一个数据属性taskDatas，方便访问</span></span><br><span class="line">    <span class="keyword">private</span> TaskData m_taskData;</span><br><span class="line">    <span class="keyword">public</span> List&lt;TaskDataItem&gt; taskDatas</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">get</span> &#123; <span class="keyword">return</span> m_taskData.taskDatas; &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 获取任务数据</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">GetTaskData</span>(<span class="params">Action cb</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        m_taskData.GetTaskDataFromDB(cb);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 更新任务进度</span></span><br><span class="line">   <span class="comment">// 使用Action&lt;int, bool&gt;回调是为了模拟实际场景中与服务端通信（异步）</span></span><br><span class="line">    <span class="comment">// 处理结果会有个返回码ErrorCode（回调函数第一个参数），客户端需判断ErrorCode的值来进行处理,一般约定ErrorCode为0表示成功</span></span><br><span class="line">    <span class="comment">// 回调函数第二个参数是是否任务进度已达成，如果任务达成，客户端需要显示领奖按钮</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">AddProgress</span>(<span class="params"><span class="built_in">int</span> chainId, <span class="built_in">int</span> subId, <span class="built_in">int</span> deltaProgress, Action&lt;<span class="built_in">int</span>, <span class="built_in">bool</span>&gt; cb</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">var</span> data = m_taskData.GetData(chainId, subId);</span><br><span class="line">        <span class="keyword">if</span> (<span class="literal">null</span> != data)</span><br><span class="line">        &#123;</span><br><span class="line">            data.progress += deltaProgress;</span><br><span class="line">            m_taskData.AddOrUpdateData(data);</span><br><span class="line">            <span class="keyword">var</span> cfg = TaskCfg.instance.GetCfgItem(data.task_chain_id, data.task_sub_id);</span><br><span class="line">            <span class="keyword">if</span> (cfg != <span class="literal">null</span>)</span><br><span class="line">                cb(<span class="number">0</span>, data.progress &gt;= cfg.target_amount);</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                cb(<span class="number">-1</span>, <span class="literal">false</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            cb(<span class="number">-1</span>, <span class="literal">false</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 领取任务奖励，解锁下一系列任务</span></span><br><span class="line">    <span class="comment">// cb用于与服务端交互，解决错误产生原因</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">GetAward</span>(<span class="params"><span class="built_in">int</span> chainId, <span class="built_in">int</span> subId, Action&lt;<span class="built_in">int</span>, <span class="built_in">string</span>&gt; cb</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">var</span> data = m_taskData.GetData(chainId, subId);</span><br><span class="line">        <span class="keyword">if</span> (data == <span class="literal">null</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            cb(<span class="number">-1</span>, <span class="string">&quot;&#123;&#125;&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (data.award_is_get == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            data.award_is_get = <span class="number">1</span>;</span><br><span class="line">            m_taskData.AddOrUpdateData(data);</span><br><span class="line">            GoNext(chainId, subId);</span><br><span class="line">            <span class="keyword">var</span> cfg = TaskCfg.instance.GetCfgItem(data.task_chain_id, data.task_sub_id);</span><br><span class="line">            cb(<span class="number">0</span>, cfg.award);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            cb(<span class="number">-2</span>, <span class="string">&quot;&#123;&#125;&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 开启下一任务</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">GoNext</span>(<span class="params"><span class="built_in">int</span> chainId, <span class="built_in">int</span> subId</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">var</span> data = m_taskData.GetData(chainId, subId);</span><br><span class="line">        <span class="keyword">var</span> cfg = TaskCfg.instance.GetCfgItem(data.task_chain_id, data.task_sub_id);</span><br><span class="line">        <span class="keyword">var</span> nextCfg = TaskCfg.instance.GetCfgItem(data.task_chain_id, data.task_sub_id + <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (data.award_is_get == <span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 移除掉已领奖的任务</span></span><br><span class="line">            m_taskData.RemoveData(chainId, subId);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 开启下一个任务</span></span><br><span class="line">            <span class="keyword">if</span> (nextCfg != <span class="literal">null</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                TaskDataItem dataItem = <span class="keyword">new</span> TaskDataItem();</span><br><span class="line">                dataItem.task_chain_id = nextCfg.task_chain_id;</span><br><span class="line">                dataItem.task_sub_id = nextCfg.task_sub_id;</span><br><span class="line">                dataItem.progress = <span class="number">0</span>;</span><br><span class="line">                dataItem.award_is_get = <span class="number">0</span>;</span><br><span class="line">                m_taskData.AddOrUpdateData(dataItem);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 开启支线任务</span></span><br><span class="line">            <span class="keyword">if</span> (!<span class="built_in">string</span>.IsNullOrEmpty(cfg.open_chain))</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">// 开启新分支</span></span><br><span class="line">                <span class="keyword">var</span> chains = cfg.open_chain.Split(<span class="string">&#x27;,&#x27;</span>);</span><br><span class="line">                <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>, len = chains.Length; i &lt; len; ++i)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">var</span> task = chains[i].Split(<span class="string">&#x27;|&#x27;</span>);</span><br><span class="line">                    </span><br><span class="line">                    <span class="comment">// 更新子任务状态</span></span><br><span class="line">                    TaskDataItem subChainDataItem = <span class="keyword">new</span> TaskDataItem();</span><br><span class="line">                    subChainDataItem.task_chain_id = <span class="built_in">int</span>.Parse(task[<span class="number">0</span>]);</span><br><span class="line">                    subChainDataItem.task_sub_id = <span class="built_in">int</span>.Parse(task[<span class="number">1</span>]);</span><br><span class="line">                    subChainDataItem.progress = <span class="number">0</span>;</span><br><span class="line">                    subChainDataItem.award_is_get = <span class="number">0</span>;</span><br><span class="line">                    m_taskData.AddOrUpdateData(subChainDataItem);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/2022/09/25/unity%E4%BB%BB%E5%8A%A1%E7%B3%BB%E7%BB%9F/image-20220926153704381.png" alt="image-20220926153704381"></p><h1 id="与UI的互动"><a href="#与UI的互动" class="headerlink" title="与UI的互动"></a>与UI的互动</h1><p>与UI互动的关键是问题是，什么时候更新任务数据的问题，又在什么时候根据更新后的数据刷新UI界面</p><p>如果是任务栏这样的弹出式UI界面，那么在OnEnable中可以添加UI更新任务数据的函数，还有种方式是在任务数据的set属性中添加一个订阅者列表，每次任务更新的时候都刷新</p><p>那UI显示任务进度为例子，我们首先需要根据任务ID获取对应的 <code>TaskDataItem</code>，再根据它的属性获取任务进度就可以了</p>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;读取策划配置表&quot;&gt;&lt;a href=&quot;#读取策划配置表&quot; class=&quot;headerlink&quot; title=&quot;读取策划配置表&quot;&gt;&lt;/a&gt;读取策划配置表&lt;/h1&gt;&lt;p&gt;一般策划都是通过EXCEL来配置，如下图所示：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/2022/09/25/unity%E4%BB%BB%E5%8A%A1%E7%B3%BB%E7%BB%9F/image-20220925124533325.png&quot; alt=&quot;image-20220925124533325&quot;&gt;&lt;/p&gt;
&lt;h2 id=&quot;Unity读取EXCEL&quot;&gt;&lt;a href=&quot;#Unity读取EXCEL&quot; class=&quot;headerlink&quot; title=&quot;Unity读取EXCEL&quot;&gt;&lt;/a&gt;Unity读取EXCEL&lt;/h2&gt;&lt;p&gt;游戏中并不是直接读取&lt;code&gt;Excel&lt;/code&gt;配置，实际项目中一般都是将&lt;code&gt;Excel&lt;/code&gt;转为&lt;code&gt;xml&lt;/code&gt;、&lt;code&gt;json&lt;/code&gt;、&lt;code&gt;lua&lt;/code&gt;或自定义的文本格式的配置，这样不会让Excel打包时占据额外空间。&lt;/p&gt;
&lt;p&gt;对于 &lt;code&gt;Json&lt;/code&gt;格式，在 &lt;code&gt;Excel&lt;/code&gt;中能够安装额外的插件，直接导出为 &lt;code&gt;Json&lt;/code&gt;格式，当然也可以用 &lt;code&gt;Python&lt;/code&gt;批量化处理，这里不赘述&lt;/p&gt;</summary>
    
    
    
    
    <category term="Unity" scheme="https://ycy666666.github.io/tags/Unity/"/>
    
  </entry>
  
  <entry>
    <title>详析二分搜索算法</title>
    <link href="https://ycy666666.github.io/2022/09/23/%E8%AF%A6%E6%9E%90%E4%BA%8C%E5%88%86%E6%90%9C%E7%B4%A2%E7%AE%97%E6%B3%95/"/>
    <id>https://ycy666666.github.io/2022/09/23/%E8%AF%A6%E6%9E%90%E4%BA%8C%E5%88%86%E6%90%9C%E7%B4%A2%E7%AE%97%E6%B3%95/</id>
    <published>2022-09-23T06:26:15.000Z</published>
    <updated>2022-11-21T07:00:25.242Z</updated>
    
    <content type="html"><![CDATA[<h1 id="框架"><a href="#框架" class="headerlink" title="框架"></a>框架</h1><p>二分查找特别容易出现问题，尤其发生在寻找左右边界的情况</p><p>主要注意这几点：</p><ul><li>计算mid的时候使用<code>left + (right - left) / 2</code>防止溢出</li><li>不写else，而是用if把条件说明</li><li>明确自己的搜索区间，跳出while的条件就是搜索区间长度为0</li><li>注意left、right和mid之间的关系，尤其是right的初始值情况</li></ul><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="built_in">int</span> <span class="title">binarySearch</span>(<span class="params"><span class="built_in">int</span>[] nums, <span class="built_in">int</span> target</span>)</span> &#123;</span><br><span class="line">    <span class="built_in">int</span> left = <span class="number">0</span>; </span><br><span class="line">    <span class="built_in">int</span> right = nums.length; <span class="comment">// 注意</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(left &lt; right) &#123;</span><br><span class="line">        <span class="built_in">int</span> mid = left + (right - left) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span>(nums[mid] == target)</span><br><span class="line">            <span class="keyword">return</span> mid; </span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (nums[mid] &lt; target)</span><br><span class="line">            left = mid + <span class="number">1</span>; <span class="comment">// 注意</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (nums[mid] &gt; target)</span><br><span class="line">            right = mid; <span class="comment">// 注意</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><span id="more"></span><h1 id="左边界查找"><a href="#左边界查找" class="headerlink" title="左边界查找"></a>左边界查找</h1><p>查找左边界时找到 target 时不是立即返回，而是缩小「搜索区间」的上界 <code>right</code>，达到锁定左边界的目的</p><p>而因为不是立即返回，如果出现<code>target</code>大于所有数的情况，left最后会等于初始的right退出循环，所以我们return之前要检查</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="built_in">int</span> <span class="title">left_bound</span>(<span class="params"><span class="built_in">int</span>[] nums, <span class="built_in">int</span> target</span>)</span> &#123;</span><br><span class="line">    <span class="built_in">int</span> left = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">int</span> right = nums.Length; <span class="comment">// 注意</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span> (left &lt; right) &#123; <span class="comment">// 注意</span></span><br><span class="line">        <span class="built_in">int</span> mid = left + (right - left) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> (nums[mid] == target) &#123;</span><br><span class="line">            right = mid;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (nums[mid] &lt; target) &#123;</span><br><span class="line">            left = mid + <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (nums[mid] &gt; target) &#123;</span><br><span class="line">            right = mid; <span class="comment">// 注意</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 判断 target 是否存在于 nums 中</span></span><br><span class="line"><span class="comment">// 此时 left 索引越界</span></span><br><span class="line">    <span class="keyword">if</span>(left == nums.Length)<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="comment">// 判断一下 nums[left] 是不是 target</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> nums[left] == target ? left : <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="右边界查找"><a href="#右边界查找" class="headerlink" title="右边界查找"></a>右边界查找</h1><p>只有两处和搜索左侧边界不同</p><p><strong>返回的是<code>left - 1</code>（此时<code>right == left</code>，<code>right - 1</code>也一样）</strong></p><p>一处是right在target小于所有数时会等于left, 而返回的是<code>left - 1</code>，数组越界</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="built_in">int</span> <span class="title">right_bound</span>(<span class="params"><span class="built_in">int</span>[] nums, <span class="built_in">int</span> target</span>)</span> &#123;</span><br><span class="line">    <span class="built_in">int</span> left = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">int</span> right = nums.Length; <span class="comment">// 注意</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span> (left &lt; right) &#123; <span class="comment">// 注意</span></span><br><span class="line">        <span class="built_in">int</span> mid = left + (right - left) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> (nums[mid] == target) &#123;</span><br><span class="line">            left = mid + <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (nums[mid] &lt; target) &#123;</span><br><span class="line">            left = mid + <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (nums[mid] &gt; target) &#123;</span><br><span class="line">            right = mid; <span class="comment">// 注意</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 判断 target 是否存在于 nums 中</span></span><br><span class="line"><span class="comment">// 此时 left - 1 索引越界</span></span><br><span class="line"><span class="keyword">if</span> (left - <span class="number">1</span> &lt; <span class="number">0</span>) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"><span class="comment">// 判断一下 nums[left] 是不是 target</span></span><br><span class="line"><span class="keyword">return</span> nums[left - <span class="number">1</span>] == target ? (left - <span class="number">1</span>) : <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;框架&quot;&gt;&lt;a href=&quot;#框架&quot; class=&quot;headerlink&quot; title=&quot;框架&quot;&gt;&lt;/a&gt;框架&lt;/h1&gt;&lt;p&gt;二分查找特别容易出现问题，尤其发生在寻找左右边界的情况&lt;/p&gt;
&lt;p&gt;主要注意这几点：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;计算mid的时候使用&lt;code&gt;left + (right - left) / 2&lt;/code&gt;防止溢出&lt;/li&gt;
&lt;li&gt;不写else，而是用if把条件说明&lt;/li&gt;
&lt;li&gt;明确自己的搜索区间，跳出while的条件就是搜索区间长度为0&lt;/li&gt;
&lt;li&gt;注意left、right和mid之间的关系，尤其是right的初始值情况&lt;/li&gt;
&lt;/ul&gt;
&lt;figure class=&quot;highlight c#&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;built_in&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;binarySearch&lt;/span&gt;(&lt;span class=&quot;params&quot;&gt;&lt;span class=&quot;built_in&quot;&gt;int&lt;/span&gt;[] nums, &lt;span class=&quot;built_in&quot;&gt;int&lt;/span&gt; target&lt;/span&gt;)&lt;/span&gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;built_in&quot;&gt;int&lt;/span&gt; left = &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;; &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;built_in&quot;&gt;int&lt;/span&gt; right = nums.length; &lt;span class=&quot;comment&quot;&gt;// 注意&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;while&lt;/span&gt;(left &amp;lt; right) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;built_in&quot;&gt;int&lt;/span&gt; mid = left + (right - left) / &lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt;(nums[mid] == target)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; mid; &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (nums[mid] &amp;lt; target)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            left = mid + &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;; &lt;span class=&quot;comment&quot;&gt;// 注意&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (nums[mid] &amp;gt; target)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            right = mid; &lt;span class=&quot;comment&quot;&gt;// 注意&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;number&quot;&gt;-1&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;</summary>
    
    
    
    
    <category term="算法导论" scheme="https://ycy666666.github.io/tags/%E7%AE%97%E6%B3%95%E5%AF%BC%E8%AE%BA/"/>
    
  </entry>
  
  <entry>
    <title>渲染管线概论</title>
    <link href="https://ycy666666.github.io/2022/09/21/%E6%B8%B2%E6%9F%93%E7%AE%A1%E7%BA%BF%E6%A6%82%E8%AE%BA/"/>
    <id>https://ycy666666.github.io/2022/09/21/%E6%B8%B2%E6%9F%93%E7%AE%A1%E7%BA%BF%E6%A6%82%E8%AE%BA/</id>
    <published>2022-09-21T08:08:09.000Z</published>
    <updated>2022-09-21T08:09:01.087Z</updated>
    
    <content type="html"><![CDATA[<h1 id="什么是渲染管线"><a href="#什么是渲染管线" class="headerlink" title="什么是渲染管线"></a>什么是渲染管线</h1><p>渲染管线（渲染流水线）是将三维场景模型转换到屏幕像素空间输出的过程。图形渲染管线主要包括两个功能：一是将物体3D坐标转变为屏幕空间2D坐标，二是为屏幕每个像素点进行着色。</p><h2 id="渲染管线的流程"><a href="#渲染管线的流程" class="headerlink" title="渲染管线的流程"></a>渲染管线的流程</h2><p>渲染管线的一般流程如下图所示。分别是：顶点数据的输入、顶点着色器、曲面细分过程、几何着色器、图元组装、裁剪剔除、光栅化、片段着色器以及混合测试。</p><p><img src="/2022/09/21/%E6%B8%B2%E6%9F%93%E7%AE%A1%E7%BA%BF%E6%A6%82%E8%AE%BA/Image [1].png" alt="Image [1]"></p><p>此外还可以抽象为4个阶段</p><p><img src="/2022/09/21/%E6%B8%B2%E6%9F%93%E7%AE%A1%E7%BA%BF%E6%A6%82%E8%AE%BA/image-20220920175951721.png" alt="image-20220920175951721"></p><span id="more"></span><ol><li><p>应用阶段：由<strong>CPU</strong>主要负责的阶段，且完全由开发人员掌控。CPU将决定递给GPU什么样的数据（目标场景的灯光、模型），有时候还会对这些数据进行处理（将摄像机不可见的元素被<strong>剔除（culling）</strong>出去），并且告诉GPU这些数据的渲染状态（譬如纹理、材质、着色器等）。</p><p><strong>这一阶段最重要的输出是渲染所需的几何信息</strong>，即<strong>渲染图元</strong>（通俗来讲可以是点、线、面等）</p></li><li><p>几何阶段：负责大部分多边形操作和顶点操作，将三维空间的数据转换为二维空间的数据。</p></li><li><p>光栅化阶段：决定每个渲染图元中哪些像素应该被绘制在屏幕上，它需要对上一阶段得到的逐顶点数据进行插值</p></li><li><p>像素处理阶段：给每一个像素正确配色，最后绘制出整幅图像</p></li></ol><p><strong>应用程序阶段在CPU端完成，后面的所有阶段都是在GPU端完成</strong>（所以又称GPU渲染管线）</p><h2 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h2><p>渲染管线的一个特点就是每个阶段都会把前一个阶段的输出作为该阶段的输入。</p><p>例如，片段着色器会将光栅化后的片段(以及片段的数据块)作为输入进行光照计算。除了图元组装和光栅化几个阶段是由硬件自动完成之外，管线的其他阶段管线都是可编程/可配置的。</p><h1 id="各个阶段的功能"><a href="#各个阶段的功能" class="headerlink" title="各个阶段的功能"></a>各个阶段的功能</h1><h2 id="应用阶段"><a href="#应用阶段" class="headerlink" title="应用阶段"></a>应用阶段</h2><p>渲染管线的起点是CPU，CPU与GPU的通信即上文的<strong>应用阶段</strong></p><p><strong>（1）把数据加载到显存</strong>：将数据加载到显存中能使GPU更快的访问这些数据，当把数据加载到显存后，便可以释放了数据，但一些数据仍需留在内存中，如CPU需要网格数据进行碰撞检测。<br><strong>（2）设置渲染状态</strong>：渲染状态的一个通俗解释就是，定义了场景中的网格是怎样被渲染的。例如，使用哪个顶点着色器/片段着色器、光源属性、材质等。如果不设置渲染状态，那所有的网格将使用同一种渲染，显然这是不希望得到的结果。<br><strong>（3）调用Draw Call</strong>：当所有的数据准备好后，CPU就需要调用一个渲染指令告诉GPU，按照上述设置进行渲染，<strong>这个渲染命令就是Draw Call</strong>。Draw Call命令仅仅指向被渲染的图元列表，而不包含任何材质信息</p><p>在实际的渲染中，GPU的渲染速度往往超过了CPU提交命令的速度，这导致<strong>渲染中大部分时间都消耗在了CPU提交Draw Call</strong>上。有一种解决这种问题的方法是使用<strong>批处理（Batching）</strong>，即把要渲染的模型合并在一起提交给GPU</p><p><img src="/2022/09/21/%E6%B8%B2%E6%9F%93%E7%AE%A1%E7%BA%BF%E6%A6%82%E8%AE%BA/v2-385c4e1a6da6e85f0725f1dca9a801cc_720w.jpg" alt="v2-385c4e1a6da6e85f0725f1dca9a801cc_720w"></p><h2 id="GPU渲染管线"><a href="#GPU渲染管线" class="headerlink" title="GPU渲染管线"></a>GPU渲染管线</h2><p><img src="/2022/09/21/%E6%B8%B2%E6%9F%93%E7%AE%A1%E7%BA%BF%E6%A6%82%E8%AE%BA/v2-579bdb7ac479bbbcf52358ca67725bd6_1440w-16636687571604.jpg" alt="v2-579bdb7ac479bbbcf52358ca67725bd6_1440w"></p><p>绿色表示开发者可以完全编程控制的部分，<strong>虚线外框</strong>表示此阶段不是必需的，<strong>黄色</strong>表示开发者无法完全控制的部分（但可以进行一些配置），<strong>紫色</strong>表示开发者无法控制的阶段（已经由GPU固定实现）</p><h2 id="几何阶段"><a href="#几何阶段" class="headerlink" title="几何阶段"></a>几何阶段</h2><h3 id="顶点着色器"><a href="#顶点着色器" class="headerlink" title="顶点着色器"></a>顶点着色器</h3><p>顶点着色器的处理单位是顶点，但是每次处理都是独立的，因此无法创建或销毁任何一个顶点，也不能得到与其他顶点的关系</p><p>顶点着色器主要功能是进行坐标变换。将输入的局部坐标变换到世界坐标、观察坐标和裁剪坐标。</p><p>虽然我们也会在顶点着色器进行光照计算(称作<strong>高洛德着色)</strong>，然后经过光栅化插值得到各个片段的颜色，但这种得到的光照比较不自然，所以一般在片段着色器进行光照计算</p><h3 id="曲面细分着色器"><a href="#曲面细分着色器" class="headerlink" title="曲面细分着色器"></a>曲面细分着色器</h3><p>曲面细分是利用镶嵌化处理技术对三角面进行细分，以此来增加物体表面的三角面的数量，是渲染管线一个可选的阶段</p><h3 id="几何着色器"><a href="#几何着色器" class="headerlink" title="几何着色器"></a>几何着色器</h3><p>在这个阶段，开发者可以控制GPU对顶点进行增删改操作</p><h3 id="投影"><a href="#投影" class="headerlink" title="投影"></a>投影</h3><p>GPU将顶点从摄像机观察空间转换到裁剪空间（又被称为齐次裁剪空间），为之后的剔除过程以及投射到二维平面做准备。</p><p>常见的投影方式有透视投影与正交投影。</p><p>在三维中原有的三个分量x、y、z上又额外增加了w=1分量，使得可以通过矩阵乘的方式为三维坐标实现平移的效果。</p><h3 id="裁剪"><a href="#裁剪" class="headerlink" title="裁剪"></a>裁剪</h3><p>只有当图元部分或全部位于视椎体内时，我们才会将它送到流水线的下个阶段，也就是光栅化阶段。对于部分位于视椎体的图元，位于外部的顶点将被裁剪掉，而且在视椎体与线段的交界处产生新的顶点。</p><p>在把不需要的顶点裁剪掉后，GPU需要把顶点映射到屏幕空间，这是一个从三维空间转换到二维空间的操作。</p><ul><li><p>对于透视裁剪空间，GPU需要对裁剪空间中的顶点执行齐次除法（将齐次坐标系中的w分量除x、y、z分量），得到顶点的<strong>归一化的设备坐标（NDC）</strong></p><p>通过透视除法后，我们得到了NDC坐标，获得NDC坐标是为了实现屏幕坐标的转换与硬件无关。</p></li><li><p>正交裁剪空间只需要把w分量去掉即可。</p></li></ul><p>此时顶点的x、y坐标接近于在屏幕上所处的位置了，此时z分量不会被丢弃而是被写入了<strong>深度缓冲（z-buffer）</strong></p><h3 id="屏幕映射"><a href="#屏幕映射" class="headerlink" title="屏幕映射"></a>屏幕映射</h3><p>屏幕映射的任务就是将每个图元的x、y值变换到<strong>屏幕坐标系</strong>，对于z坐标不做任何处理（实际上屏幕坐标系和z坐标一起构成<strong>窗口坐标系</strong>），这些值会被一起传递到光栅化阶段</p><blockquote><p>一般来说，屏幕坐标是2D的概念，只用于表示屏幕XY坐标，而窗口坐标是2.5D的概念，它还带有深度信息，也就是经过变换后的Z轴的信息。</p></blockquote><p>使用齐次坐标的意义，其实就是为了正确记录下投影变换前(观察空间)中物体的深度信息，也就是Z坐标的值。</p><h2 id="光栅化阶段"><a href="#光栅化阶段" class="headerlink" title="光栅化阶段"></a>光栅化阶段</h2><p>光栅化会确定图元所覆盖的片段，利用顶点属性插值得到片段的属性信息，然后送到片段着色器进行颜色计算，我们这里需要注意到片段是像素的候选者，只有通过后续的测试，片段才会成为最终显示的像素点。</p><h3 id="三角形设置（Triangle-Setup）"><a href="#三角形设置（Triangle-Setup）" class="headerlink" title="三角形设置（Triangle Setup）"></a><strong>三角形设置（Triangle Setup）</strong></h3><p>这个过程做的工作就是把顶点数据收集并组装为简单的基本体（线、点或三角形）</p><h3 id="三角形遍历（Triangle-Traversal）"><a href="#三角形遍历（Triangle-Traversal）" class="headerlink" title="三角形遍历（Triangle Traversal）"></a>三角形遍历（Triangle Traversal）</h3><p>这个过程将检验屏幕上的某个像素是否被一个三角形网格所覆盖，被覆盖的区域将生成一个<strong>片元</strong>（Fragment）</p><blockquote><p>片元不是真正意义上的像素，而是包含了很多种状态的集合（譬如屏幕坐标、深度、法线、纹理等）</p></blockquote><p>而片元的划分依据（像素块被覆盖到何种程度才被划分）不管怎么样都会产生锯齿，这就有许多抗锯齿的采样方式（比如MSAA）</p><h3 id="片段着色器"><a href="#片段着色器" class="headerlink" title="片段着色器"></a>片段着色器</h3><p>片元着色器的输入是上一个阶段对顶点信息进行插值的结果（是根据从顶点着色器输出的数据插值得到的），而它的输出是像素颜色值</p><p>这个阶段我们能进行很多渲染技术，比如根据顶点法线或者UV计算颜色，接受阴影或者是进行纹理采样（纹理坐标是通过前述阶段的顶点数据插值得到的）</p><h3 id="逐片元计算"><a href="#逐片元计算" class="headerlink" title="逐片元计算"></a>逐片元计算</h3><p>对每个片元进行操作，将它们的颜色以某种形式合并，得到最终在屏幕上像素显示的颜色。主要的工作有两个：对片元进行<strong>测试（Test）</strong>并进行<strong>合并（Merge）</strong>。</p><ol><li>测试步骤决定了片元最终会不会被显示出来，这个阶段是高度可配置的</li><li>如果一个片元通过了所有测试，就需要把这些片元的颜色值和颜色缓冲中已有的颜色值进行混合。</li></ol><h4 id="裁切测试"><a href="#裁切测试" class="headerlink" title="裁切测试"></a>裁切测试</h4><p>在裁剪测试中，允许程序员开设一个裁剪框，只有在裁剪框内的片元才会被显示出来，在裁剪框外的片元皆被剔除。</p><h4 id="模板测试"><a href="#模板测试" class="headerlink" title="模板测试"></a>模板测试</h4><p>模板测试通常用来限制渲染的区域，渲染阴影，轮廓渲染等</p><p>在模板测试中，GPU将读取片元的模板值与模板缓冲区的模板值进行比较，比较函数由开发者指定，如果比较不通过，这个片元将被舍弃</p><p><img src="/2022/09/21/%E6%B8%B2%E6%9F%93%E7%AE%A1%E7%BA%BF%E6%A6%82%E8%AE%BA/Image [81].png" alt="Image [81]"></p><h4 id="深度测试"><a href="#深度测试" class="headerlink" title="深度测试"></a>深度测试</h4><p>现实生活中，近的物体会遮挡住远处的物体，深度缓冲就是用来实现这种效果的。</p><p>GPU将读取片元的深度值（就是我们前面留下来的坐标z分量）与缓冲区的深度值进行比较，和模板测试一样，如何渲染物体之间的遮挡关系也是自定义的（可以让GPU把没有被遮挡的部分隐藏了，让被遮挡的部分显示出来的。）</p><blockquote><p>大量的被遮挡片元直到深度测试阶段才会被剔除，而在此之前它们同样地被计算，这占用了GPU大量的资源。</p><p>因此有种优化技术是将<strong>深度测试提前（Early-Z）</strong>。但这带来了与透明度测试的冲突，例如某个片元甲虽然遮挡了另一个片元乙，但甲却是透明的，GPU应当渲染的是片元乙，这就产生了矛盾，这就是透明度测试会导致性能下降的原因</p></blockquote><h4 id="合并"><a href="#合并" class="headerlink" title="合并"></a>合并</h4><p>一个片元通过了所有测试，片元颜色就会被送到颜色缓冲区，到达了合并环节</p><p>合并有两种主要的方式，一种是直接进行颜色的替换，另一种是根据不透明度进行<strong>混合（Blend）</strong></p><p>如果开启了混合，GPU会取出片元着色器得到的颜色（<strong>源颜色</strong>）和颜色缓冲区存在的颜色（<strong>目标颜色</strong>），之后按照设定的函数进行混合，可以设定透明度通道进行相加，相减还是相乘。</p><p>最后GPU会使用<strong>双重缓冲（Double Buffering）</strong>的策略，即屏幕上显示<strong>前置缓冲（Front Buffer）</strong>，而渲染好的颜色先被送入<strong>后置缓冲（Back Buffer）</strong>，再替换前置缓冲，以此避免在屏幕上显示正在光栅化的图元</p><h1 id="渲染管线中的坐标系变换"><a href="#渲染管线中的坐标系变换" class="headerlink" title="渲染管线中的坐标系变换"></a>渲染管线中的坐标系变换</h1><p><img src="/2022/09/21/%E6%B8%B2%E6%9F%93%E7%AE%A1%E7%BA%BF%E6%A6%82%E8%AE%BA/Image [11].png" alt="Image [11]"></p><ul><li>我们从建模工具得到的是物体的局部坐标(Local Coordinate)，</li><li>局部坐标通过模型矩阵Model变换到世界坐标(World Coordinate)，</li></ul><p>​        光照计算一般都是在世界空间进行的，所以输入的顶点坐标需要通过乘以模型矩阵变换到世界空间。在模型变换时，通常还需要将法线变换到世界空间中，对于法线变换不能简单的使用模型变换矩阵来变换法线，对于包含非均匀缩放的变换，需要求解模型变换的<strong>逆转置矩阵</strong></p><ul><li><p>世界坐标通过观察矩阵View变换到观察坐标(View Coordinate)，</p><p>虚拟摄像机定义了我们的观察空间。虚拟摄像机的位置是坐标的原点，观察方向沿着Z轴的负方向。我们可以通过摄像机的位置(EyePosition)、观察目标点(FocusPosition)和向上的方向向量(UpDirection)来构建观察矩阵。</p><p><img src="/2022/09/21/%E6%B8%B2%E6%9F%93%E7%AE%A1%E7%BA%BF%E6%A6%82%E8%AE%BA/Image [13].png" alt="Image [13]"></p></li><li><p>观察坐标经过投影矩阵Projection变换到裁剪坐标(Clip Coordinate)，</p><p>​    裁剪空间的目标是能够方便的对图元进行裁剪，这块空间是由视锥体决定的，视锥体外为看不到的区域，也就是被裁剪的部分。当时不同的视锥体有不同的处理过程，而且透视投影判断点是否在视锥体内比较麻烦，通过一个投影矩阵将顶点转换到裁剪空间中是一种通用、方便的方式。——常见的投影矩阵有透视投影和正交投影</p><p>​    投影矩阵并没有真正的进行投影工作，而是为投影做准备，真正的投影发生在<strong>齐次除法</strong>过程中，这发生在<strong>屏幕空间</strong>映射阶段</p></li><li><p>裁剪坐标经过透射除法(Perspective Division)得到标准设备空间(Normalized Device Coordinates，NDC)，</p></li><li><p>NDC坐标通过视口变换(Viewport Transformation)变换到窗口坐标进行显示</p></li></ul>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;什么是渲染管线&quot;&gt;&lt;a href=&quot;#什么是渲染管线&quot; class=&quot;headerlink&quot; title=&quot;什么是渲染管线&quot;&gt;&lt;/a&gt;什么是渲染管线&lt;/h1&gt;&lt;p&gt;渲染管线（渲染流水线）是将三维场景模型转换到屏幕像素空间输出的过程。图形渲染管线主要包括两个功能：一是将物体3D坐标转变为屏幕空间2D坐标，二是为屏幕每个像素点进行着色。&lt;/p&gt;
&lt;h2 id=&quot;渲染管线的流程&quot;&gt;&lt;a href=&quot;#渲染管线的流程&quot; class=&quot;headerlink&quot; title=&quot;渲染管线的流程&quot;&gt;&lt;/a&gt;渲染管线的流程&lt;/h2&gt;&lt;p&gt;渲染管线的一般流程如下图所示。分别是：顶点数据的输入、顶点着色器、曲面细分过程、几何着色器、图元组装、裁剪剔除、光栅化、片段着色器以及混合测试。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/2022/09/21/%E6%B8%B2%E6%9F%93%E7%AE%A1%E7%BA%BF%E6%A6%82%E8%AE%BA/Image [1].png&quot; alt=&quot;Image [1]&quot;&gt;&lt;/p&gt;
&lt;p&gt;此外还可以抽象为4个阶段&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/2022/09/21/%E6%B8%B2%E6%9F%93%E7%AE%A1%E7%BA%BF%E6%A6%82%E8%AE%BA/image-20220920175951721.png&quot; alt=&quot;image-20220920175951721&quot;&gt;&lt;/p&gt;</summary>
    
    
    
    
    <category term="图形学" scheme="https://ycy666666.github.io/tags/%E5%9B%BE%E5%BD%A2%E5%AD%A6/"/>
    
  </entry>
  
</feed>
