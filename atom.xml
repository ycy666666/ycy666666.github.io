<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>WEBSITE</title>
  
  
  <link href="https://ycy666666.github.io/atom.xml" rel="self"/>
  
  <link href="https://ycy666666.github.io/"/>
  <updated>2023-11-21T12:24:48.479Z</updated>
  <id>https://ycy666666.github.io/</id>
  
  <author>
    <name>YCY</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>ARM指令集体系结构</title>
    <link href="https://ycy666666.github.io/2023/11/21/ARM%E6%8C%87%E4%BB%A4%E9%9B%86%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/"/>
    <id>https://ycy666666.github.io/2023/11/21/ARM%E6%8C%87%E4%BB%A4%E9%9B%86%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/</id>
    <published>2023-11-21T12:24:22.000Z</published>
    <updated>2023-11-21T12:24:48.479Z</updated>
    
    <content type="html"><![CDATA[<h1 id="相关概念"><a href="#相关概念" class="headerlink" title="相关概念"></a>相关概念</h1><h2 id="架构"><a href="#架构" class="headerlink" title="架构"></a>架构</h2><p><strong>CPU架构</strong>是CPU厂商给属于同一系列的CPU产品定的一个规范，主要目的是为了区分不同类型CPU的重要标示。目&#96;前市面上的CPU分类主要分有两大阵营，一个是intel、AMD为首的复杂指令集CPU（X86架构），另一个是以IBM、ARM为首的精简指令集CPU(ARM架构)。</p><blockquote><p>你想造一个房子，在具体的细节实现之前，你必须思考，我到底要造高楼、平房、独栋别墅………然后我确定我要造平房，什么样的平房？我要造三室一厅的平房，这就是一种基于平房架构的内核，我要造四室一厅的平房，这就是基于平房架构的另外一种内核。</p></blockquote><p><strong>两种架构之前的核心区别是x86是复杂指令集（CISC），ARM是精简指令集（RISC）</strong>，指令集是指处理器能够识别并执行的指令集合。</p><ul><li><p>精简指令集：每条指令功能简单，单条指令耗电低，但功能较少对于开发者实现一个功能需要自己想办法实现。</p></li><li><p>复杂指令集：一个指令就相当于一个事件</p></li></ul><span id="more"></span><p>如果一条指令能够从存储器中读出源操作数然后完成某个操作后，将结果保存到存储器中，将其称作<strong>存储器-存储器型</strong>。</p><ul><li>X86架构是<strong>寄存器-存储器型</strong>，能过处理两个数据，一个在存储器，另一个在寄存器中，结果写回到存储器或者寄存器。</li><li>ARM架构只能对寄存器中的内容进行操作，这类计算机只能通过<strong>LOAD指令</strong>将数据读入寄存器并用<strong>STORE指令</strong>将寄存器送回到存储器中，因此也被称作load&#x2F;store型</li></ul><p><strong>ARM架构</strong>和<strong>ARM指令集</strong>经常放在一起说。经常说成<strong>ARM指令集架构</strong>，实际上并不完全相等。</p><p>ARM架构包含了指令集、寄存器集、存异常模型、内存模型等内容。</p><h2 id="内核"><a href="#内核" class="headerlink" title="内核"></a>内核</h2><p>而一个架构可以衍生出多种内核，别的公司可以向ARM公司购买架构使用权，ARM给你架构，你自己去设计内核，这就是<strong>自研内核</strong>；ARM公司自己针对自己架构设计的内核又称作<strong>公版内核</strong>。</p><h1 id="体系结构和组成"><a href="#体系结构和组成" class="headerlink" title="体系结构和组成"></a>体系结构和组成</h1><p>ARM这类处理器采用了<code>存储程序</code>结构， 将程序和数据放在同一个存储空间里面，采用 <strong>取指-执行模式</strong>，也就是按照顺序读取指令、译码、执行。</p><p>正如前面所说，ARM只能操作寄存器中的内容（寄存器是位于CPU中的存储单元，主要功能为高速缓存、循环计数、记录下一条指令地址-程序计数器PC），一般指令格式油以下三种：</p><ol><li>LDR&#x2F;LOAD 寄存器目的，存储单元源</li><li>STR&#x2F;STORE 寄存器源，存储单元目的</li><li>Operation 寄存器目的，寄存器源1，寄存器源2  —— ADD r1,r2,r3 将寄存器r2,r3相加，把和写入寄存器r1</li></ol><p>存储程序计算机部分结构图：</p><p>MAR: 保存了读写操作中正在访问的存储单元地址</p><p>MBR：保存了从存储器中读取的数据或即将写入存储器的数据</p><p>IR：存放最近从存储器中读出的指令，即当前指令</p><p>总线： 用于寄存器之间和寄存器与ALU（算术逻辑单元）传输信息</p><p>CU：解释执行IR中的指令</p><p><img src="/2023/11/21/ARM%E6%8C%87%E4%BB%A4%E9%9B%86%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/image-20231109224125081.png" alt="image-20231109224125081"></p><p>符号←表示数据传送方向，而[]代表寄存器或者存储单元的内容</p><p><img src="/2023/11/21/ARM%E6%8C%87%E4%BB%A4%E9%9B%86%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/image-20231109225041694.png" alt="image-20231109225041694"></p><p>4个RTL操作构成了处理周期的 <strong>取指</strong>阶段，该阶段从存储器中读取指令，PC+4，为读取下一条指令做好准备。 第二组的三个操作标记为LDR， 构成了<strong>执行</strong>阶段。</p><p>所有指令都是相同的<strong>取指</strong>阶段开始，<strong>执行</strong>阶段却由指令寄存器IR中的指令字决定</p><h2 id="流控制"><a href="#流控制" class="headerlink" title="流控制"></a>流控制</h2><p>流控制通常是指转移到程序中特定位置的分支或跳转指令，子程序&#x2F;过程调用，返回，中断等。</p><p>在汇编中，计算机根据测试结果决定将那个地址加载到程序计数器PC中， 存储器也会从候选指令中读出一个，将其加载到指令寄存器IR中</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">SUBS r5,r5,#1;r5-1， </span><br><span class="line">BEQ onZero; if r5 == 0 then 跳转到‘onZero’</span><br><span class="line">notZero ADD r1,r2,r3;else继续执行</span><br><span class="line">onZero SUB r1,r2,r3; 转移目的地</span><br></pre></td></tr></table></figure><p><strong>操作码后面加S表示更新CCR状态标志</strong></p><p>下图是机器级条件行为的实现：</p><p><img src="/2023/11/21/ARM%E6%8C%87%E4%BB%A4%E9%9B%86%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/image-20231110115125773.png" alt="image-20231110115125773"></p><p>和之前一个明显的区别是<strong>ALU能够通过控制单元CU与PC连接在一起</strong>， 相当于指令寄存器中的地址字段与PC之间的<strong>地址总线</strong>允许一个<strong>非顺序</strong>地址加载到PC中。首先ALU的信息被接入条件码寄存器（CCR）， 那里保存了用于测试的条件（正，负，零）， ALU执行一个操作时，会根据是否为0（Z）， 是否算术溢出（V）， 是否为负（N），是否产生进位（C）更新CRR中的零位，溢出位，负位以及借位位。</p><p>之后控制单元CU负责指令译码，他会从CCR中选择所需的条件位来进行测试，如果为true则跳转到<code>分支目标地址</code>（BTA），否则正常执行下一条指令（PC+4）； </p><h2 id="ISA的组成"><a href="#ISA的组成" class="headerlink" title="ISA的组成"></a>ISA的组成</h2><blockquote><p>指令集架构（英语：Instruction Set Architecture，缩写为ISA），又称指令集或指令集体系，是计算机体系结构中与程序设计有关的部分，<strong>包含了基本数据类型，指令集，寄存器</strong>，寻址模式，存储体系，中断，异常处理以及外部I&#x2F;O</p></blockquote><p>ARM是一个32位的计算机，采用寄存器-寄存器体系结构，使用load&#x2F;store在存储器与寄存器之间移动数据。所有操作数都是32位宽的，除了几个乘法指令会产生64位结果并保存在两个32位寄存器中。</p><p>ARM有16个可见寄存器，前十二个位通用寄存器，r13为栈指针，r14为连接寄存器，r15为程序计数器。因为<strong>操作码位数+操作数位数&#x3D;计算机字长</strong>，因此ARM的指令集较为丰富</p><h1 id="ARM指令集"><a href="#ARM指令集" class="headerlink" title="ARM指令集"></a>ARM指令集</h1><h2 id="程序结构"><a href="#程序结构" class="headerlink" title="程序结构"></a>程序结构</h2><p>下述代码计算1~10的整数立方和</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">AREA ARMtest, CODE, READONLY --伪指令AREA定义了代码段，该段名字为ARMtest，属性为CODE和READONLY</span><br><span class="line">ENTRY ——伪指令ENTRY告诉汇编器在哪里找到要执行的第一条指令</span><br><span class="line"></span><br><span class="line">MOV r0,#0;</span><br><span class="line">MOV r1 #10;</span><br><span class="line">Next MUL r2,r1,r1;计算平方</span><br><span class="line">MLA r0,r2,r2,r0;计算立方并累加</span><br><span class="line">SUBS r1,r1,#1;</span><br><span class="line">BNE Next;计数值不为0时跳转</span><br><span class="line">END; 伪指令END 告诉汇编器已经到达末尾</span><br></pre></td></tr></table></figure><h2 id="伪指令"><a href="#伪指令" class="headerlink" title="伪指令"></a>伪指令</h2><p>伪指令不是ISA的一部分，而是汇编器会根据这个生成合适的代码。</p><p>ADR是ARM最有用的伪指令之一，它能够将地址加载到目的寄存器中。假如想要把32位数0x1234567加载到寄存器r0中，不能使用MOV，因为这是一个32位常量。而ADR会利用ADD或者SUB指令以及PC相对寻址方式产生需要的地址， 这些都是由汇编器生成实际的机器代码，而不用程序员去实现</p><p>EQU能够将一个名字与一个值绑定，而DCD能够在程序运行前常量和变量预留存储空间。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Value1 EQU 12;将Value1与12关联</span><br><span class="line">Value2 EQU 45;</span><br><span class="line">Table DCD Value1;将字12保存在存储器中，DCD为32位。</span><br><span class="line">  DCD Value2;</span><br></pre></td></tr></table></figure><p>此外DCB为一个字节&#x2F;8位， DCW为16位</p><h2 id="数据处理指令"><a href="#数据处理指令" class="headerlink" title="数据处理指令"></a>数据处理指令</h2><h3 id="算术指令"><a href="#算术指令" class="headerlink" title="算术指令"></a>算术指令</h3><p>加减法分别为ADD和SUB，值得一提的是在32位体系结构中如何实现64位整数的加法。</p><p>首先两个64位数保存在r1,r0和r3,r2中。使用**<code>ADDS r4, r0,r2</code>**, 来保存结果到r4并强制更新CCR。然后使用 **<code>ADC r5,r1,r3</code>**来执行带进位的加法.</p><p>ARM乘法指令MUL只会保存结果的低32位，而且目的寄存器Rd和源寄存器Rm不能使用同一个寄存器，因为ARM会将Rd当作临时寄存器</p><p>ARM未实现除法</p><h3 id="位运算"><a href="#位运算" class="headerlink" title="位运算"></a>位运算</h3><p>ARM支持AND,OR,NOT和EOR操作，如果想要取反的话，需要使用第二操作数或者使用 <em>取反传送</em>指令MVN来实现</p><p>位运算典型引用就是数据合并，比如两个寄存器分别存储了不同位的有效数据，就可以进行合并</p><h4 id="移位"><a href="#移位" class="headerlink" title="移位"></a>移位</h4><p>所有微处理器都能支持移位操作，如果移位的位数被编码为常量，那么就是<strong>静态移位，因为运行时不能改变移位位数</strong>；如果移位位数由寄存器的值决定，那么就叫做<strong>动态移位</strong></p><p>移位操作有三种类型：逻辑移位，算数移位，循环移位</p><p><img src="/2023/11/21/ARM%E6%8C%87%E4%BB%A4%E9%9B%86%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/image-20231111115607956.png" alt="image-20231111115607956"></p><p>而ARM处理器没有独立的移位指令，而是对 <strong>寄存器-寄存器</strong>的<strong>第二个源操作数</strong>进行移位。<code>ADD r0,r1,r2,LSL,#4</code>，表示r2逻辑左移4位。</p><p>ARM在第二个源操作数的数据通路上添加了一个桶形移位器，它能够通过组合逻辑在<strong>不使用移位寄存器的基础上</strong>实现数据移位，<strong>因此移位操作不会带来额外的时钟周期</strong></p><p><img src="/2023/11/21/ARM%E6%8C%87%E4%BB%A4%E9%9B%86%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/image-20231111154234310.png" alt="image-20231111154234310"></p><p>根据第25位决定何种寻址方式</p><p><img src="/2023/11/21/ARM%E6%8C%87%E4%BB%A4%E9%9B%86%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/image-20231111160927413.png" alt="image-20231111160927413"></p><h2 id="条件执行"><a href="#条件执行" class="headerlink" title="条件执行"></a>条件执行</h2><p>ARM每条指令都是条件执行的，如果所属条件不为真那么就会被旁路（无效或者转换位空操作），ARM指令默认都是AL（总是执行），如果不缺省那么就会是 <code>ADDAL r0,r1,r2</code></p><p>我们可以添加其他合适的条件来指明条件执行条件，比如 <code>ADDEQ r1,r2,r3</code>表示 <code>IF Z = 1 THEN [r1] ← [r2] + [r3]</code>, 当条件寄存器中的Z位因为<strong>前一个结果</strong>被置为1时才会被执行</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">if(a == b) e = e + 1;</span><br><span class="line">if(a &lt; b) e = e + 2;</span><br><span class="line">if(a &gt; b) e = e + 3;</span><br><span class="line">---C语言代码---</span><br><span class="line"></span><br><span class="line">CMP r0,r1;</span><br><span class="line">ADDEQ r4,r4,#1;</span><br><span class="line">ADDLE r4,r4,#2;</span><br><span class="line">ADDGT r4,r4,#3;</span><br><span class="line"></span><br><span class="line">if((a == b) &amp;&amp; (c == d)) e++;</span><br><span class="line"></span><br><span class="line">CMP r0,r1;比较a==b</span><br><span class="line">CMPEQ r2,r3;如果 a == b 则比较c == d</span><br><span class="line">ADDEQ r4,r4,#1; </span><br></pre></td></tr></table></figure><h2 id="寻址方式"><a href="#寻址方式" class="headerlink" title="寻址方式"></a>寻址方式</h2><p><strong>ARM不支持直接寻址，也就是不支持将存储单元的内容加载到寄存器中</strong>， 因为它不支持可重定位代码（可被移动到存储器中任何位置而无需计算新的操作数地址），也不支持可重入代码（可被操作系统中断，而中断程序可再次使用该代码而不覆盖之前实例的数据）</p><h3 id="间接寻址"><a href="#间接寻址" class="headerlink" title="间接寻址"></a>间接寻址</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">for(int i = 0; i &lt; 20; i++)&#123;</span><br><span class="line">j[i] = j[i] + 10;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">MOV r0,#0;</span><br><span class="line">ADR r8,j;伪指令， 索引寄存器r8指向数组j</span><br><span class="line">Loop LDR r1,[r8];</span><br><span class="line">ADD r1,r1,#10;</span><br><span class="line">STR r1,[r8];保存j[i]</span><br><span class="line">ADD r0,r0,#1;</span><br><span class="line">CMP r0,#20;</span><br><span class="line">BNE Loop; UNTIL i =20</span><br></pre></td></tr></table></figure><p>此外间接寻址还可增加立即数偏移量，或者是指定第二个寄存器作为偏移量，使用可修改的动态偏移</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">LDR r2,[r0,r1];[r2] ← [[r0] + [r1]]</span><br><span class="line">LDR r2,[r0,r1,LSL #2]; [r2] ← [[r0] + 4 X [r1]]</span><br></pre></td></tr></table></figure><h2 id="自动前-x2F-后索引"><a href="#自动前-x2F-后索引" class="headerlink" title="自动前&#x2F;后索引"></a>自动前&#x2F;后索引</h2><p>为了数组，表格这类经常顺序访问的数据结构能够自动调整为下一个索引，ARM能够将偏移量加到<strong>基址寄存器（指针寄存器）</strong>上，可以在<strong>访问存储器之前或者之后</strong>，<strong>因为与访问存储器并行完成所以不会带来额外的执行时间</strong> </p><p><img src="/2023/11/21/ARM%E6%8C%87%E4%BB%A4%E9%9B%86%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/image-20231111193856940.png" alt="image-20231111193856940"></p><p>自动前索引在有效地址后面添加后缀！来表示，完整示例代码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">AREA AutoIndexing, CODE, READWRITE</span><br><span class="line">ENTRY</span><br><span class="line">LENEQU 8;</span><br><span class="line">ADR r0,A-4;因为使用前递增，所以需要给每个数组首字节减4</span><br><span class="line">ADR r2,B-4;</span><br><span class="line">ADR r3,C-4;</span><br><span class="line">MOV r5, #LEN;</span><br><span class="line">LOOP LDR r3,[r0,#4]!;</span><br><span class="line"> LDR r4,[r1,#4]!;</span><br><span class="line"> ADD r3,r3,r4;</span><br><span class="line"> STR r3,[r2, #4]!;</span><br><span class="line"> SUBS r5,r5,#1;</span><br><span class="line"> BNE LOOP;</span><br><span class="line"> AREA AutoIndexing, DATA, READWRITE</span><br><span class="line">ADCD 1,2,3,4,5,6,7,8;</span><br><span class="line">BDCD 3,2,1,6,5,4,8,7;</span><br><span class="line">BDCD 0,0,0,0,0,0,0,0;</span><br><span class="line"> </span><br></pre></td></tr></table></figure><p>基址寄存器为r1, 偏移量为12，目的寄存器为r1</p><p><img src="/2023/11/21/ARM%E6%8C%87%E4%BB%A4%E9%9B%86%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/image-20231111200035043.png" alt="image-20231111200035043"></p><p>对于load和store指令编码，也可以由条件执行，以及决定偏移量是否可变，指针方向等</p><p><img src="/2023/11/21/ARM%E6%8C%87%E4%BB%A4%E9%9B%86%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/image-20231113173234990.png" alt="image-20231113173234990"></p><p>根据上图可以看出ARM指令可以转换为二进制字符串，比如0101 01 1 1 0 0 10 0010 0100 00010 00 0 0110就表示 </p><p><code>STRPL r4, &#123;r2, -r6,LSL #2&#125;!</code>， 同样也能发现存储的指令字为0X5722 4106</p><p><img src="/2023/11/21/ARM%E6%8C%87%E4%BB%A4%E9%9B%86%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/image-20231113173910423.png" alt="image-20231113173910423"></p><h2 id="子程序调用与返回"><a href="#子程序调用与返回" class="headerlink" title="子程序调用与返回"></a>子程序调用与返回</h2><p>在<strong>CISC</strong>中会使用指令BSR Proc_A调用子程序Proc_A。首先处理器会保存下一条指令的地址，然后将子程序的第一条语句加载到PC中，在子程序的末尾会调用返回指令RTS，然后处理器就会返回到调用点并执行之前保存好的下一条指令。<strong>CISC采用栈结构为子程序调用和返回提供硬件支持，而RISC则不提供硬件支持将子程序处理全部交给程序员</strong></p><p>ARM使用<strong>分支并链接指令BL，来自动将返回地址保存在寄存器r14中，而子程序末尾只需要 <code>MOV r15,r14; </code>或者 <code>MOV pc,lr</code>就能返回</strong></p><p>如下图所示，分支指令分为一个8位操作码和一个24位<strong>有符号、相对于PC</strong>的偏移量。因为<strong>分支目标地址是一个字地址</strong>，按照4字节（32位）对齐的，所以首先会将24位偏移量左移两位（相当于乘4，<strong>把字偏移地址转换为字节地址</strong>），之后再将26位字节地址符号扩展为32位。</p><p>因为分支地址偏移量为26位，所以条件分支寻址范围为PC±32M字节——32M &#x3D; 32 X 2的20次方 &#x3D; 2 的25次方，另有一位表示正负</p><blockquote><img src="/2023/11/21/ARM%E6%8C%87%E4%BB%A4%E9%9B%86%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/image-20231113204209258.png" alt="image-20231113204209258" style="zoom:50%;"></blockquote><p><img src="/2023/11/21/ARM%E6%8C%87%E4%BB%A4%E9%9B%86%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/image-20231113200142721.png" alt="image-20231113200142721"></p><h3 id="子程序嵌套"><a href="#子程序嵌套" class="headerlink" title="子程序嵌套"></a>子程序嵌套</h3><p>基于栈的子程序可以天然的支持<strong>嵌套子程序</strong>，如果现在子程序A中调用嵌套的子程序B，那么就需要保存两个PC的地址，这就需要一个栈来进行先入后出的保存</p><p>而不会调用其他子程序的被称为<strong>叶子程序</strong>（leaf routines）， 如果使用<strong>BL指令</strong>调用一个叶子程序，那么返回地址将会<strong>保存在连接寄存器r14中而不是栈中</strong></p><h2 id="ARM代码实例"><a href="#ARM代码实例" class="headerlink" title="ARM代码实例"></a>ARM代码实例</h2><p><strong>字节操作与拼接</strong></p><p>将r0,r1的最低字节放到r2的高16位中，且不能修改r2的低16位。假设r0,r1的高24位都为0，比如r0为0000 0078， r1为0000 00EF， r2为1122 3344，则r2最后为78EF3344。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ADD r2,r1,r2 LSL #16; r2左移16位后，相当于原低16位的数据到了高16位；此时在和r1的相加</span><br><span class="line">ADD r2,r2,r0 LSL #8; r0左移8位，将r0的最低字节复制到r2的第8~15位</span><br><span class="line">MOV r2,r2, ROR #16; 此时只需要交换r2的高16位与低16位，使用循环右移16位，这样不会破坏任何数据</span><br></pre></td></tr></table></figure><p><strong>多条件使用</strong></p><p>将文本中的大写字母全部替换为小写，ASCII字符中大写字母的第五位都是0，转换的字符在r0中</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">CMP r0,#&#x27;A&#x27;;判断是否在大写范围内</span><br><span class="line">RSBGES r1,r0,#&#x27;Z&#x27;;如果大于等于A，在检查是否小于等于Z，并且更新标志位；翻转减指令， r1 = &#x27;Z&#x27; - r0; </span><br><span class="line">ORRGE r0,r0,#0x0020;如果在，那么将第五位置为1;ORR, 进行逻辑或运算</span><br></pre></td></tr></table></figure><p>假设寄存器r0最低4位为pqrs, 希望实现<code>if((p == 1) &amp;&amp; (r == 1)) s = 1</code>, r1用于工作寄存器</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ANDS r1,r0,#0x8; 逻辑取且，取出p，更新状态位</span><br><span class="line">ANDNES r1,r0,#0x2; 判断p是否为0， 如果不是那么再取出r</span><br><span class="line">ORRNE r0,r0,#1; s置为1</span><br></pre></td></tr></table></figure><h1 id="ARM存储体系"><a href="#ARM存储体系" class="headerlink" title="ARM存储体系"></a>ARM存储体系</h1><p>所有计算机的字编号是通用的，都是第一个字编号为0，最后一个为2^n -1。但是处理器之间的<strong>位编号</strong>都是不同的，大多数微处理器（ARM，Intel，Freescale）都是将数字最低位写在右边如图中a，而PowerPC等则相反如图中b</p><p><img src="/2023/11/21/ARM%E6%8C%87%E4%BB%A4%E9%9B%86%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/image-20231114115821228.png" alt="image-20231114115821228"></p><p>同样的字节编号也有两种，将最高字节放在最低地址称作<strong>大端格式</strong>， 最高字节放在最高位置叫<strong>小端格式</strong></p><p>Intel是小端排序，Freescale是大端排序，而ARM两种都可以，<strong>接下来采用大端格式</strong></p><h2 id="数据组织"><a href="#数据组织" class="headerlink" title="数据组织"></a>数据组织</h2><p>因为ARM存储器是按照字节编址的，所以两个连续的32位字地址相差4字节，必须按照4字节边界对齐存放。</p><p><img src="/2023/11/21/ARM%E6%8C%87%E4%BB%A4%E9%9B%86%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/image-20231114123902370.png" alt="image-20231114123902370"></p><h2 id="块移动指令"><a href="#块移动指令" class="headerlink" title="块移动指令"></a>块移动指令</h2><p>ARM能使用<strong>STM和LDM</strong>将块移入或者移出存储器，这样能在寄存器组和存储器之间移动数据。</p><p>但在实际操作中，会考虑如何进行移动，存储指针何时更新这样的问题——ARM总是把编号最低的寄存器放在地址最低的位置</p><p><strong>与LDR、STR指令寄存器在前，然后是有效地址不同，多寄存器加载&#x2F;存储（LDMIA，STMIA）将指针寄存器在前，需要保存的寄存器列表在大括号中</strong></p><p><code>STMIA r0!,&#123;r1-r3,r5&#125;</code>表示将寄存器r1~r3，r5移动到地址连续的寄存器单元。添加后缀 ! 表示更新栈指针，每一次移动的时候+4  </p><p><img src="/2023/11/21/ARM%E6%8C%87%E4%BB%A4%E9%9B%86%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/image-20231114133049535.png" alt="image-20231114133049535"></p><p>四种形式的栈ARM都可以使用， 本文采用的是FD形式。空指的是栈指针指向栈顶之上的一个空元素，满是指向元素本身；上升，下降分别指的是向高地址或者低地址生长</p><p><img src="/2023/11/21/ARM%E6%8C%87%E4%BB%A4%E9%9B%86%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/image-20231114133639743.png" alt="image-20231114133639743"></p><p>块移动指令的一个重要应用就是在进入或者退出子程序的时候保存或回复寄存器。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">BL test;调用子程序test，并将返回地址保存到r14</span><br><span class="line">...</span><br><span class="line">test STMFD r13!,&#123;r0-r14,r10&#125;;保存六个工作寄存器</span><br><span class="line">...</span><br><span class="line">LDMFD r13!,&#123;r0-r4,r10&#125;;恢复寄存器</span><br><span class="line">MOV pc,r14;返回地址复制到pc</span><br><span class="line">----其实有了块移动就不需要单独写r14的保存和恢复了---</span><br><span class="line">test STMFD r13!,&#123;r0-r14,r10，r14&#125;;</span><br><span class="line">...</span><br><span class="line">LDMFD r13!,&#123;r0-r4,r10,r14&#125;;</span><br></pre></td></tr></table></figure><p>如果需要从table1移动256个子数据到table2，因为块移动指令允许一次移动8个寄存器，所以有以下代码</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">ADR r0,table1;伪指令ADR</span><br><span class="line">ADR r1,table2;</span><br><span class="line">MOV r2,#32; 256 / 8 = 32 ，需要重复32次</span><br><span class="line">Loop LDRFD r0!, &#123;r3-r10&#125;;将8个字数据加载到r3~r10里</span><br><span class="line">STRFD r1!, &#123;r3-r10&#125;;存储到目标表格</span><br><span class="line">SUBS r2,r2,#1;不断重复</span><br><span class="line">BNE Loop;</span><br></pre></td></tr></table></figure><h2 id="栈帧的创建与取消"><a href="#栈帧的创建与取消" class="headerlink" title="栈帧的创建与取消"></a>栈帧的创建与取消</h2><p>如果我们需要开辟一个临时的存储空间， 比如计算 <code>X = （A+B） * C</code> 时，需要将A+B的结果保存起来，而且指令完成之后会被释放，我们就需要一个局部工作区(Local workspace)， 被称作帧</p><p>栈使用栈帧（SF）和帧指针（FP）为动态分配提供了支持，栈帧（SF）是位于栈顶的一块临时存储区域，子程序开始时会将栈指针上移d字节来创建一个d字节的栈帧。</p><p>因为我们采用的是FD，所以是向低地址方向生长，按照约定，会使用<strong>r13作为栈指针</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SUB r13,r13 #100;</span><br></pre></td></tr></table></figure><p>如果我们需要访问位于帧中的临时变量，我们可以通过栈指针或者帧指针访问。不过由于栈指针会因为其他数据进入或离开栈而改变，我们都采用<strong>与临时变量位置固定偏移量的帧指针</strong>来访问， 比如 <code>[r11,-#8]</code>, 按照约定 <strong>r11为帧指针</strong>。最后从子程序返回之前，我们会释放开辟出的存储空间。</p><p><img src="/2023/11/21/ARM%E6%8C%87%E4%BB%A4%E9%9B%86%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/image-20231117113122848.png" alt="image-20231117113122848"></p><p>而ARM中没有用于创建栈帧的连接指令也没有返回时的取消连接指令，都需要我们手动完成</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">SUB sp,sp,#4;首先上移32位字，用于保存指令</span><br><span class="line">STR fp,[sp];保存旧的帧指针在栈中</span><br><span class="line">MOV fp,sp;复制栈指针给帧指针，这是帧指针指向帧底</span><br><span class="line">SUB sp,sp,#8;栈指针上移8个字节，相当于创建了8字节的帧</span><br></pre></td></tr></table></figure><p><img src="/2023/11/21/ARM%E6%8C%87%E4%BB%A4%E9%9B%86%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/image-20231117162611318.png" alt="image-20231117162611318"></p><p>在实践中，可以采用<strong>后递减多存储指令STRFD</strong>, 将链接寄存器（包含返回地址）和帧指针保存在栈中</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">STRFD sp!,&#123;lp,fp&#125;;从栈里面恢复保存的数据</span><br><span class="line">SUB sp,sp,#4;</span><br></pre></td></tr></table></figure><h3 id="代码示例"><a href="#代码示例" class="headerlink" title="代码示例"></a>代码示例</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">AREA TestProg，CODE，READONLY</span><br><span class="line">ENTRY</span><br><span class="line">Begin</span><br><span class="line">MainADR sp,Stack;将r13设为栈指针</span><br><span class="line">MOVr0,#124;设置一个哑参数——不起作用的参数</span><br><span class="line">MOV fp,#123;哑帧指针</span><br><span class="line">STR r0,[sp,#-4]!;参数入栈</span><br><span class="line">BLSub;调用子程序</span><br><span class="line">LDRr1,[sp];载入数据</span><br><span class="line">LOOPBLoop;等待(死循环)</span><br><span class="line">SubSTMFDsp!,&#123;fp,lr&#125;;帧指针和链接寄存器压栈</span><br><span class="line">MOVfp,sp;帧指针指向帧底</span><br><span class="line">SUBsp,sp,#4;创建栈帧(一个字)</span><br><span class="line">LDRr2，[fp,#8];获得先前被压入栈的参数</span><br><span class="line">ADD r2,r2,#120;对该操作进行一个哑操作</span><br><span class="line">STRr2，[fp,#-4];将其保存在栈帧中</span><br><span class="line">ADDsp,sp,#4;清除栈帧</span><br><span class="line">LDMFDsp!,&#123;fp,pc&#125;;恢复栈指针并返回</span><br><span class="line">DCD0x0000;清空存储器</span><br><span class="line">DCD0x0000</span><br><span class="line">DCD0x0000</span><br><span class="line">DCD0x0000</span><br><span class="line">DCD0x0000</span><br><span class="line">StackDCD0x0000;栈起始处(栈向低地址方向生长)</span><br><span class="line">END</span><br></pre></td></tr></table></figure><p><img src="/2023/11/21/ARM%E6%8C%87%E4%BB%A4%E9%9B%86%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/image-20231117170546388.png" alt="image-20231117170546388"></p><h2 id="通过栈传递参数"><a href="#通过栈传递参数" class="headerlink" title="通过栈传递参数"></a>通过栈传递参数</h2><p>和C语言相同，汇编语言中传值也有两种方式：值传递和引用传递</p><p>按照值传递，将参数传递给子程序的方法，Main函数过程及代码如图</p><p><img src="/2023/11/21/ARM%E6%8C%87%E4%BB%A4%E9%9B%86%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/image-20231117204408732.png" alt="image-20231117204408732"></p><p><img src="/2023/11/21/ARM%E6%8C%87%E4%BB%A4%E9%9B%86%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/image-20231117204418203.png" alt="image-20231117204418203"></p><p>按照引用传递</p><p><img src="/2023/11/21/ARM%E6%8C%87%E4%BB%A4%E9%9B%86%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/image-20231117204456429.png" alt="image-20231117204456429"></p><p>他们的重要区别如下所列：</p><p>操作 <code>tmp = a</code> 通过下列代码实现</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">LDR r0,[fp,#4];获取参数a的值</span><br><span class="line">STR r0,[fp,#-4];保存在栈帧tmp中</span><br></pre></td></tr></table></figure><p>操作 <code>tmp = *a</code> 通过下列代码实现</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">LDR r1,[fp,#4];获取参数a的地址</span><br><span class="line">LDR r2,[r1];获取参数a的值</span><br><span class="line">STR r2,[fp,#-4];保存在栈帧tmp中</span><br></pre></td></tr></table></figure><p>此外**swap(x,y)<strong>与</strong>swap(&amp;x,&amp;y)**的参数入栈也不同，一个是值入栈，一个是地址入栈，如4-8b后半部分和4-9b</p><p>ARM的C编译器遵循APCS，它指明了寄存器的用途与别名，r0<del>r3又称a1</del>a4作为通用参数或者工作寄存器，v1~v5位寄存器变量，在函数调用期间会被保存</p><p><img src="/2023/11/21/ARM%E6%8C%87%E4%BB%A4%E9%9B%86%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/image-20231117212243203.png" alt="image-20231117212243203"></p><h1 id="中断与异常"><a href="#中断与异常" class="headerlink" title="中断与异常"></a>中断与异常</h1><p>中断与异常是能够强制计算机停止正常处理并调用<strong>异常处理程序</strong>（一般是操作系统得部分）的事件。一场是指响应内部硬件、软件错误或者外设请求引起的，中断则是程序员执行软中断指令比如输入输出</p><p>ARM处理器会在下列操作模式中工作，每一种模式都有自己的保存程序状态寄存器（SPSR），用于发生异常时保存当前CPSR。但异常在新的寄存器r13,r14切换时，新寄存器组的名称标识如下图</p><p><img src="/2023/11/21/ARM%E6%8C%87%E4%BB%A4%E9%9B%86%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/image-20231117213122593.png" alt="image-20231117213122593"></p><p>每一种操作模式下寄存器r13和寄存器r14都会被复制，被切换到特权模式时，r13和r14在用户模式下的值将不可用，相当于特权模式有私有寄存器——r13和r14，程序员也不必每次发生异常的时候（除了嵌套异常）保存r13和r14</p><p><img src="/2023/11/21/ARM%E6%8C%87%E4%BB%A4%E9%9B%86%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/image-20231118133831553.png" alt="image-20231118133831553"></p><h2 id="处理步骤"><a href="#处理步骤" class="headerlink" title="处理步骤"></a>处理步骤</h2><p>发生异常时，ARM会首先完成当前指令（除非是当前指令引发的异常），然后进入异常处理模式，下面是异常发生时的处理步骤</p><ol><li>操作模式改变为异常对应的模式，中断请求会选择IRQ模式</li><li>将异常发生时的下一条指令地址保存到r14中，异常被当作一次子程序调用，返回地址保存在链接寄存器中</li><li>将<strong>当前处理器状态寄存器CPSR</strong>的值保存在新模式的<strong>保存程序状态寄存器SPSR</strong>中，比如中断请求，CPSR保存在SPSR_irq中，因为异常不能改变处理器状态</li><li>将CPSR的第七位置为1，禁止中断请求。如果当前异常时快速中断请求，那么将CPSR的第六位置为1来禁止其他FIQ异常</li><li>异常表中的每一项都包括异常处理例程中要执行的第一条指令，通常是一个分支操作，它会将对应的<strong>异常处理程序的入口地址</strong>加载到程序计数器中</li></ol><p>下图就列出了异常处理程序对应的第一条指令</p><p><img src="/2023/11/21/ARM%E6%8C%87%E4%BB%A4%E9%9B%86%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/image-20231118150933794.png" alt="image-20231118150933794"></p><p>处理完毕之后，为了从异常返回，已经事先保存了之前的模式信息（PC和CPSR）。但是如果使用普通的操作序列，先恢复pc那么仍然处于异常处理模式，先恢复处理器状态那就不在处于异常状态中，也就不能恢复CPSR了</p><p>涉及到操作模式的改变，ARM提供了两种异常返回机制：用于返回地址已经被保存在分体的r14中；用于返回地址已经入栈</p><p>下表是<strong>处理返回地址在链接寄存器</strong>中的情况，</p><table><thead><tr><th>异常类型</th><th>返回用户模式所用的指令</th></tr></thead><tbody><tr><td>SWI，未定义指令</td><td>MOVS pc,r14</td></tr><tr><td>IRQ,FIQ</td><td>SUBS pc,r14,#4</td></tr><tr><td>数据退出以再次执行故障指令</td><td>SUBS pc,r14,#8</td></tr></tbody></table><p>如果<strong>处理返回地址在栈中</strong>， 需要采用一种特殊机制。如果需要从保存pc在栈中的子程序返回，一般情况可以使用 <code>LDMFD r13!,&#123;r0-r4,pc&#125;</code>。如果需要同一时间将保存在战中的寄存器取出并恢复CPSR，就是用特殊形式 <code>LDMFD r13!,&#123;r0-r4,pc&#125;^</code> 这表明CPSR将在恢复pc时一起被恢复，此外不会修改pc的内容，因此<strong>必须在pc入栈之前对其进行修改</strong></p><h1 id="数据处理与传送"><a href="#数据处理与传送" class="headerlink" title="数据处理与传送"></a>数据处理与传送</h1><p>从数据元素的压缩与移位，位组的位移到检测数据元素是否在正确的范围内都属于数据传送，接下来将并不局限于ARM处理器，而是关注计算机设计方法的变化</p><h2 id="循环"><a href="#循环" class="headerlink" title="循环"></a>循环</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">;ARM处理器实现一个简单的循环;</span><br><span class="line">MOVr0,#10;</span><br><span class="line">Next</span><br><span class="line">SUBS r0,r0,#1;</span><br><span class="line">BEQ Next;</span><br><span class="line"></span><br><span class="line">;Intel的IA32体系结构，使用cx寄存器作为循环计数器完成递减和分支操作不需要显式的寄存器访问，只需使用LOOP指令</span><br><span class="line">MOV cx,count;</span><br><span class="line">Next</span><br><span class="line">Do Something;</span><br><span class="line">LOOP Next;</span><br><span class="line"></span><br><span class="line">;68K提供了一条复杂的递减和分支指令——DBRA，它允许程序员在8个循环计数器中指定一个并在两个出口中选择一个。</span><br><span class="line">;循环计值为-1或达到特定条件时循环结束</span><br><span class="line">MOV #10,D0;</span><br><span class="line">CLR D1;清除寄存器D1中的值</span><br><span class="line">LEA Table,A0;指向数据列表，将Table加载到地址寄存器A0中</span><br><span class="line">NextADD(A0)+, D1;REPEAT，寄存器A0所指向存储单元的值加到D1中，然后A0的指针递增</span><br><span class="line">DBCS D0,Next;</span><br></pre></td></tr></table></figure><h2 id="存储器间接寻址"><a href="#存储器间接寻址" class="headerlink" title="存储器间接寻址"></a>存储器间接寻址</h2><p><strong>寄存器间接寻址使用一个指针访问所需要的操作数</strong>。而在存储器间接寻址模式中，<strong>寄存器提供了一个指向存储器中指针的指针</strong>，实际操作数需要读取第二个指针来访问</p><p>一共需要4次寄存器&#x2F;存储器访问：<strong>读指令；读包含存储器指针的寄存器；读包含指向操作数的存储单元，访问操作数；</strong></p><p>这种寻址模式可以更好的处理数据结构，如果某数据结构含有连续的几组16字节空间，想要访问下一个元素时，可以使用带偏移量的寄存器寻址模式将常数加到指针上， <code>LDR r1,[r0,#16]</code>；也可以采用两个索引寄存器之和表示有效地址，一个表示首元素地址，一个表示偏移量。</p><p>不过如果数据结构每个元素所占用空间并不相同，就需要采用一个指向指针表的指针寄存器，假设A0为基地址 <code>MOV [(A0)],D0</code>访问首元素，然后执行 <code>ADD #4,A0</code>将A0加4指向下一个元素的指针</p><p><img src="/2023/11/21/ARM%E6%8C%87%E4%BB%A4%E9%9B%86%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/image-20231119230426155.png" alt="image-20231119230426155"></p><h3 id="实现switch结构"><a href="#实现switch结构" class="headerlink" title="实现switch结构"></a>实现switch结构</h3><p>switch相当于根据变量n来决定跳转到哪一个函数，我们可以使用一个函数指针的表格，将对应指针载入到PC中就能执行对应函数，</p><p>在传统CISC中，比如68K，可以使用以下指令调用D0指定的子程序(A0表示表格的基地址), <code>JSR ([A0, D0 * 4])</code>。</p><blockquote><p>之前的ARM版本实现switch如下</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">ADR r1,CaseTab;</span><br><span class="line">LDR r15,[r1,r0,LSR #2]; 跳转到所选case</span><br><span class="line"></span><br><span class="line">CaseTab DCD case 0;</span><br><span class="line">DCD case 1;</span><br></pre></td></tr></table></figure></blockquote><p>提供了两个基本选择：前索引（前变址）和后索引（后变址）</p><p><img src="/2023/11/21/ARM%E6%8C%87%E4%BB%A4%E9%9B%86%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/../../Desk/markDown/ARM指令集体系结构/image-20231120143202451.png" alt="image-20231120143202451"><img src="/2023/11/21/ARM%E6%8C%87%E4%BB%A4%E9%9B%86%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/image-20231120143230727.png" alt="image-20231120143230727"></p><p>索引寄存器和记录指针相加，不过68020在间接寻址模式中只允许一个索引寄存器，所以在后变址中程序员需要决定第一级表格指针和二级表格指针中的目标记录哪一个作为运行时变量</p><h1 id="代码压缩"><a href="#代码压缩" class="headerlink" title="代码压缩"></a>代码压缩</h1><blockquote><p>使用短符号替换经常出现的字符串可以压缩文本大小，但是这样指令集会更加受限制，但可以使用8位总线和外设。之前因为8位微处理器能够使用非常便宜的8位存储器、外设和总线，RISC的32位处理器在嵌入式处理器中性价比很差。一种方案是设计压缩RISC，它具备RISC的很多特征但是<strong>字长短得多，Thumb就是第一款这样的处理器</strong></p></blockquote><p>Thumb使用ARM处理器的32位指令集并强制将其转换为16位模式，但是它可以既执行压缩的16位Thumb代码，也可以执行一般的32位代码。它是通过将所需的ARM处理器代码放到小容量32位宽存储器中，其他代码放到便宜的16位宽存储器中</p><p>Thumb状态下，寄存器r8~r12只能采用特殊指令访问。ARM处理器使用<strong>CPSR的第五位（T位）是否为1</strong>来判断是否处于Thumb状态。执行BX（分支并交换）指令可以进入Thumb状态，它会将T位置1并进行跳转，同样也可以执行 <code>BX Rm</code>从Thumb切换回到ARM处理器状态，寄存器Rm中含有要执行的Thumb指令的目标地址</p><p>Thumb状态下限制了寄存器r8~r12的访问，同时丢掉了条件运行，许多指令也采用两地址格式（和CISC处理器一样）来避免编码第三个操作数。同时舍弃了第二操作数移位，增加了一组新的显式移位指令。最后大幅度削减了立即操作数的大小</p><img src="/2023/11/21/ARM%E6%8C%87%E4%BB%A4%E9%9B%86%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/image-20231120224722217.png" alt="image-20231120224722217" style="zoom:80%;"><p>如果需要更新ARM处理器的状态位，是在操作助记符之后加上’S’（将操作码的S位置为1）。但是在Thumb下，对r0~r7的数据处理指令总会更新条件码位(8位处理器的传统方法)</p><p>对于Thumb状态的分支指令，有条件分支有8位偏移量，无条件则有11位。但是<strong>子程序调用指令——BL分支并链接</strong>无法被短立即数满足，同样采用的是带11位偏移量的BL指令，而且可以重复执行并拼接，最终可以得到22位偏移量</p><p><img src="/2023/11/21/ARM%E6%8C%87%E4%BB%A4%E9%9B%86%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/image-20231121103332118.png" alt="image-20231121103332118"></p><p>但第一条指令执行并且H位被清0时，链接寄存器作为临时寄存器，用于保存PC地址加上目标地址的高半部分左移12位的结果。左移12位因为在thumb状态下所有指令的地址都是按照16位或者是半字边界对齐。然后目标地址下半部分与链接寄存器相加将结果保存到pc中来完成分支操作</p><p>编写程序时，可以使用CODE32(ARM代码)，CODE16(Thumb)两个伪代码将代码类型告诉编译器</p><p>Thumb状态下的load&#x2F;store指令基本与ARM指令相同，不过立即数指定的位移量较小，但是支持字节(byte)、半字(half-word)和字(word)类型的数据传送。而且<strong>偏移量会被缩放以便与传送数据的大小适应</strong>，假设5位偏移量为12，有效地址为 <code>[r0, #12]</code>,r0为1000。那么将访问地址为1012的字节，地址为1024或者1048的半字</p><blockquote><p>字的大小取决去具体系统的总线宽度，如果是32位的系统，则一个字(word)是4个字节(byte)，如果是64位，则是8个字节(byte)。</p><p>在8位&#x2F;16位处理器体系结构中，字的长度一般为16位(bit)，2个字节</p></blockquote><h2 id="变长指令"><a href="#变长指令" class="headerlink" title="变长指令"></a>变长指令</h2><p>RISC通常都是采用的定长指令，而8位微处理器和68K等CISC都是采用的变长指令。</p><p>8位处理器的一种解决方案是不需要或者很短操作数的指令长为1个字节，8位操作数指令长2字节，16位存储器地址为3字节。8位微处理器并没有将所有256个操作码都分配给合法指令，可以使用未分配的操作码作为指针，指向一组新的最多256个操作码，这样就相当于创造了一条16位的指令</p><p>使用了变长指令的话一是可以使8位处理器使用任意复杂的指令，同样可以设计一款处理器访问任意大小的程序和数据结构。二是可以将频繁使用的指令限制为一个字节。但是，每条指令访问外部程序和数据存储器的次数可能变多（读取24位指令，占据三字节所以需要3次；如果指定的操作数位16位，那么一共需要5次访问）</p><h1 id="流水线"><a href="#流水线" class="headerlink" title="流水线"></a>流水线</h1><p>高级语言编译器将程序翻译为低级语言程序或者机器指令流，微程序设计则是将机器指令转换为微操作序列，微操作是一种硬件原语操作，比如<em>将数据锁存在寄存器中</em>或者<em>将数据从总线A复制到总线B上</em></p><h2 id="通用结构"><a href="#通用结构" class="headerlink" title="通用结构"></a>通用结构</h2><p>下图是一台非常简单的计算机，包含两个寄存器，和存放指令地址的程序计数器PC、存放 即将写入或者读出存储器数据的地址的 存储器地址寄存器MAR、存放即将写入或读出存储器真实数据的存储器缓冲寄存器MBR以及一个指令寄存器IR</p><p>三条总线A、B、C，所有寄存器都经过A来接受ALU的数据，所有数据也必须通过ALU到达总线A上。除MAR的所有寄存器都可以通过对应的三态驱动器将数据放到B上，但只有MBR和通用寄存器可以将数据放到C上</p><img src="/2023/11/21/ARM%E6%8C%87%E4%BB%A4%E9%9B%86%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/image-20231121155902639.png" alt="image-20231121155902639" style="zoom:150%;"><p>ALU的三个控制输入一共定义了8种功能，同时CCR条件码寄存器保存了溢出，进位，为负，为0——VCNZ等结果</p><h2 id="流水线简介"><a href="#流水线简介" class="headerlink" title="流水线简介"></a>流水线简介</h2><p>时钟周期是计算机种发生的最小时间，机器周期使执行一条指令所需的时间，指令分为5个阶段：</p><ul><li>取指：从系统存储器中读出指令<code>ADD R0,R1,R2</code>,并将PC+4</li><li>译码： 对上一阶段读出的指令译码。定长指令可以经过两级门电路快速译码，复杂指令格式的译码可能需要基于ROM的查找表来实现</li><li>读操作数： 从寄存器R1和R2中读出指令制定的操作数，并送入触发器</li><li>执行</li><li>保存操作数：将结果协会操作数的目的地址</li></ul><p>可以看出当指令处于执行阶段时，保存操作数逻辑正在等待结果，因此需要流水线来让指令执行的各个阶段重叠或者流水(pipeline)执行</p><p><img src="/2023/11/21/ARM%E6%8C%87%E4%BB%A4%E9%9B%86%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/image-20231121174923182.png" alt="image-20231121174923182"></p><p>流水线的最佳长度与实现技术有关，分支以及其他控制程序流的指令很大程度上影响了流水线长度。取指周期事件与取操作数、执行和保存操作数等阶段的时间的比率，很大地决定了流水线的最优长度</p><p>到ARM7为止的ARM处理器使用简单的3级流水线，它包括下列流水线级。 （1）取指令 从寄存器装载一条指令。 （2）译码（decode） 识别被执行的指令，并为下一个周期准备数据通路的控制信号。在这一级，指令占有译码逻辑，不占用数据通路。 （3）执行 处理指令并将结果写回寄存器。下图是ARM的流水线</p><p><img src="/2023/11/21/ARM%E6%8C%87%E4%BB%A4%E9%9B%86%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/image-20231121180058950.png" alt="image-20231121180058950"></p><h2 id="实现流水线"><a href="#实现流水线" class="headerlink" title="实现流水线"></a>实现流水线</h2><p>加速比（speedup ratio）带流水线与不带流水线的速度之比用于描述流水线性能。</p><p>流水线几种情况总结(以三级流水线+冯·诺依曼结构分析)</p><h3 id="单周期指令"><a href="#单周期指令" class="headerlink" title="单周期指令"></a>单周期指令</h3><p>三级流水线</p><p><img src="/2023/11/21/ARM%E6%8C%87%E4%BB%A4%E9%9B%86%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/70.png" alt="img"></p><p>   (1)使用条件：三级流水线在处理简单的寄存器操作指令时(不包括存储器访问指令和跳转指令)</p><p>   (2)上图中的MOV、ADD、SUB等指令为单周期指令，并且都是简单的寄存器指令</p><p>   (3)从T1开始，用3个时钟周期执行了3条指令，指令平均周期数(CPI)等于1个时钟周期。</p><p>​    三级流水线在处理简单的寄存器操作指令时，吞吐率为平均每个时钟周期一条指令；但是在存在存储器访问指令、跳转指令的情况下会出现流水线阻断情况，导致流水线的性能下降。图1给出了流水线的最佳运行情况，图中的MOV、ADD、SUB指令为单周期指令。从T1开始，用3个时钟周期执行了3条指令，指令平均周期数(CPI)等于1个时钟周期。</p><h3 id="分步指令"><a href="#分步指令" class="headerlink" title="分步指令"></a>分步指令</h3><p>带有存储器访问指令的流水线LDR和STR</p><p><img src="/2023/11/21/ARM%E6%8C%87%E4%BB%A4%E9%9B%86%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/70-17005680784464.png" alt="img"></p><p>   ARM指令LDR(装载)   eg. ldr r0，#0x11223344 (将数据0x11223344装载到soc内的寄存器r0中)</p><p>   (1)将数据移进片内(soc)导致了指令&#x2F;数据总线(冯诺依曼就一根线)被占用，LDR指令移进内存(Memory)中。</p><p>   (2)因此随后紧跟了内部的写周期(writeback)以完成将数据写回寄存器。</p><p>工作流程：</p><p>(1)LDR和STR指令，存储器访问指令</p><p>(2)一条指令执行有两个先后动作</p><p>(3)LDR指令</p><pre><code>  step1：访问内存——取数据——冯诺依曼一根线被占用——AND指令被延时(stall)  step2：数据写回寄存器——写数据——冯诺依曼一根线被占用——其他指令被延时</code></pre><p>(4**)由于冯诺依曼结构，仅有一个线作为数据和地址传输，所以执行LDR&#x2F;STR指令时，线被占用，等待LDR指令执行结束，数据&#x2F;地址总线才被释放——这就是阻断流水线的原因和过程**</p><p><img src="/2023/11/21/ARM%E6%8C%87%E4%BB%A4%E9%9B%86%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/70-17005680958677.png" alt="img"></p><p>说明：S ——stall——表示三级流水线部分被拖延了</p><p>​    对存储器的访问指令LDR就是非单周期指令，如图所示。这类指令在执行阶段，首先要进行存储器的地址计算，占用控制信号线，而译码的过程同样需要占用控制信号线，所以下一条指令(第一个SUB)的译码被阻断，并且由于LDR访问存储器和回写寄存器的过程中需要继续占用执行单元，所以下一条(第一个 SUB)的执行也被阻断。由于采用冯·诺伊曼体系结构，不能够同时访问数据存储器和指令存储器，当LDR处于访存周期的过程中时，MOV指令的取指被阻断。因此处理器用8个时钟周期执行了6条指令，指令平均周期数(CPI)&#x3D;1．3个时钟周期。</p><h3 id="分支流水线"><a href="#分支流水线" class="headerlink" title="分支流水线"></a>分支流水线</h3><p>分析跳转指令的动作 &#x3D; B(跳转&#x3D;调整程序指针) + L(写连接寄存器)</p><p><img src="/2023/11/21/ARM%E6%8C%87%E4%BB%A4%E9%9B%86%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/70-170056811831310.png" alt="img"></p><p>ARM跳转指令BL   eg.BL 9X8FEC</p><p>step1：先Link到目的地址(L)</p><p>step2：连接到地址后，修改程序指针进行跳转(B)</p><p>工作流程：(三级流水线)</p><p>(1)一条指令执行有两个先后动作</p><p>(2)BL指令</p><p>step1：找地址(Link)——连接相关地址——冯诺依曼一根线被占用</p><p>step2：跳转(B)——跳转到相关位置——冯诺依曼一根线被占用</p><p>step3：执行完上面两个步骤后，BL指令才执行结束，此时跳到被连接的指令，如上图SUB和ORR指令被抛弃</p><p>(3)由于冯诺依曼结构，仅有一个线作为数据和地址传输，所以执行BL(分步执行)指令时，线被占用，等待BL指令执行结束，数据&#x2F;地址总线才被释放——这就是阻断流水线的原因和过程</p><p>​    当指令序列中含有具有分支功能的指令(如BL等)时，流水线也会被阻断。分支指令在执行时，其后第1条指令被译码，其后第2条指令进行取指，但是这两步操作的指令并不被执行。因为分支指令执行完毕后，程序应该转到跳转的目标地址处执行，因此在流水线上需要丢弃这两条指令，同时程序计数器就会转移到新的位置接着进行取指、译码和执行。此外还有一些特殊的转移指令需要在跳转完成的同时进行写链接寄存器、程序计数寄存器，如BL执行过程中包括两个附加操作——写链接寄存器和调整程序指针。这两个操作仍然占用执行单元，这时处于译码和取指的流水线被阻断了。</p><h3 id="中断-进入异常模式"><a href="#中断-进入异常模式" class="headerlink" title="中断(进入异常模式)"></a>中断(进入异常模式)</h3><p>中断流水线(IRQ 外部中断为例)</p><p>中断发生后，当前指令和中断哪个优先处理，怎么工作的？</p><p> step1：中断发生后，不打断当前正在执行的指令，即等待当前指令执行结束</p><p> step2：执行完当前指令在取处理中断</p><p>ARM发生外部中断，进入中断处理模式IRQ， 发生异常后，CPU进入异常模式，硬件执行四大步三小步</p><p> <img src="/2023/11/21/ARM%E6%8C%87%E4%BB%A4%E9%9B%86%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/70-170056869126113.png" alt="img"></p><p> 按照上面硬件处理异常的四大步三小步来的</p><p>​       step1：当前指令执行阶段：当有中断发生时，当前指令在执行</p><p>​       step2：中断处理入口：当前指令执行结束后，处理中断——上图蓝色框</p><p>​       step3：解码阶段：DI——中断使能，设置相应标志位——进入ARM态——异常向量表的跳转start.S</p><p>​       step4：中断处理：EI——中断处理——void do_irq</p><p>​       step5：连接(LR寄存器)地址——跳转回ARM指令程序中——LR</p><p>​       step6：修正返回地址——pc &#x3D; lr -4</p>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;相关概念&quot;&gt;&lt;a href=&quot;#相关概念&quot; class=&quot;headerlink&quot; title=&quot;相关概念&quot;&gt;&lt;/a&gt;相关概念&lt;/h1&gt;&lt;h2 id=&quot;架构&quot;&gt;&lt;a href=&quot;#架构&quot; class=&quot;headerlink&quot; title=&quot;架构&quot;&gt;&lt;/a&gt;架构&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;CPU架构&lt;/strong&gt;是CPU厂商给属于同一系列的CPU产品定的一个规范，主要目的是为了区分不同类型CPU的重要标示。目	&amp;#96;前市面上的CPU分类主要分有两大阵营，一个是intel、AMD为首的复杂指令集CPU（X86架构），另一个是以IBM、ARM为首的精简指令集CPU(ARM架构)。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;你想造一个房子，在具体的细节实现之前，你必须思考，我到底要造高楼、平房、独栋别墅………然后我确定我要造平房，什么样的平房？我要造三室一厅的平房，这就是一种基于平房架构的内核，我要造四室一厅的平房，这就是基于平房架构的另外一种内核。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;两种架构之前的核心区别是x86是复杂指令集（CISC），ARM是精简指令集（RISC）&lt;/strong&gt;，指令集是指处理器能够识别并执行的指令集合。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;精简指令集：每条指令功能简单，单条指令耗电低，但功能较少对于开发者实现一个功能需要自己想办法实现。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;复杂指令集：一个指令就相当于一个事件&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>C++ 函数模板和类模板</title>
    <link href="https://ycy666666.github.io/2023/11/21/C-%E5%87%BD%E6%95%B0%E6%A8%A1%E6%9D%BF%E5%92%8C%E7%B1%BB%E6%A8%A1%E6%9D%BF/"/>
    <id>https://ycy666666.github.io/2023/11/21/C-%E5%87%BD%E6%95%B0%E6%A8%A1%E6%9D%BF%E5%92%8C%E7%B1%BB%E6%A8%A1%E6%9D%BF/</id>
    <published>2023-11-21T12:23:05.000Z</published>
    <updated>2023-11-21T12:24:03.542Z</updated>
    
    <content type="html"><![CDATA[<h1 id="函数模板"><a href="#函数模板" class="headerlink" title="函数模板"></a>函数模板</h1><h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>所谓的函数模板实际上是建立一个通用函数，其函数类型和形参类型不具体指定，用一个虚拟的类型来表达。这个通用函数就称为函数模板。凡是函数体相同的函数都可以用这个这个模板来取代模板中的虚拟类型，从而实现了不同函数的功能。</p><p>1).模板把函数或类要处理的数据类型参数化，表现为参数的多态性，成为类属。</p><p>2).模板用于<strong>表达逻辑结构相同</strong>，但<strong>具体数据元素类型不同</strong>的数据对象的通用行为。</p><span id="more"></span><h2 id="举例"><a href="#举例" class="headerlink" title="举例"></a>举例</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">myprint</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;调用的是普通函数！&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* template&lt;typename T&gt;</span></span><br><span class="line"><span class="comment">* 函数声明或定义</span></span><br><span class="line"><span class="comment">* template -- 声明创建模板</span></span><br><span class="line"><span class="comment">* typename -- 表面其后面的符号是一种数据类型，可以用class代替</span></span><br><span class="line"><span class="comment">* T -- 通用的数据类型，名称可以替换，通常为大写字母</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">myPrint</span><span class="params">(T a, T b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;调用函数模板！&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;  </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">myPrint</span><span class="params">(T a, T b, T c)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;函数模板重载！&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">int</span> a = <span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> b = <span class="number">20</span>;</span><br><span class="line"><span class="comment">//myPrint(a, b);//1、优先调用函数模板</span></span><br><span class="line">    <span class="built_in">myPrint</span>&lt;<span class="type">int</span>&gt; (a,b); <span class="comment">// 显示指定类型，可以发生隐式类型转换</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//2、通过空模板参数列表 强制调用函数模板</span></span><br><span class="line">myPrint&lt;&gt;(a, b);<span class="comment">//函数模板</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//3、函数模板 重载</span></span><br><span class="line"><span class="type">int</span> c = <span class="number">30</span>;</span><br><span class="line">myPrint&lt;&gt;(a, b, c);<span class="comment">//函数模板重载</span></span><br><span class="line"><span class="built_in">myPrint</span>(a, b, c);<span class="comment">//函数模板重载</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//4、如果函数模板可以产生更好的匹配 优先调用 函数模板</span></span><br><span class="line"><span class="type">char</span> c1 = <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line"><span class="type">char</span> c2 = <span class="string">&#x27;b&#x27;</span>;</span><br><span class="line"><span class="built_in">myPrint</span>(c1, c2);<span class="comment">//调用函数模板</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>普通函数与函数模板的调用规则:</strong></p><p>1、如果函数模板和普通函数都可以实现，<strong>优先调用 普通函数（编译器有关）</strong></p><p>2、可以通过 空模板参数列表 来强制调用函数模板</p><p>3、函数模板也可以发生 函数重载</p><p>4、如果函数模板可以产生更好的匹配 优先调用 函数模板</p><h1 id="类模板"><a href="#类模板" class="headerlink" title="类模板"></a>类模板</h1><h2 id="介绍-1"><a href="#介绍-1" class="headerlink" title="介绍"></a>介绍</h2><p>类模板用于实现类所需数据的<strong>类型参数化</strong></p><p>类模板在表示如数据、表、图等数据结构显得特别重要，这些<strong>数据结构的表示和算法不受所含的元素类型的影响</strong></p><h2 id="举例-1"><a href="#举例-1" class="headerlink" title="举例"></a>举例</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*类模板语法</span></span><br><span class="line"><span class="comment">template&lt;typename T&gt;</span></span><br><span class="line"><span class="comment">类</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">NameType</span>,<span class="keyword">class</span> <span class="title class_">AgeType</span>&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">Person</span>(NameType name, AgeType age)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">this</span>-&gt;m_Name = name;</span><br><span class="line"><span class="keyword">this</span>-&gt;m_Age = age;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">showPerson</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;name = &quot;</span> &lt;&lt; <span class="keyword">this</span>-&gt;m_Name &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;age = &quot;</span> &lt;&lt; <span class="keyword">this</span>-&gt;m_Age &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">NameType m_Name;</span><br><span class="line">AgeType m_Age;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//指定NameType 为 string 类型，AgeType 为 int 类型</span></span><br><span class="line"><span class="function">Person&lt;string, <span class="type">int</span>&gt; <span class="title">p1</span><span class="params">(<span class="string">&quot;Abc&quot;</span>, <span class="number">99</span>)</span></span>;</span><br><span class="line">p1.<span class="built_in">showPerson</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h2><h3 id="类模板对象做函数参数"><a href="#类模板对象做函数参数" class="headerlink" title="类模板对象做函数参数"></a>类模板对象做函数参数</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 三种传入方式 */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//1、指定传入的类型：直接显示对象的数据类型</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">printPerson1</span><span class="params">(Person&lt;string, <span class="type">int</span>&gt;&amp; p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">p.<span class="built_in">showPerson</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//2、参数模板化：将对象中的参数变为模板进行传递</span></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T1,<span class="keyword">class</span> T2&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">printPerson2</span><span class="params">(Person&lt;T1, T2&gt;&amp; p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">p.<span class="built_in">showPerson</span>();</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;T1 的类型：&quot;</span> &lt;&lt; <span class="built_in">typeid</span>(T1).<span class="built_in">name</span>() &lt;&lt; endl;<span class="comment">//string</span></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;T2 的类型：&quot;</span> &lt;&lt; <span class="built_in">typeid</span>(T2).<span class="built_in">name</span>() &lt;&lt; endl;<span class="comment">//int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//3、整个类模板化：将这个对象类型 模板化进行传递</span></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">printPerson3</span><span class="params">(T&amp; p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">p.<span class="built_in">showPerson</span>();</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;T 的类型：&quot;</span> &lt;&lt; <span class="built_in">typeid</span>(T).<span class="built_in">name</span>() &lt;&lt; endl;<span class="comment">//Person</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="成员函数创建时机"><a href="#成员函数创建时机" class="headerlink" title="成员函数创建时机"></a><strong>成员函数创建时机</strong></h3><ul><li>普通类中的成员函数 一开始就可以创建</li><li>类模板中的成员函数 在调用时才创建 因为一开始的时候不知道数据类型</li></ul><h3 id="类模板继承"><a href="#类模板继承" class="headerlink" title="类模板继承"></a>类模板继承</h3><p>当子类继承的父类是一个类模板时，子类在声明的时候，<strong>要指定出父类T的类型</strong></p><ul><li>如果不指定，编译器无法给子类分配内存</li><li>如果想<strong>灵活指定出父类中 T 的类型，子类也需要变为类模板</strong></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">T m;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//class Son :public Base//缺少类模板Base的参数列表,必须知道父类中 T的数据类型，才能继承给子类再分配内存空间</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Son1</span>:<span class="keyword">public</span> Base&lt;<span class="type">int</span>&gt;<span class="comment">//必须指定一个类型</span></span><br><span class="line">&#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//如果想灵活指定出父类中 T 的类型，子类也需要变为类模板</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T1</span>,<span class="keyword">class</span> <span class="title class_">T2</span>&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Son2</span> :<span class="keyword">public</span> Base&lt;T1&gt;</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">Son2</span>()</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;T1 的数据类型：&quot;</span> &lt;&lt; <span class="built_in">typeid</span>(T1).<span class="built_in">name</span>() &lt;&lt; endl;<span class="comment">//int</span></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;T2 的数据类型：&quot;</span> &lt;&lt; <span class="built_in">typeid</span>(T2).<span class="built_in">name</span>() &lt;&lt; endl;<span class="comment">//char</span></span><br><span class="line">&#125;</span><br><span class="line">T1 obj;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Son1 s1;</span><br><span class="line">    Son2&lt;<span class="type">int</span>,<span class="type">char</span>&gt; s2;<span class="comment">//子类创建时，指定类型传递给父类</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="类模板与函数模板的区别"><a href="#类模板与函数模板的区别" class="headerlink" title="类模板与函数模板的区别"></a>类模板与函数模板的区别</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1、类模板在模板参数列表中可以有默认参数</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">NameType</span>, <span class="keyword">class</span> <span class="title class_">AgeType</span> = <span class="type">int</span>&gt; <span class="comment">//模板参数列表中可以有默认参数</span></span><br><span class="line">    </span><br><span class="line"><span class="comment">// 2、类模板没有自动类型推导的使用方式</span></span><br><span class="line">Person <span class="built_in">p</span>(<span class="string">&quot;Abc&quot;</span>, <span class="number">99</span>);<span class="comment">//自动类型推导失败，类模板中，无法使用自动类型推导</span></span><br><span class="line">Person&lt;string, <span class="type">int</span>&gt;<span class="built_in">p</span>(<span class="string">&quot;Abc&quot;</span>, <span class="number">99</span>);<span class="comment">//类模板中只能显示指定类型</span></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="特例化"><a href="#特例化" class="headerlink" title="特例化"></a>特例化</h1><p>编写单一的模板，它能适应多种类型的需求，使每种类型都具有相同的功能，但对于某种特定类型，如果要实现其特有的功能，单一模板就无法做到，这时就需要模板特例化</p><ul><li><strong>全部特例化(全特化)<strong>：必须有一个主模板(泛化版本)，且</strong>模板参数被全部指定</strong>成具体的类型。</li><li><strong>部分特例化(偏特化)<strong>：必须有一个主模板(泛化版本)，且</strong>模板参数被部分指定</strong>成具体的类型。</li></ul><h2 id="函数模板-1"><a href="#函数模板-1" class="headerlink" title="函数模板"></a>函数模板</h2><h3 id="全特化"><a href="#全特化" class="headerlink" title="全特化"></a>全特化</h3><blockquote><p>编译器会对函数模板进行<strong>两次编译</strong></p><p><strong>在声明的地方对模板代码本身进行编译；</strong></p><p><strong>在调用的地方对参数替换后的代码进行编译。</strong></p></blockquote><p>函数模板的全特化等价于函数模板针对特定类型的一个实例化，并不等价于一个函数重载，不能将函数模板的全特化与函数重载混为一谈。</p><ul><li>如果使用普通重载函数，那么不管是否发生实际的函数调用，都会在目标文件中生成该函数的二进制代码。</li><li>如果使用函数模板的全特化版本，<strong>除非发生函数调用，否则不会在目标文件中包含全特化模板函数的二进制代码</strong>，这符合函数模板的“惰性实例化”准则。</li></ul><h3 id="函数模板不能偏特化"><a href="#函数模板不能偏特化" class="headerlink" title="函数模板不能偏特化"></a>函数模板不能偏特化</h3><p>因为模板特化版本不参与函数的重载抉策过程，因此在和函数重载一起使用的时候，可能出现不符合预期的结果</p><p>C++禁止的原因是在于函数模板偏特化和函数重载决策的矛盾，而我们可以显式地避开了函数重载的问题。</p><ol><li><p><strong>使用类模板偏特化</strong>，由于类可以进行偏特化处理，因此一种非常直观的方案就是使用Functor代替函数，并实现<code>operator()</code>。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 借助类模板偏特化demo</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> A, <span class="keyword">typename</span> B&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">F</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">F</span>(A a, B b): <span class="built_in">a_</span>(a), <span class="built_in">b_</span>(b) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">operator</span><span class="params">()</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 使用a_, b_作为函数的参数</span></span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Normal version.&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    A a_;</span><br><span class="line">    B b_;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> A&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">F</span>&lt;A, <span class="type">int</span>&gt; &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">F</span>(A a, <span class="type">int</span> b): <span class="built_in">a_</span>(a), <span class="built_in">b_</span>(b) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">operator</span><span class="params">()</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 使用a_, b_作为函数的参数</span></span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Partial version.&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    A a_;</span><br><span class="line">    <span class="type">int</span> b_;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li><li><p>**使用标签分发(Tag Dispatch)**，通过函数实现不同的函数重载实现，根据不同实参类型选择具体的函数实现，以达到函数模板偏特化的实现</p></li><li><p><strong><code>Concepts</code>特性</strong>，<code>Concepts</code>就是在模板元编程过程中需要用户手动打的hints，来帮助编译器知道你在元编程过程中的想法，进而可以更好地给你提供准确的信息</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> A, <span class="keyword">typename</span> B&gt;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">(A a, B b)</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Normal version.&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> A, <span class="keyword">typename</span> B&gt;</span><br><span class="line"><span class="keyword">requires</span> std::integral&lt;B&gt;<span class="comment">// 使用requires</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">(A a, B b)</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Partial version.&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h2 id="类模板-1"><a href="#类模板-1" class="headerlink" title="类模板"></a>类模板</h2><h3 id="类模板及其成员函数的全特化"><a href="#类模板及其成员函数的全特化" class="headerlink" title="类模板及其成员函数的全特化"></a>类模板及其成员函数的全特化</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span> U&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span>    <span class="comment">// 主模板</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">A</span>() &#123; cout &lt;&lt; <span class="string">&quot;A&lt;T, U&gt;::A()&quot;</span> &lt;&lt; endl; &#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">fun</span><span class="params">()</span> </span>&#123; cout &lt;&lt; <span class="string">&quot;A&lt;T, U&gt;::fun()&quot;</span> &lt;&lt; endl; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span>&lt;<span class="type">int</span>, <span class="type">int</span>&gt;    <span class="comment">// 类模板的全特化</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">A</span>() &#123; cout &lt;&lt; <span class="string">&quot;A&lt;int, int&gt;::A()&quot;</span> &lt;&lt; endl; &#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">fun</span><span class="params">()</span> </span>&#123; cout &lt;&lt; <span class="string">&quot;A&lt;int, int&gt;::fun()&quot;</span> &lt;&lt; endl; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;&gt;</span><br><span class="line"><span class="type">void</span> A&lt;<span class="type">int</span>, <span class="type">double</span>&gt;::<span class="built_in">fun</span>()    <span class="comment">// 类模板成员函数的全特化</span></span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;A&lt;int, double&gt;::fun()&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">A&lt;<span class="type">int</span>, <span class="type">int</span>&gt; aii;</span><br><span class="line">aii.<span class="built_in">fun</span>();</span><br><span class="line"></span><br><span class="line">A&lt;<span class="type">int</span>, <span class="type">double</span>&gt; aid;</span><br><span class="line">aid.<span class="built_in">fun</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 输出结果：</span></span><br><span class="line"><span class="comment"> A&lt;int, int&gt;::A()</span></span><br><span class="line"><span class="comment"> A&lt;int, int&gt;::fun() </span></span><br><span class="line"><span class="comment"> A&lt;T, U&gt;::A()</span></span><br><span class="line"><span class="comment"> A&lt;int, double&gt;::fun()</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><h3 id="偏特化"><a href="#偏特化" class="headerlink" title="偏特化"></a>偏特化</h3><p>不必为所有模板参数提供实参，可以<strong>指定一部分而非所有模板参数</strong>。</p><p>一个类模板的部分特例化本身仍是一个模板，使用它时还必须为其特例化版本中未指定的模板参数提供实参</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Foo</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Bar</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Barst</span><span class="params">(T a)</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;&gt;</span><br><span class="line"><span class="type">void</span> Foo&lt;<span class="type">int</span>&gt;::<span class="built_in">Bar</span>()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//进行int类型的特例化处理</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;我是int型特例化&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Foo&lt;string&gt; fs;</span><br><span class="line">Foo&lt;<span class="type">int</span>&gt; fi;<span class="comment">//使用特例化</span></span><br><span class="line">fs.<span class="built_in">Bar</span>();<span class="comment">//使用的是普通模板，即Foo&lt;string&gt;::Bar()</span></span><br><span class="line">fi.<span class="built_in">Bar</span>();<span class="comment">//特例化版本，执行Foo&lt;int&gt;::Bar()</span></span><br><span class="line"><span class="comment">//Foo&lt;string&gt;::Bar()和Foo&lt;int&gt;::Bar()功能不同</span></span><br></pre></td></tr></table></figure><h3 id="最佳匹配"><a href="#最佳匹配" class="headerlink" title="最佳匹配"></a>最佳匹配</h3><p>根据模板参数范围进行偏特化,<strong>按最佳匹配原则，哪个最匹配，就用相应的模板</strong></p><p>从直观上理解，<code>const int</code> 比 <code>int</code> 的范围小，<code>T*</code> 比 <code>T</code> 的范围小，<code>T&amp;</code> 比 <code>T</code> 的范围小，<code>T&amp;&amp;</code> 比 <code>T</code> 的范围小。</p><p><strong>调用优先级：普通函数 &gt; 函数模板的全特化 &gt; 函数模板。</strong></p>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;函数模板&quot;&gt;&lt;a href=&quot;#函数模板&quot; class=&quot;headerlink&quot; title=&quot;函数模板&quot;&gt;&lt;/a&gt;函数模板&lt;/h1&gt;&lt;h2 id=&quot;介绍&quot;&gt;&lt;a href=&quot;#介绍&quot; class=&quot;headerlink&quot; title=&quot;介绍&quot;&gt;&lt;/a&gt;介绍&lt;/h2&gt;&lt;p&gt;所谓的函数模板实际上是建立一个通用函数，其函数类型和形参类型不具体指定，用一个虚拟的类型来表达。这个通用函数就称为函数模板。凡是函数体相同的函数都可以用这个这个模板来取代模板中的虚拟类型，从而实现了不同函数的功能。&lt;/p&gt;
&lt;p&gt;1).模板把函数或类要处理的数据类型参数化，表现为参数的多态性，成为类属。&lt;/p&gt;
&lt;p&gt;2).模板用于&lt;strong&gt;表达逻辑结构相同&lt;/strong&gt;，但&lt;strong&gt;具体数据元素类型不同&lt;/strong&gt;的数据对象的通用行为。&lt;/p&gt;</summary>
    
    
    
    
    <category term="C++" scheme="https://ycy666666.github.io/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>UI框架设计学习</title>
    <link href="https://ycy666666.github.io/2023/07/18/UI%E6%A1%86%E6%9E%B6%E8%AE%BE%E8%AE%A1%E5%AD%A6%E4%B9%A0/"/>
    <id>https://ycy666666.github.io/2023/07/18/UI%E6%A1%86%E6%9E%B6%E8%AE%BE%E8%AE%A1%E5%AD%A6%E4%B9%A0/</id>
    <published>2023-07-18T15:23:12.000Z</published>
    <updated>2023-07-20T14:54:20.070Z</updated>
    
    <content type="html"><![CDATA[<p>如今的项目大多是吸纳了系统开发Lua化, 针对UI的设计开发中的技术问题总结了一部份资料, 以便于自己增加对UI框架的了解, 并在自己今后设计UI框架时有所参考</p><h1 id="UI框架模型"><a href="#UI框架模型" class="headerlink" title="UI框架模型"></a>UI框架模型</h1><p>游戏UI系统需求变更频繁，为了把界面和数据分离，通常把MVC作为架构设计的参考.  MVC有很多的变种，统称为M-V-X，MVX的本质都是一样的，重点在于M-V之间的桥梁，要靠X来牵线。</p><p>简要介绍一些软件架构的概念及优缺点所在。</p><h2 id="M-V-C"><a href="#M-V-C" class="headerlink" title="M-V-C"></a>M-V-C</h2><p>MVC全称是Model View Controller,是模型(model)-视图(view)-控制器(controller)的缩写，一种软件设计范式，用一种把业务逻辑、数据、界面显示分离的方法组织代码，将业务逻辑聚集到Control中，在改变界面及用户交互的时候不需要重新编写业务逻辑。M层专注于数据处理，V层专注于数据显示</p><span id="more"></span><p><img src="/2023/07/18/UI%E6%A1%86%E6%9E%B6%E8%AE%BE%E8%AE%A1%E5%AD%A6%E4%B9%A0/image-20230714115022407-16898575034391.png" alt="image-20230714115022407"></p><p>MVC的一般流程是这样的: View (界面)发事件  –&gt; Controler (业务)处理了业务，然后发了数据更新 –&gt; 更新了Model的数据 –&gt; Model (带着数据)回到了View –&gt; View更新数据。</p><h3 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h3><p>耦合性低，视图层和业务层分离，很容易改变应用程序的数据层和业务规则，</p><p>重用性高，允许使用各种不同样式的视图来访问同一个模型里面的数据，因此多个视图能共享一个模型，分开明确，生命周期低</p><p>分离视图层和业务层使得应用更易于维护和修改</p><h3 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h3><p>数据(M层)是封闭的，如果多模块需要同一个数据块，数据之间的互通和重用性较低;</p><p>在局部实现了内聚，但是局部内的三角关系之间的逻辑糟合还是很深。<img src="/2023/07/18/UI%E6%A1%86%E6%9E%B6%E8%AE%BE%E8%AE%A1%E5%AD%A6%E4%B9%A0/image-20230714143832715.png" alt="image-20230714143832715"></p><p>在这种情况下，MVC的框架不能很好地应对游戏开发。游戏数据是互相依赖的。比如: 角色的属性展示需要用到背包里的装备，背包需要显示货币; 任务依赖角色等级，同时奖励货币和道具、装备等等。在游戏中使用MVC模式，增加了系统结构和实现的复杂性。</p><p>当你需要变化的时候你需要同时维护三个对象和三个交互，这增加了复杂度。</p><h2 id="M-V-P"><a href="#M-V-P" class="headerlink" title="M-V-P"></a>M-V-P</h2><p>MVP对MVC的改进: 切断View和Model的联系，让View只和Presenter交互，减少在需求变化中需要维护的对象的数量。Model的工作是完成对数据的操纵、获取、存储和状态变化的任务，如: 网络请求，持久化数据增删改查等任务。View只处理视图相关，不做任何逻辑处理</p><h3 id><a href="#" class="headerlink" title></a><img src="/2023/07/18/UI%E6%A1%86%E6%9E%B6%E8%AE%BE%E8%AE%A1%E5%AD%A6%E4%B9%A0/image-20230714144545825.png" alt="image-20230714144545825"></h3><h3 id="优点-1"><a href="#优点-1" class="headerlink" title="优点"></a>优点</h3><p>MVP定义了Presenter和View之间的接口，让一些可以根据已有的接口协议去各自分别独立开发，以此去解决界面需求变化频繁的问题。将Model和View解耦，不管哪一方的实现方式发生变化，只要最终和P同步的数据不变，另一方都不需要关心和修改。</p><p>可以进行View的模拟测试，在View和Model之间没有直接依赖，开发者能够借助模拟对象注入测试两者中的任一方</p><h3 id="缺点-1"><a href="#缺点-1" class="headerlink" title="缺点"></a>缺点</h3><p>每一个View都对应一个Presenter，增加了代码的复杂度，会使程序几余。</p><p>大量的View-&gt;Model，Model-&gt;Views的手动同步逻辑，会导致Presenter臃肿，维护困难。当软件复杂的时候，类和文件就特别多，仍然没有解决Model复用的问题。</p><h2 id="M-V-VM"><a href="#M-V-VM" class="headerlink" title="M-V-VM"></a>M-V-VM</h2><p>M-V-VM也就是Model - View - ViewModel模式</p><p><img src="/2023/07/18/UI%E6%A1%86%E6%9E%B6%E8%AE%BE%E8%AE%A1%E5%AD%A6%E4%B9%A0/image-20230714145946608.png" alt="image-20230714145946608"></p><p>ViewModel替代了MVP的Presenter和MVC的Controller，而View和ViewModel间没有了MVP的界面接口，而是直接交互，原本的Presenter和View一对一的关系现在可以变成了ViewModel-View一对多的关系。</p><h3 id="优点-2"><a href="#优点-2" class="headerlink" title="优点"></a>优点</h3><p>通常通过数据绑定 (DataBinding) 的形式实现View和Model之间的关系映射，抛弃了Presenter层的手动关系接口和维护。</p><p>通过数据更新事件方式不需要开发人员手动编写数据处理逻辑，而是自动地双向同步。比起MVP，M-V-VM不仅简化了业务和界面的依赖关系，还优化了数据频繁更新的问题。</p><p>ViewModel一对多的关系，表示Model在一定程度上可以复用了,类和文件的数量和管理上要减轻很多</p><h3 id="缺点-2"><a href="#缺点-2" class="headerlink" title="缺点"></a>缺点</h3><p>数据绑定使得Bug很难被调试，数据绑定使得一个位置的Bug被快速传递到别的位置，要定位出问题的地方比较闲难。</p><p>当一个大的模块Model很大时，为了保证数据的一致性，会长期持有，不释放内存，造成了花费更多的内存。</p><p>数据双向绑定不利于代码重用，客户端最常用的重复利用是View，但是数据双向绑定技术，让一个View绑定了一个Model，不同模块的Model都不同，就不能简单的重用View了</p><h1 id="事件驱动框架模型"><a href="#事件驱动框架模型" class="headerlink" title="事件驱动框架模型"></a>事件驱动框架模型</h1><p>项目框架设计中没有使用DataBinding技术, 而是定制化MVVM技术,采用事件驱动的方式, 在M与V之间靠Event来连接,  最终形成了<code>Model - View - Event - ValueObject</code>的模型</p><p><img src="/2023/07/18/UI%E6%A1%86%E6%9E%B6%E8%AE%BE%E8%AE%A1%E5%AD%A6%E4%B9%A0/image-20230714153612835.png" alt="image-20230714153612835"></p><p>ViewModel被替换成了ValueObject，以便贴近游戏开发。开发过程中有三种情况: </p><p>(1)、View层可以直接访问Model层的数据; </p><p>(2)、ValueObiect对象不能重用，一个ValueObiect对应一个View; </p><p>(3)、ValueObiect对象可以被多个View对象所使用，增加了ValueObject对象的复用，减少了ValueObject对象的数量。</p><p>游戏中的数据来源于两个地方，一部分是服务器，另外一部分是本地化存储。数据来自于服务器，View和Model是查询关系，并不会改变数据，数据的变化只能来自于服务器的协议驱动; 数据来自于本地化，当View要求Model修改数据时，Model会把数据存放在客户端，然后通知View数据进行更新。<strong>界面通过注册事件来订阅指定的事件类型，数据中心通过和服务器之间的交互来获得或者改变数据，并根据需求推送指定的Event。</strong></p><p>当界面关心的事件发生，它有两种可能:一部分是动态变化的局部更新，可以通过事件带下来;另外一种是整体数据需要去数据中心获取. </p><p>举个例子，当打开背包界面的时候，需要知道所有的背包数据，因此View和Model直接交互，拿到背包里所有道具并显示。然后吃掉了一个经验丹，<strong>服务器会告诉客户端删除一个物品，数据层会通过事件触发，背包监听了这个事件，并且查找对应的道具ID，删除，然后对背包道具进行局部重新排列刷新</strong>。</p><p>假设还有一个界面叫做一键升级，可以选择背包内不同种类的经验丹，那么<strong>它打开的时候同样找数据中心获取道具相关的数据用于显示</strong>. 如果这个时候在背包内吃掉一个，那么同样监听了这条消息的一键升级界面也要重现显示数量。</p><h1 id="底层实现"><a href="#底层实现" class="headerlink" title="底层实现"></a>底层实现</h1><p>游戏UI的展示是一个层级结构。例如: 主界面一般会在最下面，而警告框、公告跑马灯和Loading等一般会在上面。其他界面根据功能需求的不同而定，一般来说后打开会在先打开的上面。</p><p>但也有一些层级是固定的，比如:当已经弹出了警告框，但是这个时候服务器推送协议导致打开了邮件界面，也必须要显示在警告框的下面。因此，需要对UI的显示层级做整体规划，确保在任何时候打开的界面都能按照正确的层级显示正确</p><h2 id="UI层级"><a href="#UI层级" class="headerlink" title="UI层级"></a>UI层级</h2><p>可以采用ZOrder来决定同一层级UI的绘制顺序.  从排序函数中可以看出，先按ZOrder进行排序，然后再按子控件位置进行排席。不同的ZOrder，不管子控件的位置如何，都会优先显示ZOrder值比较大的界面。<strong>相同的ZOrder,按子控件的排布位置来显示，在父节点下面位置越靠下，越后绘制</strong>。</p><h3 id="分组管理"><a href="#分组管理" class="headerlink" title="分组管理"></a>分组管理</h3><p>基于<code>CanvasPanel</code>的ZOrder绘制规则，在显示一个界面时，我们只要赋予正确的ZOrder值，便可以正确的显示出来。因此，我们需要对显示层级进行分组管理，在组与组之间预留一定范围的ZOrder值，每一个界面在显示的时候给它指定对应的分组值，能隔离大部分的UI层级显示。</p><p>定义一个枚举值来表示各组Root的名称,  在总的UI Root下都有对应组的root作为各个界面的父物体</p><p><img src="/2023/07/18/UI%E6%A1%86%E6%9E%B6%E8%AE%BE%E8%AE%A1%E5%AD%A6%E4%B9%A0/image-20230714170504932.png" alt="image-20230714170504932"></p><p>已经基本涵盖了游戏功能类型, 在UIManager的显示Api中需要指定一个分组参数, 也就是定义的枚举值</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">UIManager:LuaShowUI</span><span class="params">(uiname, root, bpPath, uiSubKey, paramsTable)</span></span></span><br></pre></td></tr></table></figure><h3 id="ZOrder自动化管理"><a href="#ZOrder自动化管理" class="headerlink" title="ZOrder自动化管理"></a>ZOrder自动化管理</h3><p>即便有了分组, 大量界面由于异步加载使后打开的界面先加载好等一系列原因, 仍有可能导致渲染顺序不符预期. 为此, 在绑定分组枚举与UI根节点绑定时, 会每组预留出十万的ZOrder间隔. 同时组内面板的层级会维护一个永远增长的Order标志, 打开组内界面都+1, 排除掉了加载时间的影响</p><h2 id="栈状态机"><a href="#栈状态机" class="headerlink" title="栈状态机"></a>栈状态机</h2><p>在UI系统开发的过程中，界面之间的跳转是非常常见的，比如:角色界面有一个按钮点击之后需要打开商店界面但是出于降低设备渲染压力等目的，新打开界面的时候需要隐藏前一个打开的界面，而且关闭打开界面的时候，被隐藏的界面需要自动显示出来。</p><p>又比如A和B两个界面是互斥关系，A在打开的情况下，B打开，A要能自动关闭，同理在B打开的时候，打开A，B也要能自动关闭。还有当一个界面打开时，除了主界面，其他界面要全部自动关闭等等。</p><h3 id="显示策略"><a href="#显示策略" class="headerlink" title="显示策略"></a>显示策略</h3><p>目前定义了四种显示类型</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="built_in">enum</span> EWidgetLayerLevel&#123;</span><br><span class="line">    <span class="comment">// UI之间打开相互不影响</span></span><br><span class="line">    Normalwidget,</span><br><span class="line"><span class="comment">// 同层级会替换且保存，关闭时会自动打开上一未手动关闭的UI界面</span></span><br><span class="line">    UISameLevelCachewidget ,</span><br><span class="line"><span class="comment">// 同层级的UI直接替换，同时只存在一个</span></span><br><span class="line">    SameLevelReplacewidget</span><br><span class="line">    <span class="comment">// 关闭显示栈里除第一个以外的其他所有界面</span></span><br><span class="line">    CloseAlIBackKeywidget,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>应用场景:</p><p><code>Normalwidget</code>: 用于主界面中组队, 每日任务等半屏UI,  不影响主界面显示和隐藏</p><p><code>UISameLevelCachewidget</code>: 仓库, 商城, 活动等大部分全屏界面</p><p><code>SameLevelReplacewidget</code>:  战斗场景中的地图, 背包等界面(参考Apex), 他们之间互斥同时只能显示一个</p><p><code>CloseAlIBackKeywidget</code>:  比如遭受攻击时自动关闭除了主界面外的所有界面,  或者装扮界面需要关闭所有其他UI查看效果</p><p>把界面之间的关系独立成显示策略，可以更加方便的管理他们之间的关系，保证整个显示链路完整。同时，如果需<br>要，可以开发其他的显示策略，具有扩展性。</p><h3 id="生命周期管理"><a href="#生命周期管理" class="headerlink" title="生命周期管理"></a>生命周期管理</h3><p>多个界面之间跳转时, 基本的<code>OnUIOpened</code> 和 <code>OnUIClosed</code>已经不能满足需求. </p><p>比如 AB界面都依赖同一模块中的一些数据,  从A跳转到B时, 在B界面进行操作改变了数据.  那么返回到A界面时, 希望有一个触发函数根据最新数据刷新界面.  我们如果再次触发OnInit会导致显示错乱, 而且很容易产生Bug, 有时候我们只是需要刷新一部分. 综上,我们需要提供更多的生命周期触发函数,来满足开发需求</p><p><strong><code>OnUIOpened</code> –&gt; <code>OnShow</code> –&gt; <code>OnHide</code> –&gt; <code>OnUIClosed</code></strong></p><p>对单个界面而言，提供了四个触发函数，在两个界面跳转之间会调用各自的<code>OnShow</code>和<code>OnHide</code>函数。对同一个界面，函数<code>OnUIOpened</code>和<code>OnUIClosed</code>只会调用一次，由其他界面操作导致的界面刷新逻辑函数写在<code>OnShow</code>和<code>OnHide</code>。每个界面的逻辑放到相应的触发函数中由开发人员实现</p><p>对于一些创建开销大的界面, 我们希望内存能够缓存, 因此提供了<code>IsPersistent</code>作为常驻界面的标识, 同时还提供了枚举值(World生命周期与”主世界”保持一致,  Global全局生命周期)标识切换场景时是否删除</p><h2 id="Lua层事件分发与数据绑定"><a href="#Lua层事件分发与数据绑定" class="headerlink" title="Lua层事件分发与数据绑定"></a>Lua层事件分发与数据绑定</h2><p>每一个绑定界面的Lua脚本中, 都有模板函数 <code>GetControlDefine</code>返回绑定控件的数组. </p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">UI_Lobby_Main:GetControlDefine</span><span class="params">()</span></span></span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">        Widgets = &#123;</span><br><span class="line">            &#123;</span><br><span class="line">                Name = <span class="string">&quot;UI_Lobby_MainMenu&quot;</span>,</span><br><span class="line">                Alias = <span class="string">&quot;MainMenu&quot;</span>,</span><br><span class="line">                Handlers = &#123;</span><br><span class="line">                    <span class="comment">-- 子界面向父界面冒泡事件</span></span><br><span class="line">                    [<span class="string">&quot;OnBtnWarehouseClickedPost&quot;</span>] = <span class="built_in">self</span>.OnBtnWarehouseClickedPost</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;,</span><br><span class="line">            &#123;</span><br><span class="line">                Name = <span class="string">&quot;Btn_Activity&quot;</span>,</span><br><span class="line">                Handlers = &#123;</span><br><span class="line">                    <span class="comment">-- 普通按钮点击事件</span></span><br><span class="line">                    [<span class="string">&quot;OnBtnWarehouseClickedPost&quot;</span>] = <span class="built_in">self</span>.OnBtnWarehouseClickedPost</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;,</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>每个绑定项，由三部分组成:“Name”、“Alias”和”Handles”。“Name”是绑定控制的名称; “Alias”是绑定控件的别名，提高代码的可读性，“Handles”绑定C#提供的事件，也可以是Lua层自己扩展定义的冒泡事件。</p><h3 id="Panel内冒泡事件系统"><a href="#Panel内冒泡事件系统" class="headerlink" title="Panel内冒泡事件系统"></a>Panel内冒泡事件系统</h3><p>Lua层提供了一个事件系统, 实现逻辑内聚和控件重用, 避免Lua全局事件阻碍了控件重用, 污染全局空间</p><p>如上述<code>GetControlDefine</code>函数的Handler, 通过事件名称绑定回调函数,  回调函数中携带了发送者和参数列表. 而子界面就可以通过接口 <code>PostMessahe</code>指定事件名称和携带参数(Lua表)进行事件的冒泡发送 </p><h3 id="自定义数据绑定"><a href="#自定义数据绑定" class="headerlink" title="自定义数据绑定"></a>自定义数据绑定</h3><p>Lua可以给表动态添加字段，对于子界面，可以给子界面传递不同的配置参数，以实现功能的定制化. 在模板函数<code>GetControlDefine</code>中定义的每个控件的Lua表存储在子界面的<code>CustomSetting</code>字段上</p><p>实际案例中, Slider支持两种显示形式:</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">SliderDisplayerType = &#123;</span><br><span class="line">    None = <span class="number">0</span>,</span><br><span class="line">    Range = <span class="number">1</span>, <span class="comment">-- 100/150</span></span><br><span class="line">    Percent = <span class="number">2</span>, <span class="comment">-- 30%</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 在使用控件的地方指定显示格式</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">UI_Customize_OperationBoard_C:GetControlDefine</span><span class="params">()</span></span></span><br><span class="line">    <span class="keyword">return</span>&#123;</span><br><span class="line">        Widgets = &#123;</span><br><span class="line">            Name = <span class="string">&quot;UI_Slider_ButtonScale&quot;</span>,</span><br><span class="line">            SliderDisplayerType = SliderDisplayerType.Percent,</span><br><span class="line">            Handlers = &#123;</span><br><span class="line">            &#125;,</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><h1 id="拓展功能"><a href="#拓展功能" class="headerlink" title="拓展功能"></a>拓展功能</h1><h2 id="通用资源栏显示配置"><a href="#通用资源栏显示配置" class="headerlink" title="通用资源栏显示配置"></a>通用资源栏显示配置</h2><p>通用资源栏: 在主界面上方标志着金币, 付费货币, 体力等通用资源的UI栏.  在商城, 充值界面, 排行榜等都有不同的配置, 比如显示哪一部分数据, 点击对应图标之后是否弹窗等</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 0:Hide</span></span><br><span class="line"><span class="comment">-- 1:can pop window</span></span><br><span class="line"><span class="comment">-- 2:cannot pop window</span></span><br><span class="line"><span class="comment">-- ...</span></span><br><span class="line">UICurrencyAction = &#123;</span><br><span class="line">    [UINames.UI_Rank] = <span class="number">0</span>,</span><br><span class="line">    [UINames.UI_Recharge] = <span class="number">1</span>,</span><br><span class="line">    [UINames.UI_Shop] = <span class="number">2</span>,</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 具体实现逻辑</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">UINavigationManager:PrivateRefreshCurrency</span><span class="params">(uiname)</span></span></span><br><span class="line">    <span class="keyword">local</span> UI_Currency_ResourceBarPanel = LuaPanelUtil.GetUI(WindowsDefine.ResourceBarPanel)</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">if</span> UICurrencyAction[uiname] <span class="keyword">then</span></span><br><span class="line">        <span class="keyword">if</span> UICurrencyAction[uiname] == <span class="number">1</span> <span class="keyword">then</span></span><br><span class="line">            UI_Currency_ResourceBarPanel:PanelShowSelf(<span class="literal">true</span>)</span><br><span class="line">        <span class="keyword">elseif</span> UICurrencyAction[uiname] == <span class="number">2</span> <span class="keyword">then</span></span><br><span class="line">            UI_Currency_ResourceBarPanel:PanelShowSelf(<span class="literal">false</span>)</span><br><span class="line">        <span class="keyword">elseif</span> UICurrencyAction[uiname] == <span class="number">0</span> <span class="keyword">then</span></span><br><span class="line">            UI_Currency_ResourceBarPanel:PanelHideSelf()</span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">end</span>            </span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><h2 id="UI动画的管理"><a href="#UI动画的管理" class="headerlink" title="UI动画的管理"></a>UI动画的管理</h2><p>针对同一物体的动画播放,  如果播放时有正在播放中的动画会把前一个动画强制播放到最后一帧.</p><p>此外, 在播放界面进入和退出时,会禁用界面的输入响应而且不能穿透界面,  使用了两个Panel分别控制不能点击穿透和不响应点击事件</p><h2 id="UI循环列表"><a href="#UI循环列表" class="headerlink" title="UI循环列表"></a>UI循环列表</h2><p>循环列表可分为数据对象和显示对象, 由于显示对象可重复利用能极大的减少内存</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;如今的项目大多是吸纳了系统开发Lua化, 针对UI的设计开发中的技术问题总结了一部份资料, 以便于自己增加对UI框架的了解, 并在自己今后设计UI框架时有所参考&lt;/p&gt;
&lt;h1 id=&quot;UI框架模型&quot;&gt;&lt;a href=&quot;#UI框架模型&quot; class=&quot;headerlink&quot; title=&quot;UI框架模型&quot;&gt;&lt;/a&gt;UI框架模型&lt;/h1&gt;&lt;p&gt;游戏UI系统需求变更频繁，为了把界面和数据分离，通常把MVC作为架构设计的参考.  MVC有很多的变种，统称为M-V-X，MVX的本质都是一样的，重点在于M-V之间的桥梁，要靠X来牵线。&lt;/p&gt;
&lt;p&gt;简要介绍一些软件架构的概念及优缺点所在。&lt;/p&gt;
&lt;h2 id=&quot;M-V-C&quot;&gt;&lt;a href=&quot;#M-V-C&quot; class=&quot;headerlink&quot; title=&quot;M-V-C&quot;&gt;&lt;/a&gt;M-V-C&lt;/h2&gt;&lt;p&gt;MVC全称是Model View Controller,是模型(model)-视图(view)-控制器(controller)的缩写，一种软件设计范式，用一种把业务逻辑、数据、界面显示分离的方法组织代码，将业务逻辑聚集到Control中，在改变界面及用户交互的时候不需要重新编写业务逻辑。M层专注于数据处理，V层专注于数据显示&lt;/p&gt;</summary>
    
    
    
    
    <category term="Unity" scheme="https://ycy666666.github.io/tags/Unity/"/>
    
    <category term="lua" scheme="https://ycy666666.github.io/tags/lua/"/>
    
  </entry>
  
  <entry>
    <title>基于lua的红点树实现</title>
    <link href="https://ycy666666.github.io/2023/07/04/%E5%9F%BA%E4%BA%8Elua%E7%9A%84%E7%BA%A2%E7%82%B9%E6%A0%91%E5%AE%9E%E7%8E%B0/"/>
    <id>https://ycy666666.github.io/2023/07/04/%E5%9F%BA%E4%BA%8Elua%E7%9A%84%E7%BA%A2%E7%82%B9%E6%A0%91%E5%AE%9E%E7%8E%B0/</id>
    <published>2023-07-04T15:51:26.000Z</published>
    <updated>2023-07-24T13:20:01.714Z</updated>
    
    <content type="html"><![CDATA[<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>游戏中的红点算是一个极其常用的功能， 可以为玩家提供有效的非强制性引导。目前比较常用的红点一般围绕两种方案，一种是基于业务模块各自实现，另一种是设计一个尽可能通用的模块来管理红点</p><ol><li><p>基于业务模块</p><p>只需要从各个业务模块获取红点的显示数据，红点的生命周期由对应业务模块负责管理。</p><p>此方案可以避免红点陷入复杂的业务逻辑，但缺点也很明显，ui和业务逻辑过于耦合，ui的调整可能会带来代码逻辑上的改动，从而增加了许多重复的工作量，浪费了人力资源。</p></li><li><p>通用型红点模块</p><p>通用型红点模块即红点模块不仅管理红点数据，还需控制和管理所有业务界面的所有红点的生命周期，将之统一收纳进一个尽可能通用、灵活健壮的管理机制当中。</p><p>为了避免界面调整带来的代码调整，我们把红点的显示路径抽离出代码逻辑，以配置文件的形式交由策划去维护。优点是，程序只要实现一次逻辑，界面调整带来的红点改动只需修改配置即可</p></li></ol><h1 id="红点树配置"><a href="#红点树配置" class="headerlink" title="红点树配置"></a>红点树配置</h1><span id="more"></span><h2 id="红点分类"><a href="#红点分类" class="headerlink" title="红点分类"></a>红点分类</h2><p>红点配置表区分”静态红点”和“动态红点”</p><p>静态红点: RedDot表Type列标记为”Static”。游戏初始化时，直接读取配置，自动生成</p><p>动态红点: RedDot表Type列标记为”Dynamic”。此为红点模板，由程序动态创建。 如装备红点，不希望策划在红点表中将所有装备全部遍历配置出来，所以只需要设置为动态红点，由程序代码创建</p><p>而ParentRedDot列可配置父节点ID</p><h2 id="生成过程"><a href="#生成过程" class="headerlink" title="生成过程"></a>生成过程</h2><p>获得新装备之后，物品所属种类的页面就会出现红点，如果他同时也可升级、熔炼等，其他界面也会出现红点。</p><p><img src="/2023/07/04/%E5%9F%BA%E4%BA%8Elua%E7%9A%84%E7%BA%A2%E7%82%B9%E6%A0%91%E5%AE%9E%E7%8E%B0/image-20230702234024938.png" alt="image-20230702234024938"></p><p><strong>配置过程：</strong></p><p>​从需求可以看出，一个子红点可能有多个父红点。因此最终的api可定义为AddRedHintItem(key, …)， key为子节点， …为不定数量父节点</p><h2 id="职责分工"><a href="#职责分工" class="headerlink" title="职责分工"></a>职责分工</h2><ul><li>配置表:负责红点树的关联和维护</li><li>UIPrefab: 将红点节点直接拖拽进UIPrefab，静态红点设置好红点key</li><li>代码逻辑: 负责具体某个红点的赋值 、创建动态红点、设置prefab上动态红点的Key<ul><li><code>RedHintUtil.lua</code> 对外暴露的红点系统操作接口, 创建、获取、增删、开关红点屏蔽等</li><li><code>RedDotModel.lua</code> 数据层，不暴露</li><li><code>RedDotComponent.lua</code> 表现层， 用于动态设置红点和绑定红点刷新事件</li><li><code>UIRedDot.cs</code> C#组件挂载在Prefab上, 包含了红点对应的key和数字、图片等</li></ul></li></ul><h1 id="红点树数据设置"><a href="#红点树数据设置" class="headerlink" title="红点树数据设置"></a>红点树数据设置</h1><h2 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h2><p>采用的是将所有红点存储在map中， key为红点名称， value’为红点具体信息。</p><p><img src="/2023/07/04/%E5%9F%BA%E4%BA%8Elua%E7%9A%84%E7%BA%A2%E7%82%B9%E6%A0%91%E5%AE%9E%E7%8E%B0/image-20230702234738411.png" alt="image-20230702234738411"></p><ul><li>selfValue: 该红点自身的值</li><li>parentsArr: 该红点的父节点列表</li><li>childrenArr: 该红点的子节点列表</li><li>cacheValue: 该红点及子节点红点数值之和的缓存值 (为了避免反复取值导致的反复计算)</li></ul><h2 id="红点创建与关联"><a href="#红点创建与关联" class="headerlink" title="红点创建与关联"></a>红点创建与关联</h2><p>要实现之前定义的api——<code>AddRedHintItem（key, ...）</code> , 我们需要期望能够双向关联红点， 也就是能在子红点<code>parentsArr</code>中插入父红点， 父红点<code>childrenArr</code>中插入子红点</p><p><img src="/2023/07/04/%E5%9F%BA%E4%BA%8Elua%E7%9A%84%E7%BA%A2%E7%82%B9%E6%A0%91%E5%AE%9E%E7%8E%B0/image-20230702235642422.png" alt="image-20230702235642422"></p><p>selfValue为自身红点的值， 以装备为例： 新装备的selfValue为1，尽管背包入口也有红点，当selfValue仍然为0</p><p>cacheValue为当前节点与子节点所有selfValue之和，为了避免反复计算， 将该值存储到cacheValue中</p><p>注意， 如果获得了另一个新装备， 父层红点缓存的cacheValue也就成为错误的旧数据， 因此每次设置红点时需要将父层红点的cacheValue清空</p><p>设置新红点的流程图：</p><p><img src="/2023/07/04/%E5%9F%BA%E4%BA%8Elua%E7%9A%84%E7%BA%A2%E7%82%B9%E6%A0%91%E5%AE%9E%E7%8E%B0/image-20230703001320614.png" alt="image-20230703001320614"></p><h3 id="红点的清除"><a href="#红点的清除" class="headerlink" title="红点的清除"></a>红点的清除</h3><p>当触发点击事件、特定操作使红点消失后，也需要将父层红点缓存清空</p><p>响应事件消费红点流程图：</p><p><img src="/2023/07/04/%E5%9F%BA%E4%BA%8Elua%E7%9A%84%E7%BA%A2%E7%82%B9%E6%A0%91%E5%AE%9E%E7%8E%B0/image-20230703002818876.png" alt="image-20230703002818876"></p><p>同时也可以清除该红点， 比如全部已读、一键领取等功能。主要是递归清除子节点selfValue， 如果为叶子节点那么再清除该节点与父节点的cacheValue</p><p>清除红点流程图</p><p><img src="/2023/07/04/%E5%9F%BA%E4%BA%8Elua%E7%9A%84%E7%BA%A2%E7%82%B9%E6%A0%91%E5%AE%9E%E7%8E%B0/image-20230703003100273.png" alt="image-20230703003100273"></p><h1 id="屏蔽红点树"><a href="#屏蔽红点树" class="headerlink" title="屏蔽红点树"></a>屏蔽红点树</h1><p>假设有如下需求:进入战斗后，不显示背包系统红点;当战斗结束后，再显示背包系统红点</p><p>上述需求，可以拆为以下步骤</p><ol><li>当进入战斗，设置一个屏蔽key，并通知红点需要刷新;</li><li>计算红点数值时，检测红点是否被屏蔽，若被屏蔽则不计算</li><li>当退出战斗，关闭屏蔽key，并通知红点需要刷新</li><li>重复步骤2</li></ol><h2 id="屏蔽流程"><a href="#屏蔽流程" class="headerlink" title="屏蔽流程"></a>屏蔽流程</h2><p>进入战斗的屏蔽key定义为”battleBlock”，背包入口的红点key为”equipRoot”<br>那么红点屏蔽可配置为:</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">RedHintBlockDefine = &#123;</span><br><span class="line">    battleBlock = &#123;<span class="string">&quot;equipRoot&quot;</span>,&#125;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>尽管有了红点屏蔽的设置，但我们依然无法快速得知该红点是否被屏蔽。我们更希望拿到的是，红点是受哪些blockKey的影响。即，我们希望转义得到:</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">RedHintBlockDefine = &#123;</span><br><span class="line">    equipRoot = &#123;<span class="string">&quot;battleBlock&quot;</span>,&#125;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>另外，游戏逻辑中可能会同时开启多个红点屏蔽key，所以，我们选择位运算的方式，将多个屏蔽key存到一个number字段中。 (例如，有屏蔽a和屏蔽b。当只有a开启屏蔽时，屏蔽值为1&lt;&lt;0;当只有b开启屏蔽时，屏蔽值为1&lt;&lt;1;当a和b都开启屏蔽时，二者取并集)</p><p><strong>初始化红点屏蔽列表的流程图如下图所示</strong></p><p><img src="/2023/07/04/%E5%9F%BA%E4%BA%8Elua%E7%9A%84%E7%BA%A2%E7%82%B9%E6%A0%91%E5%AE%9E%E7%8E%B0/image-20230704230010856.png" alt="image-20230704230010856"></p><p>在上述流程中，屏蔽key已对应成1左移n位的数字表述。那么，开启和关闭屏蔽红点就可以的表述为简单的位运算即可</p><p><strong>设置红点屏蔽的流程图如下图所示</strong></p><p><img src="/2023/07/04/%E5%9F%BA%E4%BA%8Elua%E7%9A%84%E7%BA%A2%E7%82%B9%E6%A0%91%E5%AE%9E%E7%8E%B0/image-20230704230418408.png" alt="image-20230704230418408"></p><p>在配置转义后，我们可以知道该红点收到了哪些屏蔽key的影响。屏蔽key对应的数字也可以通过简单的位运算方式判断是否开启了屏蔽。</p><p><strong>判断红点是否被屏蔽的流程可用下述流程图表述</strong></p><p><img src="/2023/07/04/%E5%9F%BA%E4%BA%8Elua%E7%9A%84%E7%BA%A2%E7%82%B9%E6%A0%91%E5%AE%9E%E7%8E%B0/image-20230704230501489.png" alt="image-20230704230501489"></p><h1 id="获取红点树的数值"><a href="#获取红点树的数值" class="headerlink" title="获取红点树的数值"></a>获取红点树的数值</h1><h2 id="获取过程"><a href="#获取过程" class="headerlink" title="获取过程"></a>获取过程</h2><p>如果一棵红点树比较复杂，然后还需要再主入口显示红点总数<img src="/2023/07/04/%E5%9F%BA%E4%BA%8Elua%E7%9A%84%E7%BA%A2%E7%82%B9%E6%A0%91%E5%AE%9E%E7%8E%B0/image-20230704230857437.png" alt="image-20230704230857437"></p><p>在主入口如果只有装备a显示红点，那么这时候数量显示多少？这时候1和2其实都可以， 如果希望是2那么采用广度遍历，逐层向上设置cacheValue即可</p><p><strong>获取红点的流程图：</strong></p><p><img src="/2023/07/04/%E5%9F%BA%E4%BA%8Elua%E7%9A%84%E7%BA%A2%E7%82%B9%E6%A0%91%E5%AE%9E%E7%8E%B0/image-20230704231653859.png" alt="image-20230704231653859"></p><h2 id="性能优化"><a href="#性能优化" class="headerlink" title="性能优化"></a>性能优化</h2><p>每次界面刷新都会触发红点树的刷新， 而界面刷新又是十分频繁的操作， 那么如何解决其中的性能问题呢</p><p><strong>缓存值：</strong>也就是cacheValue值， 只有为nil时才遍历取值并缓存到cacheValue中</p><p><strong>懒加载：</strong>当红点节点的数值发生变化时，只是将其当前节点及父节点的cacheValue清空，当实际需要显示这个红点数值的时候，再去遍历取值.</p><p><strong>红点树变化具体过程：</strong></p><ol><li><p>原始状态下并停留在游戏主界面，红点树各节点的值</p><p><img src="/2023/07/04/%E5%9F%BA%E4%BA%8Elua%E7%9A%84%E7%BA%A2%E7%82%B9%E6%A0%91%E5%AE%9E%E7%8E%B0/image-20230704233331147.png" alt="image-20230704233331147"></p></li><li><p>打开了背包界面， 红色标记出变化部分</p></li></ol><p>   <img src="/2023/07/04/%E5%9F%BA%E4%BA%8Elua%E7%9A%84%E7%BA%A2%E7%82%B9%E6%A0%91%E5%AE%9E%E7%8E%B0/image-20230704233438492.png" alt="image-20230704233438492"></p><ol start="3"><li>装备a的数据发生变化，红点系统的数据层先将装备a的self设为1，再将自己及父节点的cacheValue置空</li></ol><p>   <img src="/2023/07/04/%E5%9F%BA%E4%BA%8Elua%E7%9A%84%E7%BA%A2%E7%82%B9%E6%A0%91%E5%AE%9E%E7%8E%B0/image-20230704233524474.png" alt="image-20230704233524474"></p><ol start="4"><li><p>通知正在显示中的红点取对应的红点数值</p><p><img src="/2023/07/04/%E5%9F%BA%E4%BA%8Elua%E7%9A%84%E7%BA%A2%E7%82%B9%E6%A0%91%E5%AE%9E%E7%8E%B0/image-20230704233601210.png" alt="image-20230704233601210"></p></li><li><p>关闭背包界面，返回主界面</p><p><img src="/2023/07/04/%E5%9F%BA%E4%BA%8Elua%E7%9A%84%E7%BA%A2%E7%82%B9%E6%A0%91%E5%AE%9E%E7%8E%B0/image-20230704233627073.png" alt="image-20230704233627073"></p></li><li><p>再次打开背包界面时，因为各红点节点的cacheValue均已赋值，直接读取即可</p></li></ol>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h1&gt;&lt;p&gt;游戏中的红点算是一个极其常用的功能， 可以为玩家提供有效的非强制性引导。目前比较常用的红点一般围绕两种方案，一种是基于业务模块各自实现，另一种是设计一个尽可能通用的模块来管理红点&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;p&gt;基于业务模块&lt;/p&gt;
&lt;p&gt;只需要从各个业务模块获取红点的显示数据，红点的生命周期由对应业务模块负责管理。&lt;/p&gt;
&lt;p&gt;此方案可以避免红点陷入复杂的业务逻辑，但缺点也很明显，ui和业务逻辑过于耦合，ui的调整可能会带来代码逻辑上的改动，从而增加了许多重复的工作量，浪费了人力资源。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;通用型红点模块&lt;/p&gt;
&lt;p&gt;通用型红点模块即红点模块不仅管理红点数据，还需控制和管理所有业务界面的所有红点的生命周期，将之统一收纳进一个尽可能通用、灵活健壮的管理机制当中。&lt;/p&gt;
&lt;p&gt;为了避免界面调整带来的代码调整，我们把红点的显示路径抽离出代码逻辑，以配置文件的形式交由策划去维护。优点是，程序只要实现一次逻辑，界面调整带来的红点改动只需修改配置即可&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h1 id=&quot;红点树配置&quot;&gt;&lt;a href=&quot;#红点树配置&quot; class=&quot;headerlink&quot; title=&quot;红点树配置&quot;&gt;&lt;/a&gt;红点树配置&lt;/h1&gt;</summary>
    
    
    
    
    <category term="Unity" scheme="https://ycy666666.github.io/tags/Unity/"/>
    
    <category term="lua" scheme="https://ycy666666.github.io/tags/lua/"/>
    
  </entry>
  
  <entry>
    <title>unity Lua架构学习总结</title>
    <link href="https://ycy666666.github.io/2023/06/28/unity-Lua%E6%9E%B6%E6%9E%84%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93/"/>
    <id>https://ycy666666.github.io/2023/06/28/unity-Lua%E6%9E%B6%E6%9E%84%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93/</id>
    <published>2023-06-28T14:46:14.000Z</published>
    <updated>2023-07-04T15:52:38.836Z</updated>
    
    <content type="html"><![CDATA[<h1 id="基础架构"><a href="#基础架构" class="headerlink" title="基础架构"></a>基础架构</h1><p>基于实习所在的项目组，主要是使用tolua框架在C#端进行C#接口开发，使用C&#x2F;C++ Lua Bindings框架在lua层进行C++接口开发。Lua层能够以脚本更新来实现逻辑代码热更，但对于C#层和C++层的模块修改只能通过发布新的二进制包方式而无法热更</p><p>使用tolua框架能够是Lua层访问C#层接口，使用C&#x2F;C++ Lua Bindings框架使其能够访问C++结构，引入C++主要是为了剥离出会造成GC Alloc压力的代码到C++层。C#层只需要关注Unity引擎接口与Unity插件模块的使用，理想情况下IO，网络，下载与SDK等核心基础模块都应该使用C++开发与优化，从而提高基础组件的性能表现</p><h1 id="Lua层结构"><a href="#Lua层结构" class="headerlink" title="Lua层结构"></a>Lua层结构</h1><h2 id="启动流程"><a href="#启动流程" class="headerlink" title="启动流程"></a>启动流程</h2><p>有了两种绑定方法，Lua层同时具有了调用C++层接口和Unity引擎接口的可能</p><span id="more"></span><p><img src="/2023/06/28/unity-Lua%E6%9E%B6%E6%9E%84%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93/image-20230624205513773.png" alt="image-20230624205513773"></p><p>游戏开始启动时，首先实例化Unity场景，执行挂载在其中的启动脚本，在脚本当中会初始化GameManager，在该脚本种会主动设置一系列全局参数。</p><p>然后会触发C++层初始化操作，这时候会负责初始化SDK， 解密模块，热更模块，线程池等核心模块。此后会创建Lua虚拟机，注册生成绑定代码（wrap文件）</p><p>C++初始化完毕后，初始化流程会返回C#，在C#层初始化基础的Unity相关模块。执行完毕后，tolua#便开始了初始化操作，创建<code>LuaManager</code>实例，<code>LuaManager</code>会创建C#层<code>LuaState</code>对象代理，用来管理C#层Lua交互. 同时tolua#的<code>LuaState</code>会执行<code>LuaBinder</code>和<code>DelegateFactory</code>的初始化注册</p><ul><li><code>LuaBinder</code>会负责所有C#导出接口的注册绑定</li><li><code>DelgateFactory</code>负责所有Lua层注册给C#的回调函数，这些回调函数的管理形式就是以C#的委托来管理的</li></ul><p>在绑定代码注册完毕后，就会加载外部脚本，执行tolua的Lua脚本的加载，其中包括tolua#的Lua组件和tolua++在Lua的实现模块。</p><p>最后就能加载Lua Framework, 开始游戏的启动和登录流程</p><h2 id="toLua"><a href="#toLua" class="headerlink" title="toLua++"></a>toLua++</h2><p>这是Tolua框架的C++层, 其Lua Binding技术特点如下</p><ol><li>宿主语言为C&#x2F;C++</li><li>C++对象的生命周期可依托Lua的GC机制,C++层通过在userdata中存储某个对象地址</li><li>对tolua的简单封装，基于纯净的头文件方式，轻量级的，支持C++模板,极大的简化了C&#x2F;C++代码与Lua代码的集成</li><li>tolua++提供自动生成从Lua访问C&#x2F;C++功能的绑定代码的工具</li></ol><h3 id="对象访问原理"><a href="#对象访问原理" class="headerlink" title="对象访问原理"></a>对象访问原理</h3><p>tolua++为原生对象构建一个userdata作为Lua的引用，其中userdata的值就是C++对象的地址，它的metatable即为对应C++类型的元表，表中包含了导出的成员变量、成员函数等信息。</p><p>对于类成员变量的读取赋值，tolua++是在C++类型的metatable里建立了.get和.set两个表，两个表里key为变量名，value是读取&#x2F;设置的C函数。而_index和 _newindex元方法里，以变量名为key，从.get和.set表里获取对应函数并调用</p><p>调用类成员函数时，会将C++对象的地址作为key（形式为light_userdata），将Lua持有的引用对象作为userdata压入Lua栈中，并将该键值对存储在tolua_ubox表内，下次如果是相同的C++对象，便可直接从这个表中读取缓存</p><p>C++对象与userdata引用关系如下：</p><p><img src="/2023/06/28/unity-Lua%E6%9E%B6%E6%9E%84%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93/image-20230627004308358.png" alt="image-20230627004308358"></p><p>由上图可知，所有light_userdata都共享一张metatable, 不能通过传入的内存地址直接与具体的C++类型metatable相绑定。所以引入tolua_unbox表用来表示C++对象与userdata的映射，用于判断C++对象类型的metatable中是否有ubox表。</p><h3 id="对象生命周期"><a href="#对象生命周期" class="headerlink" title="对象生命周期"></a>对象生命周期</h3><p>在语言绑定技术中，对于原生层对象和脚本层对象，这两种对象的生命周期是不同步的，典型的案例就是开发者调用某个原生类对象的destroy或者remove接口，此时原生层对象将会被释放，而脚本层对象的引用如果仍然被持有，是可以访问的，但是开发者调用任何绑定层提供的接口，都会发现无法找到原生层对象而发生错误或者崩溃。</p><p>基于以上的原因，原生对象的生命周期管理依托于Lua的GC机制，<strong>Lua脚本对象持有C++原生对象的引用，而仅在脚本对象被垃圾回收的时候才释放原生对象</strong>，所以内存模型也被称为 Full GC ReliedMemory Model (完全依赖垃圾回收机制的内存模型)，通过下面这张图可以看到它的基本运作方式</p><p><img src="/2023/06/28/unity-Lua%E6%9E%B6%E6%9E%84%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93/image-20230627005805569.png" alt="image-20230627005805569"></p><p>图中**虚线代表脚本对象对原生对象的引用(通过增加引用计数)**，这样即便从节点树上删除某个节点，它的原生对象也不会被释放。而当脚本对象被垃圾回收的时候，会减少它所引用的原生对象的引用计数，使得原生对象也会被释放。</p><p>这种模式通过以下两点避免原生对象和脚本对象生命周期不同步</p><ol><li>使用垃圾回收机制同时控制原生对象和脚本对象的生命周期</li><li>传递原生层的引用关系给脚本层</li></ol><p><strong>红色箭头代表了在脚本层的对象引用关系</strong>，tolua++在脚本层引用生成时会对C++对象的引用计数加1，而对于脚本对象，当脚本对象的引用被解除后，会使得脚本对象进入GC。又由于每个脚本对象的userdata的元表实现了 _gc的元方法，使得C++导出类的GC函数会被触发执行，此时其中GC函数会将当前原生对象的引用计数减1</p><p>在基于引用计数的管理模式下，即使开发者在原生层释放了某个对象也只会减少它所持有的原生对象的引用计数，并不会影响到因为脚本层引用而所产生的引用计数，从而保证了原生对象和脚本对象生命周期的同步。</p><h3 id="绑定"><a href="#绑定" class="headerlink" title="绑定"></a>绑定</h3><p>tolua++绑定C&#x2F;C++接口，在Lua访问C++对象和方法时，主要有以下三个过程</p><ol><li>获取C++对象指针并且取出Lua传递的参数</li><li>调用对应的C++方法</li><li>将C++返回值传递给Lua</li></ol><p>将C++层API按照Lua的注册函数的签名格式注册到虚拟机中，在Lua层调用对应的C++层的API时tolua++会在当前tolua_ubox中通过userdata找到对应的对象指针，从而取出对应的C++对象，并将参数做类型转换为C++的参数以及做参数类型检查，调用C++层的API，传递解析后的C++参数，并且将C++层的返回值压入Lua栈返回给Lua层</p><h2 id="C-结构"><a href="#C-结构" class="headerlink" title="C++结构"></a>C++结构</h2><h3 id="Runtime"><a href="#Runtime" class="headerlink" title="Runtime"></a>Runtime</h3><p>C++运行时类，负责Lua引擎的管理，以及C++调度管理，包括运行时环境的初始化、清理</p><p>Runtime的创建，主要完成了LuaEngine的构造并控制其整个生命周期，Runtime析构的时候会主动移除LuaEngine并且进行相关的资源释放操作</p><h3 id="LuaEngine"><a href="#LuaEngine" class="headerlink" title="LuaEngine"></a>LuaEngine</h3><p>Lua引擎的管理员，掌管着Lua的初始化、销毁、绑定代码注册，垃圾回收，当他初始化时会创建当前Lua虚拟机的LuaStack对象</p><p>而LuaStack对象管理C++与Lua交互, 负责绑定代码的注册</p><h3 id="LuaDelegate"><a href="#LuaDelegate" class="headerlink" title="LuaDelegate"></a>LuaDelegate</h3><p>保存了对Lua函数的引用, 通过持有对应函数的ref来管理释放与调用</p><p>如果引用计数为0会触发对象的析构, 这个过程中会移除对该Lua函数的引用, 从而使其和当前C++的引用链断开, 如果没有其他地方引用则会GC这个Lua函数</p><h2 id="C-结构-1"><a href="#C-结构-1" class="headerlink" title="C#结构"></a>C#结构</h2><p>项目目前C#结构主题仍然是toLua#的类结构设计, </p><p>主要组成部分功能介绍:</p><h3 id="GameManager"><a href="#GameManager" class="headerlink" title="GameManager"></a>GameManager</h3><p>在C#控制整个游戏的核心逻辑, 管理游戏的生命周期. 实例化构造后, 会执行基础模块的C#文件IO管理, 资源管理的初始化, 然后执行LuaManager的构造以及其他业务模块的初始化</p><p>在C#的创建, 销毁, 调度等都会同步到C++, 使得C++的逻辑能被驱动起来</p><h3 id="LuaManager"><a href="#LuaManager" class="headerlink" title="LuaManager"></a>LuaManager</h3><p>C#层的Lua管理器, 负责Lua初始化和导出绑定代码的注册以及LuaState的初始化.</p><p>C++初始化完成之后,会创建该实例, 拿到C++层初始化的lua_State对象之后执行C#层的初始化. C#会对lua_State封装成LuaState, 提供函数调用以及参数传递转换等,  同样也能维护内部hash表, 对LuaFunction进行弱引用管理</p><h3 id="ObjectTranslator"><a href="#ObjectTranslator" class="headerlink" title="ObjectTranslator"></a>ObjectTranslator</h3><p>为Lua中与C#对象的交互提供了基础, 简单来说就是C#传递对象给Lua时并非直接暴露, 而是会在ObjectTranslator里面注册并返回对应索引.  并将索引包装为userdata传递给Lua,同时为其设置元表</p><p>通过每次生成新的userdata来代表当前C#对象在Lua层的访问存在形式,  会从ObjectTranslator中获取新的索引, 然后将该索引存入userdata中.</p><p>当Lua通过userdata访问C#对象时, 会从userdata中取出这个索引,  在ObjectTranslator中通过索引获取对象</p><p>ObjectTranslator主要用于缓存Lua需要访问的C#对象, 提供对象池以及对象的增删查方法, 管理对象生命周期.  LuaObjectPool对象池包含了PoolNode对象的链表进行循环复用, PoolNode对象包含对真正object的引用以及一个当前空闲索引</p><h3 id="LuaTable"><a href="#LuaTable" class="headerlink" title="LuaTable"></a>LuaTable</h3><p>LuaTable是一种tolua#提供的用于Lua和C#之间传递数据的类型, 可以被看作是C#中的Dictionary, 键和值都可以是任何类型的Lua对象. C#层可以根据tolua#提供的接口获得LuaTable, 然后进行读写或者是传递给Lua中的函数,从而进行数据交换,这是一种双向数据绑定</p><p>而LuaFunction 是tolua#提供的代表C#中的委托,  在Lua中获取到LuaFunction之后就可以直接调用对应的C#函数了</p><h1 id="常见问题与优化"><a href="#常见问题与优化" class="headerlink" title="常见问题与优化"></a>常见问题与优化</h1><h2 id="C-对象访问"><a href="#C-对象访问" class="headerlink" title="C#对象访问"></a>C#对象访问</h2><p>C#对象的访问和C++类似, 都是通过lua中userdata的引用, 然后拿到其中对应的索引信息后在C#的ObjectTranslator中查询到C#对象, 然后调用C#方法.</p><p>那么以Unity的特定组件举例, 假设我们需要获取某游戏对象的transform组件, 然后以此来改变对象数据. 下面给出整个过程的实现细节:</p><table><thead><tr><th align="left">调用</th><th>含义</th></tr></thead><tbody><tr><td align="left"><code>UnityEngine_GameObjectWrap.get_transform</code></td><td>Lua层访问transform属性会直接调用注册进Lua虚拟机的绑定函数，从而调用到该绑定函数</td></tr><tr><td align="left"><code>LuaDLL.tolua_rawnetobj</code></td><td>从Lua对象的userdata中拿到C#对象在ObjectTranslator中的索引</td></tr><tr><td align="left"><code>ObjectTranslator.GetObject</code></td><td>用索引获取在ObjectTranslator中的GameObject对象</td></tr><tr><td align="left"><code>obj.transform</code></td><td>获取gameObject中的transform组件对象</td></tr><tr><td align="left"><code>ObjectTranslator.AddObject</code></td><td>分配一个新的index给transform对象，存入ObjectTranslator</td></tr><tr><td align="left"><code>LuaDLL.tolua_pushnewudata</code></td><td>分配一个新的userdata,并把当前的index存入其中，并把userdata留在Lua栈返回给Lua层</td></tr></tbody></table><p>可以看出获取组件的代价是巨大的,  而且C#的Object不能作为指针直接操作, 所以主流Lua结构都是用ID表示C#的对象索引, 以hash表来对应ID和Object, 同时正如之前所说 这还保证了Lua持有引用时C#对象不会被GC</p><h3 id="值类型传递"><a href="#值类型传递" class="headerlink" title="值类型传递"></a>值类型传递</h3><p>对于Vector3等table类数据,  在C#和Lua中已经是两个数据类型了， 每次传递都会存在类型转换。 尽管tolua已经做了一定的优化， 在Lua层以纯Lua形式实现Vector3，而避免在C#之间传递。 但这种性能优化明显不够，但UI界面需要频繁更新UI节点时会产生大量的Vector3 tabel，这会导致大量GC， 而这时候只是需要通知C#层更新位置而已， 并不需要这样的表对象。这时候完全可以拓展出新的接口， 用number的方式传递，而且这种方式是无GC的</p><h3 id="枚举类型传递"><a href="#枚举类型传递" class="headerlink" title="枚举类型传递"></a>枚举类型传递</h3><p>同样类似的， 对于C#枚举类型的传递，原本tolua会将每个enum强制转换为object类型通过userdata的方式传递给lua， 而且tolua会在c#层维护一个enumMap来映射枚举和对应的object，便于重复读取。</p><p>显然，这也会导致多余GC，因此采用将枚举转换int64的方式，压入栈中传递给Lua层， </p><h2 id="Lua代码加载"><a href="#Lua代码加载" class="headerlink" title="Lua代码加载"></a>Lua代码加载</h2><p>tolua#在C#层提供了一个<code>LuaFileUtils</code>类，内部维护了一个搜索路径的优先级，用来管理Lua文件或者Lua Bundle文件的动态读取，因为是在C#层的lO，所以会产生很多C#的内存，进而导致Mono的GC.</p><p>加载方式主要是C#层通过<code>P/Invoke</code>的方式调用Lua的 C API来设置Lua的Loader。 这样就会导致在require代码的时候， 通过<code>LuaFileUtils</code>类实现Lua文件的IO，然后将文件压入Lua栈中， 这就有C#和C两层的内存开销</p><p>考虑到Lua直接宿主语言是C&#x2F;C++， 因此将Lua编译以及IO操作移植到C++中， 这就可以做到与C#无关，也就不会有相应的GC</p><h2 id="全局变量"><a href="#全局变量" class="headerlink" title="全局变量"></a>全局变量</h2><p>Lua这样的嵌入式语言中，是通过是宿主语言调用代码段(trunk)来实现功能的，Lua不适用全局变量而是使用一个名为全局环境（global  environment）的表来模拟全局环境</p><p>全局变量的使用总是会引发问题， 除了会随着功能增多不稳定之外，如果在_G表中引用了Unity的Object对象就会导致即使对象被Destroy了，仍然会保持引用，引发内存泄漏</p><p>为了避免这个问题， 项目中通常会为_G表设置元表，并实现__Index元方法来阻断全局变量定义</p><h2 id="配置表优化"><a href="#配置表优化" class="headerlink" title="配置表优化"></a>配置表优化</h2><p>随着项目的进行，策划使用的表格也会越来越多， 总体优化思路为去除冗余的无用数据</p><p>csv导出的原始数据一般会保持最直接的多维结构， 因此存在许多默认值为空的字段，增加了table表大小与嵌套。原始结构如下：</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">TaskConfig = &#123;</span><br><span class="line">    [<span class="number">1</span>] = &#123;</span><br><span class="line">    [<span class="string">&quot;TaskID&quot;</span>] = <span class="number">1000</span>,</span><br><span class="line">        [<span class="string">&quot;TaskName&quot;</span>] = <span class="string">&quot;NewPlayer&quot;</span>,</span><br><span class="line">        [<span class="string">&quot;Reward&quot;</span>] = &#123;<span class="string">&quot;Gold&quot;</span>, <span class="string">&quot;Exp&quot;</span>&#125;,</span><br><span class="line">        ...</span><br><span class="line">    &#125;,</span><br><span class="line">    [<span class="number">2</span>] = &#123;</span><br><span class="line">        [<span class="string">&quot;TaskID&quot;</span>] = <span class="number">1001</span>,</span><br><span class="line">        [<span class="string">&quot;TaskName&quot;</span>] = <span class="string">&quot;Daily&quot;</span>,</span><br><span class="line">        [<span class="string">&quot;Reward&quot;</span>] = &#123;<span class="string">&quot;Gold&quot;</span>, <span class="string">&quot;Exp&quot;</span>&#125;,</span><br><span class="line">        ...</span><br><span class="line">    &#125;,</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="字段名优化"><a href="#字段名优化" class="headerlink" title="字段名优化"></a>字段名优化</h3><p>利用metatable， 创建一张KeyMap， 导出时将Hash表转为数组，降低小表的内存占用</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 所有字段名都标注一个字段序</span></span><br><span class="line"><span class="keyword">local</span> KeyMap = &#123;</span><br><span class="line">    [<span class="string">&quot;TaskID&quot;</span>] = <span class="number">1</span>,</span><br><span class="line">    [<span class="string">&quot;TaskName&quot;</span>] = <span class="number">2</span>,</span><br><span class="line">    [<span class="string">&quot;Reward&quot;</span>] = <span class="number">3</span>,</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 数组形式展开</span></span><br><span class="line">TaskConfig = &#123;</span><br><span class="line">    [<span class="number">1</span>] = &#123;<span class="number">1000</span>, <span class="string">&quot;NewPlayer&quot;</span>, &#123;<span class="string">&quot;Gold&quot;</span>, <span class="string">&quot;Exp&quot;</span>&#125;, ...&#125;,</span><br><span class="line">    [<span class="number">2</span>] = &#123;<span class="number">1001</span>, <span class="string">&quot;Daily&quot;</span>, &#123;<span class="string">&quot;Gold&quot;</span>, <span class="string">&quot;Exp&quot;</span>&#125;, ...&#125;,</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 迭代器函数</span></span><br><span class="line"><span class="keyword">local</span> <span class="function"><span class="keyword">function</span> <span class="title">iterator</span><span class="params">(t, k)</span></span></span><br><span class="line">    <span class="keyword">local</span> v</span><br><span class="line">    k, v = <span class="built_in">next</span>(KeyMap, k)</span><br><span class="line">    <span class="keyword">if</span> v ~= <span class="literal">nil</span> <span class="keyword">then</span> <span class="keyword">return</span> k, t[v] <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span>    </span><br><span class="line"></span><br><span class="line"><span class="comment">-- 元表</span></span><br><span class="line"><span class="keyword">local</span> mt = &#123;</span><br><span class="line">    <span class="built_in">__index</span> = <span class="function"><span class="keyword">function</span><span class="params">(t, k)</span></span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> k <span class="keyword">then</span> <span class="keyword">return</span> <span class="keyword">end</span></span><br><span class="line">        <span class="keyword">return</span> t[KeyMap[k]]</span><br><span class="line">    <span class="keyword">end</span>,</span><br><span class="line">    <span class="built_in">__newindex</span> = <span class="function"><span class="keyword">function</span><span class="params">(t, k, v)</span></span></span><br><span class="line">        <span class="keyword">local</span> tk = KeyMap[k] <span class="keyword">or</span> k</span><br><span class="line">        rawret(t, tk, v)</span><br><span class="line">    <span class="keyword">end</span>,</span><br><span class="line">    __pairs = <span class="function"><span class="keyword">function</span><span class="params">(t)</span></span></span><br><span class="line">        <span class="keyword">return</span> iterator, t, <span class="literal">nil</span></span><br><span class="line">    <span class="keyword">end</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 设置每行数据的metatable</span></span><br><span class="line"><span class="keyword">local</span> <span class="function"><span class="keyword">function</span> <span class="title">_setmatatable</span><span class="params">(t,cnt)</span></span></span><br><span class="line">    <span class="keyword">if</span> cnt == <span class="number">0</span> <span class="keyword">then</span></span><br><span class="line">        <span class="built_in">setmetatable</span>(t, mt)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> _, v <span class="keyword">in</span> <span class="built_in">pairs</span>(t) <span class="keyword">do</span></span><br><span class="line">        _setmetatable(v, cnt - <span class="number">1</span>)</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">local</span> KeyConut = <span class="number">1</span></span><br><span class="line">_setmatatable(TaskConfig, KeyConut)</span><br></pre></td></tr></table></figure><h3 id="默认值提取"><a href="#默认值提取" class="headerlink" title="默认值提取"></a>默认值提取</h3><p>对于大量重复的默认值，常见优化方式是将默认数据置空，所有默认值存储在单独的table中，作为共享对象使用</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">local</span> DefaultValueMap = &#123;</span><br><span class="line">    [<span class="string">&quot;Reward&quot;</span>] = &#123;<span class="string">&quot;Gold&quot;</span>, <span class="string">&quot;Exp&quot;</span>&#125;,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">TaskConfig = &#123;</span><br><span class="line">    [<span class="number">1</span>] = &#123;<span class="number">1000</span>, <span class="string">&quot;NewPlayer&quot;</span>, <span class="literal">nil</span>, ...&#125;,</span><br><span class="line">    [<span class="number">2</span>] = &#123;<span class="number">1001</span>, <span class="string">&quot;Daily&quot;</span>, <span class="literal">nil</span>, ...&#125;,</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">local</span> mt = &#123;</span><br><span class="line">    <span class="built_in">__index</span> = <span class="function"><span class="keyword">function</span><span class="params">(t, k)</span></span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> k <span class="keyword">then</span> <span class="keyword">return</span> <span class="keyword">end</span></span><br><span class="line">        <span class="keyword">return</span> t[KeyMap[k]] <span class="keyword">or</span> DefaultValueMap[k]</span><br><span class="line">    <span class="keyword">end</span>,</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="表格压缩"><a href="#表格压缩" class="headerlink" title="表格压缩"></a>表格压缩</h3><p>核心点是将导出的配置表中的N维表格改成用一维数组的方式来表示，减少整个配置表结构中的Lua表规模，从而降低Lua内存</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 把N维表格转为一维， 降低table表个数</span></span><br><span class="line"><span class="keyword">local</span> DataTable = &#123;</span><br><span class="line">    [<span class="number">1</span>] = &#123;<span class="number">1000</span>, <span class="string">&quot;NewPlayer&quot;</span>, <span class="literal">nil</span>, ..., <span class="number">1001</span>, <span class="string">&quot;Daily&quot;</span>, <span class="literal">nil</span>, ...&#125;,</span><br><span class="line">    [<span class="number">2</span>] = &#123;<span class="number">1000</span>, <span class="number">1001</span>, ...&#125;,<span class="comment">-- 提取出索引ID</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 所有字段名都标注一个字段序</span></span><br><span class="line"><span class="keyword">local</span> KeyMap = &#123;</span><br><span class="line">    [<span class="string">&quot;TaskID&quot;</span>] = <span class="number">1</span>,</span><br><span class="line">    [<span class="string">&quot;TaskName&quot;</span>] = <span class="number">2</span>,</span><br><span class="line">    [<span class="string">&quot;Reward&quot;</span>] = <span class="number">3</span>,</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 迭代器，用于遍历每一行数据</span></span><br><span class="line"><span class="keyword">local</span> <span class="function"><span class="keyword">function</span> <span class="title">iter1</span><span class="params">(t, k)</span></span></span><br><span class="line">    k = <span class="built_in">next</span>(KeyMap, k)</span><br><span class="line">    <span class="keyword">return</span> k, t[k]</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 一维数组每一段的迭代器, 对应表格中每一行</span></span><br><span class="line"><span class="keyword">local</span> mt1 = &#123;</span><br><span class="line">    <span class="built_in">__index</span> = <span class="function"><span class="keyword">function</span><span class="params">(t, k)</span></span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> k <span class="keyword">or</span> <span class="keyword">not</span> KeyMap[k] <span class="keyword">then</span> <span class="keyword">return</span> <span class="keyword">end</span></span><br><span class="line">        <span class="keyword">local</span> idx = t.left + KeyMap[k]</span><br><span class="line">        <span class="keyword">return</span> DataTable[<span class="number">1</span>][idx] <span class="keyword">or</span> DefaultValues[k]</span><br><span class="line">    <span class="keyword">end</span>,</span><br><span class="line">    __pairs = <span class="function"><span class="keyword">function</span><span class="params">(t)</span></span></span><br><span class="line">        <span class="keyword">return</span> iter1, t, <span class="literal">nil</span></span><br><span class="line">    <span class="keyword">end</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 一维数组迭代器， 也就是遍历出每个Task</span></span><br><span class="line"><span class="keyword">local</span> <span class="function"><span class="keyword">function</span> <span class="title">iter2</span><span class="params">(t, k)</span></span></span><br><span class="line">    <span class="keyword">local</span> v</span><br><span class="line">    <span class="keyword">if</span> k <span class="keyword">then</span></span><br><span class="line">        <span class="keyword">local</span> vv = t[k]</span><br><span class="line">        <span class="keyword">local</span> i = vv.idx + <span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> i &gt; #DataTable[<span class="number">2</span>] <span class="keyword">then</span></span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">        k = DataTable[<span class="number">2</span>][i]</span><br><span class="line">        v = &#123; left = (i - <span class="number">1</span>) * ValConut + <span class="number">1</span>, idx = i&#125;</span><br><span class="line">        <span class="built_in">setmetatable</span>(v, mt1)</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        k = DataTable[<span class="number">2</span>][<span class="number">1</span>]</span><br><span class="line">        v = t[k]</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">return</span> k, v</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 配置表对象的元表， 用于获取某个key的表对象，以mt1为元表</span></span><br><span class="line"><span class="keyword">local</span> mt2 = &#123;</span><br><span class="line">    <span class="built_in">__index</span> = <span class="function"><span class="keyword">function</span><span class="params">(t,k)</span></span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> k <span class="keyword">then</span> <span class="keyword">return</span> <span class="keyword">end</span></span><br><span class="line">        <span class="keyword">for</span> i = <span class="number">1</span>, #DataTable[<span class="number">2</span>], <span class="number">1</span> <span class="keyword">do</span></span><br><span class="line">            <span class="keyword">if</span> k == DataTable[<span class="number">2</span>][i] <span class="keyword">then</span></span><br><span class="line">                <span class="keyword">local</span> tbl = &#123; left = (i - <span class="number">1</span>) * ValCount + <span class="number">1</span>&#125;</span><br><span class="line">                <span class="built_in">setmetatable</span>(tbl, mt1)</span><br><span class="line">                <span class="keyword">return</span> tbl</span><br><span class="line">            <span class="keyword">end</span></span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">end</span>,</span><br><span class="line">    __pairs = <span class="function"><span class="keyword">function</span><span class="params">(t)</span></span></span><br><span class="line">        <span class="keyword">return</span> iter2, t, <span class="literal">nil</span></span><br><span class="line">    <span class="keyword">end</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">local</span> tbl = &#123;&#125;</span><br><span class="line"><span class="built_in">setmetatable</span>(tbl, mt2)</span><br><span class="line">TaskConfig = tbl</span><br></pre></td></tr></table></figure><h2 id="Lua内存泄漏"><a href="#Lua内存泄漏" class="headerlink" title="Lua内存泄漏"></a>Lua内存泄漏</h2><p>Lua层内存泄漏主要在三个方面</p><ul><li><p>C#委托</p></li><li><p>循环引用</p></li><li><p>全局引用</p></li></ul><h3 id="C-委托"><a href="#C-委托" class="headerlink" title="C#委托"></a>C#委托</h3><p>Lua层会通过tolua#注册回调给C#层, 使得Lua层会有对应的逻辑. 但如果在C#层没有及时的对委托进行清理, tolua#层在Collector的时候也无法回收对应的LuaFunction对象,也就不能释放其中引用的Lua表对象</p><p>因此需要对每一个在Lua层注册到C#层的回调函数都显式的做出清理操作, 不再使用委托时 应当实现Dispose接口或者其他接口清理委托对象</p><h3 id="循环引用"><a href="#循环引用" class="headerlink" title="循环引用"></a>循环引用</h3><p>会经常使用handler这个函数对象接口来包装回调函数, 但是handler调用之后会产生一个新的匿名函数对象,  而传入的obj参数会成为该匿名函数的upvalue, 只有匿名函数引用消失后才会对obj的引用消除</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">handler</span><span class="params">(obj, method)</span></span></span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> <span class="params">(...)</span></span></span><br><span class="line">        method(obj, ...)</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span>    </span><br></pre></td></tr></table></figure><p>handler一般都会传入一个self表做包装, 如果是一个可以反复创建的对象, 如果不主动清理这个匿名函数, 就会导致这个匿名函数与对象循环引用, 造成两侧的内存泄漏</p><p>出于安全性的考虑, 时刻关注匿名函数生命周期不太合适, 因此采用自动管理的方式.  将handler传入的obj对象从强引用转换为弱引用, 在其他地方没有对obj的引用后会自动进入GC</p><h3 id="全局引用"><a href="#全局引用" class="headerlink" title="全局引用"></a>全局引用</h3><p>因为前面已经提出了禁止全局变量使用的优化, 但部分特殊框架仍然会在_G表下</p><p>tolua#中提供了多个调度对象–<code>UpdateBeat</code>, <code>LateUpdateBeat</code>, <code>FixedUpdateBeat</code>, <code>CoUpdateBeat</code>, 这些都是event实例化的对象, 且均在_G环境下作为常驻对象存在</p><p>tolua的event类其中的self.current会引用最后一次遍历对象, 那么这就导致了这些对象会被一直引用,无法进入GC. 既然是因为引用链未及时清理, 那么每次遍历结束后直接清理self.current为nil即可</p><p>对于这种因为上层对象是全局对象引发的内存泄漏, 只需清理引用关系链,驱动真缺德内存对象GC即可, 特别是Lua函数很容易形成闭包upvalue的强引用关系,</p>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;基础架构&quot;&gt;&lt;a href=&quot;#基础架构&quot; class=&quot;headerlink&quot; title=&quot;基础架构&quot;&gt;&lt;/a&gt;基础架构&lt;/h1&gt;&lt;p&gt;基于实习所在的项目组，主要是使用tolua框架在C#端进行C#接口开发，使用C&amp;#x2F;C++ Lua Bindings框架在lua层进行C++接口开发。Lua层能够以脚本更新来实现逻辑代码热更，但对于C#层和C++层的模块修改只能通过发布新的二进制包方式而无法热更&lt;/p&gt;
&lt;p&gt;使用tolua框架能够是Lua层访问C#层接口，使用C&amp;#x2F;C++ Lua Bindings框架使其能够访问C++结构，引入C++主要是为了剥离出会造成GC Alloc压力的代码到C++层。C#层只需要关注Unity引擎接口与Unity插件模块的使用，理想情况下IO，网络，下载与SDK等核心基础模块都应该使用C++开发与优化，从而提高基础组件的性能表现&lt;/p&gt;
&lt;h1 id=&quot;Lua层结构&quot;&gt;&lt;a href=&quot;#Lua层结构&quot; class=&quot;headerlink&quot; title=&quot;Lua层结构&quot;&gt;&lt;/a&gt;Lua层结构&lt;/h1&gt;&lt;h2 id=&quot;启动流程&quot;&gt;&lt;a href=&quot;#启动流程&quot; class=&quot;headerlink&quot; title=&quot;启动流程&quot;&gt;&lt;/a&gt;启动流程&lt;/h2&gt;&lt;p&gt;有了两种绑定方法，Lua层同时具有了调用C++层接口和Unity引擎接口的可能&lt;/p&gt;</summary>
    
    
    
    
    <category term="Unity" scheme="https://ycy666666.github.io/tags/Unity/"/>
    
    <category term="lua" scheme="https://ycy666666.github.io/tags/lua/"/>
    
  </entry>
  
  <entry>
    <title>NGUI使用方法</title>
    <link href="https://ycy666666.github.io/2023/04/29/NGUI%E4%BD%BF%E7%94%A8%E6%96%B9%E6%B3%95/"/>
    <id>https://ycy666666.github.io/2023/04/29/NGUI%E4%BD%BF%E7%94%A8%E6%96%B9%E6%B3%95/</id>
    <published>2023-04-29T12:59:39.000Z</published>
    <updated>2023-04-29T13:12:49.688Z</updated>
    
    <content type="html"><![CDATA[<h1 id="基本用法"><a href="#基本用法" class="headerlink" title="基本用法"></a>基本用法</h1><p>很多基本模块比如按钮、slider等都能从Prefab中直接拖拽到场景中实现，但都需要有一个Collider（Prefab已经自带）</p><p>因为不仅是UI，所有带有Collider的游戏物体都能接收到OnClick， OnPress这样的事件——前提是需要在Main Camera里面添加上event System组件，然后自定义脚本添加以下函数：</p><p><img src="/2023/04/29/NGUI%E4%BD%BF%E7%94%A8%E6%96%B9%E6%B3%95/%E8%8E%89%E8%8E%89%E4%B8%9D%E9%A3%9E%E4%B9%A620230412-142107.jpg" alt="莉莉丝飞书20230412-142107"></p><p>如果不想写代码，也可以直接拖拽UIEventTrugger脚本来实现相关功能</p><p><img src="/2023/04/29/NGUI%E4%BD%BF%E7%94%A8%E6%96%B9%E6%B3%95/%E8%8E%89%E8%8E%89%E4%B8%9D%E9%A3%9E%E4%B9%A620230412-143328.jpg" alt="莉莉丝飞书20230412-143328"></p><p>与此同时，我们也可以给其中一个事件绑定多个函数，比如滑动条的变更既改变音量大小也能改变滑动条背景颜色。也能在On Finished中指定动作完成后发生的下一动作</p><span id="more"></span><h2 id="核心组件"><a href="#核心组件" class="headerlink" title="核心组件"></a>核心组件</h2><h3 id="UILabel-标签"><a href="#UILabel-标签" class="headerlink" title="UILabel (标签)"></a>UILabel (标签)</h3><p><img src="/2023/04/29/NGUI%E4%BD%BF%E7%94%A8%E6%96%B9%E6%B3%95/v2-74aa8940d4cc2e8235c5126f2a8c9735_720w.webp" alt="img"></p><p>用于创建各种类型的文本标签和标注，除了基本的文本属性外，NGUI的UILabel还具有文本对齐方式（alignment）, 渐变和模糊（gradient和blur属性）</p><h3 id="UISlider-进度条"><a href="#UISlider-进度条" class="headerlink" title="UISlider (进度条)"></a>UISlider (进度条)</h3><p><strong>Appearance [添加进度条显示组件]</strong></p><ol><li>Foreground [表层进度条]</li><li>Background [背景进度条]</li><li>Thumb [滑块]</li><li>Direction [进度条方向]</li></ol><h3 id="UIInput-输入框"><a href="#UIInput-输入框" class="headerlink" title="UIInput (输入框)"></a>UIInput (输入框)</h3><p><img src="/2023/04/29/NGUI%E4%BD%BF%E7%94%A8%E6%96%B9%E6%B3%95/v2-9e39aca5c3d80e8929fc2188ee903fcc_720w.webp" alt="img"></p><ul><li>Starting Value [默认输入文字]</li></ul><blockquote><p>默认输入文本和初始化显示文本是两个概念,默认输入的文本是有效文本,初始化显示文本是提示用户输入用的文本</p></blockquote><ul><li>Saved As [设置输入的内容在PlayerPref中哪个字段保存] 这里通常不用设置,它会自动保存</li><li>**KeyboardType [文本输入时键盘类型设定]**： 电话号码、URL、隐藏输入等</li><li>On Submit ：提交输入内容时触发事件函数设定</li><li>OnChange： 当输入内容改变时触发事件函数设定</li><li>Validation [验证输入类型] 只能验证指定输入类型,通过下拉框选择</li></ul><p><strong>一些注意事项：</strong></p><ol><li>输入框Input本身是无法显示文字的，它必须借助于一个 Label 来帮它显示输入的文本，字体、颜色等都与其相关联。如果发生冲突，比如颜色设置那么将会以 Input 中的设置为准。</li><li>输入框必须要有一个 BoxCollider 和一个 Sprite 底框否则无法输入。</li><li>输入框无法显示文字的一些情况:<ul><li>超出最大字符数限定, 或者文字大小超出范围;</li><li>Label所选用的字体库中没有这个文字或者输入的字符不符合要求的验证类型</li></ul></li><li>输入的文字可以从Input 中的 value 变量读取也可以从关联的 Label中的text变量读取。</li><li>请将相关联的 Label 设为输入框的子物体，这样就可以保证输入的文字和底框保持相对位置不变。</li></ol><h3 id="Scroll-View"><a href="#Scroll-View" class="headerlink" title="Scroll View"></a>Scroll View</h3><ul><li><strong>Drag Effect [拖动效果]</strong><ul><li>None [无效果] 视窗拖动到哪里就是哪里</li><li>Momentum [惯性拖动] 松开拖动后会根据惯性动能继续拖动</li><li>MomentumAndSpring [弹性拖动] 内容被拖到边界外时会自动回弹为正常视窗界面</li></ul></li></ul><p><strong>注意事项：</strong><br>(1)通常情况下，滚动视图一定要有一个 UIPanel 来进行窗口剪辑。这个UIPanel组件在创建ScrollView时会自动生成。</p><p>(3)<strong>滚动视图内包含的内容，一定要有一个 BoxCollider和 DragScrollView 组件</strong>，DragScrollView 组件会和ScrollView 相互作用，在运行时，它会自动去找到父物体中的 ScrollView，然后和它相互作用，让视图内的内容可以被滚动起来</p><p>(5)滚动视图的内容，最好放到创建的 Scrollview 节点下面作为子物体存在，这样可以免去大量的烦恼和隐患。</p><p>(7)滚动视图的剪辑窗口的尺寸一定要调整到位，尽量别去调整 clip的Centero</p><h1 id="UI动画"><a href="#UI动画" class="headerlink" title="UI动画"></a>UI动画</h1><h2 id="渐隐渐现动画-透明度动画"><a href="#渐隐渐现动画-透明度动画" class="headerlink" title="渐隐渐现动画 (透明度动画)"></a>渐隐渐现动画 (透明度动画)</h2><p><img src="/2023/04/29/NGUI%E4%BD%BF%E7%94%A8%E6%96%B9%E6%B3%95/v2-a8083694077f2067ea794be249cd7b54_720w.webp" alt="img"></p><p>创建TweenAlpha动画: NGUI 菜单 -&gt; Tween -&gt; Alpha 脚本</p><ul><li><p>From 和 To [开始和结束] Tween动画核心设置,起始点的设置</p></li><li><p><strong>PlayStyle [循环模式]</strong></p></li><li><ul><li>Once [单次播放]</li><li>Loop [循环播放] 播放完毕后,瞬间回到起点重新播放</li><li>PingPong [乒乓模式] 播放完毕后,从终点倒着播放回到起点</li></ul></li><li><p>Animation Curve [动画曲线编辑] 通过编辑曲线可以调整动画播放的快慢</p></li></ul><p><strong>注意点</strong></p><p>(1)从起点播放到终点，就算动画播放完了一遍。但是，在动画结束的触发事件中，我们需要注意的是，如果动画模式是 Loop 或者 PingPong，那么它将永远不会结束。</p><p>(2)透明度动画会实实在在地改变 UI的透明度，并不是一个临时透明度。例如，我们设置了一个透明度从1变为 0的渐渐消失动画，当透明度变化到 0.5时我们就将动画组件关闭，此时 UI 的透明度将会一直停留在 0.5。</p><p>(4)动画组件激活后，它会立即开启 StartDelay 的计时，然后播放动画。</p><p>(5)如果动画播放设定为播放一次，那么动画播放一次之后，就会自动关闭该组</p><h2 id="颜色变化动画-变色动画"><a href="#颜色变化动画-变色动画" class="headerlink" title="颜色变化动画 (变色动画)"></a>颜色变化动画 (变色动画)</h2><p><img src="/2023/04/29/NGUI%E4%BD%BF%E7%94%A8%E6%96%B9%E6%B3%95/v2-4839e178a210b97eee116e8f7cb30e57_720w.webp" alt="img"></p><p>颜色改变原理为UI原色与控件颜色相乘</p><h2 id="动画控制组件-UIPlayTween"><a href="#动画控制组件-UIPlayTween" class="headerlink" title="动画控制组件 (UIPlayTween)"></a>动画控制组件 (UIPlayTween)</h2><p><img src="/2023/04/29/NGUI%E4%BD%BF%E7%94%A8%E6%96%B9%E6%B3%95/16827732611752.png" alt="img"></p><p>UIPlayTween需要接收外部点击事件,所以我们会将它放在带有Collider的组件上</p><h2 id="动画控制组件-UIPlayAnimation"><a href="#动画控制组件-UIPlayAnimation" class="headerlink" title="动画控制组件 (UIPlayAnimation)"></a>动画控制组件 (UIPlayAnimation)</h2><p><img src="/2023/04/29/NGUI%E4%BD%BF%E7%94%A8%E6%96%B9%E6%B3%95/16827732611751.png" alt="img"></p><ul><li>为目标物体添加Animation组件: AddComponent -&gt; Animation 脚本 (注意:这里的Animation并不是UIPlayAnimation)</li><li>为目标物体添加动画: Animation组件 -&gt; Animation选项 -&gt; AnimationClip动画</li><li>为本体添加UIPlayAnimation: NGUI 菜单 -&gt; Attach -&gt; PlayAnimation 脚本</li><li>为本体添加目标物体: 拖动目标物体 -&gt; PlayAnimation脚本 -&gt; Animation选项</li></ul><h1 id="NGUI各组件实现功能"><a href="#NGUI各组件实现功能" class="headerlink" title="NGUI各组件实现功能"></a>NGUI各组件实现功能</h1><h2 id="屏幕适应"><a href="#屏幕适应" class="headerlink" title="屏幕适应"></a>屏幕适应</h2><p>NGUI中Anchors下拉菜单中type选择Unified或Advanced可以自定义UI四个方向上与给定位置保持相同距离，Unified四边选择的是同一transform，andvanced每边可以选择不同tansform作为target<br>Widget菜单中可选择Pivot位置（主要是影响子物体） 以及UI所处层级</p><h1 id="NGUI-相较于-UGUI的区别"><a href="#NGUI-相较于-UGUI的区别" class="headerlink" title="NGUI 相较于 UGUI的区别"></a>NGUI 相较于 UGUI的区别</h1><p>UGUI中UI元素被当作添加了UI组件的GameObject使用，更方便于单个使用。<br>NGUI使用仅有一个脚本挂载的GameObject，更方便控制所有UI元素</p><h2 id="从性能来看，UGUI比NGUI有底层优势"><a href="#从性能来看，UGUI比NGUI有底层优势" class="headerlink" title="从性能来看，UGUI比NGUI有底层优势"></a><strong>从性能来看，UGUI比NGUI有底层优势</strong></h2><p>UGUI的排序及合批逻辑都在C++层处理，采用EventSystem的分发模式，效率更高；</p><h2 id="UI动画-1"><a href="#UI动画-1" class="headerlink" title="UI动画"></a><strong>UI动画</strong></h2><p>NGUI整合了ITween，并将ITween的使用封装成脚本，可以非常方便制作出各种旋转、平移、缩放的效果，易用性很强。</p><p>UGUI官方文档建议是采用Animation System来制作UI动画，但是有个比较明显的缺陷，在UI频繁显隐的时候（Active&#x2F;Inactive），Animator会重新Rebind一次Controller，导致无意义的性能损耗。所以UGUI的动画实现，一般通过整合DoTween来实现。Dotween不存在Animation的反复初始化问题，并且它使用了一些缓存策略，相对于ITween来说，每帧耗时更短，效率更高，产生GC更少</p><h2 id="交互形式"><a href="#交互形式" class="headerlink" title="交互形式"></a>交互形式</h2><p>在NGUI中，默认控件是不参与交互的，除非加上Collider；而在UGUI中，默认控件是参与交互的，除非使用canvas Group组件来禁止交互（可以通过去掉勾选raycast Target来禁止）</p><p>NGUI的交互事件是通过SendMessage来发送消息的，相比较于Delegate的性能，Delegate会快10倍左右。UGUI的交互事件改为通过事件回调机制来发送消息，性能上提升不少，比较直接反馈是scroll view的滑动流畅度。</p><h1 id="NGUI重要类的UML图"><a href="#NGUI重要类的UML图" class="headerlink" title="NGUI重要类的UML图"></a>NGUI重要类的UML图</h1><p><img src="/2023/04/29/NGUI%E4%BD%BF%E7%94%A8%E6%96%B9%E6%B3%95/image-20230429210221355.png" alt="image-20230429210221355"></p>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;基本用法&quot;&gt;&lt;a href=&quot;#基本用法&quot; class=&quot;headerlink&quot; title=&quot;基本用法&quot;&gt;&lt;/a&gt;基本用法&lt;/h1&gt;&lt;p&gt;很多基本模块比如按钮、slider等都能从Prefab中直接拖拽到场景中实现，但都需要有一个Collider（Prefab已经自带）&lt;/p&gt;
&lt;p&gt;因为不仅是UI，所有带有Collider的游戏物体都能接收到OnClick， OnPress这样的事件——前提是需要在Main Camera里面添加上event System组件，然后自定义脚本添加以下函数：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/2023/04/29/NGUI%E4%BD%BF%E7%94%A8%E6%96%B9%E6%B3%95/%E8%8E%89%E8%8E%89%E4%B8%9D%E9%A3%9E%E4%B9%A620230412-142107.jpg&quot; alt=&quot;莉莉丝飞书20230412-142107&quot;&gt;&lt;/p&gt;
&lt;p&gt;如果不想写代码，也可以直接拖拽UIEventTrugger脚本来实现相关功能&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/2023/04/29/NGUI%E4%BD%BF%E7%94%A8%E6%96%B9%E6%B3%95/%E8%8E%89%E8%8E%89%E4%B8%9D%E9%A3%9E%E4%B9%A620230412-143328.jpg&quot; alt=&quot;莉莉丝飞书20230412-143328&quot;&gt;&lt;/p&gt;
&lt;p&gt;与此同时，我们也可以给其中一个事件绑定多个函数，比如滑动条的变更既改变音量大小也能改变滑动条背景颜色。也能在On Finished中指定动作完成后发生的下一动作&lt;/p&gt;</summary>
    
    
    
    
    <category term="Unity" scheme="https://ycy666666.github.io/tags/Unity/"/>
    
  </entry>
  
  <entry>
    <title>ToLua框架学习</title>
    <link href="https://ycy666666.github.io/2023/04/29/ToLua%E6%A1%86%E6%9E%B6%E5%AD%A6%E4%B9%A0/"/>
    <id>https://ycy666666.github.io/2023/04/29/ToLua%E6%A1%86%E6%9E%B6%E5%AD%A6%E4%B9%A0/</id>
    <published>2023-04-29T12:59:26.000Z</published>
    <updated>2023-04-29T13:13:01.143Z</updated>
    
    <content type="html"><![CDATA[<p>ToLua 是一个用于在 Unity 中为 Lua 提供 C# 语言绑定的框架。通过 ToLua，你可以方便地将 C# 代码暴露给 Lua 脚本，并在 Lua 脚本中调用 C# 类、方法和属性。</p><h1 id="更新流程"><a href="#更新流程" class="headerlink" title="更新流程"></a>更新流程</h1><p>原理：使用AssetBundle进行资源的更新，而由于lua运行时才编译的特性，所以lua文件也可以被看成是一种资源文件（与fbx、Image等一样）可以打进ab包中</p><p>流程：</p><p>游戏运行时从服务器下载files.txt清单文件,与本地的files.txt清单文件进行对比。如果新下载的files里面的md5值与本地files的md5值不一样,或者本地清单里没有对应文件，那么就从服务器下载AB包，然后解压进行初始化</p><h1 id="LuaState"><a href="#LuaState" class="headerlink" title="LuaState"></a>LuaState</h1><p>C#能调用lua的原理就是创建了一个lua虚拟机，LuaState封装了对lua 主要数据结构 lua_State 指针的各种堆栈操作。</p><span id="more"></span><h2 id="去反射"><a href="#去反射" class="headerlink" title="去反射"></a>去反射</h2><p>旧版本中lua调用C#函数是基于反射的，而现阶段是基于去反射，意思就是：把所有的c#类的public成员变量、成员函数，都导出到一个相对应的Wrap类中。而这些成员函数通过特殊的标记，映射到lua的虚拟机中，当在lua中调用相对应的函数时候，直接调用映射进去的c# wrap函数，然后再调用到实际的c#类，完成调用过程</p><h3 id="Lua虚拟栈"><a href="#Lua虚拟栈" class="headerlink" title="Lua虚拟栈"></a>Lua虚拟栈</h3><p><img src="/2023/04/29/ToLua%E6%A1%86%E6%9E%B6%E5%AD%A6%E4%B9%A0/16827734664141.png" alt="img"></p><p>C#会告诉虚拟机传入的参数和需要返回的参数，然后虚拟机开始访问栈，从栈中取出对应函数传送给Lua编译器。然后lua程序调用Lua文件全局表（Global table）查找对应函数，然后将返回参数入栈，C#再从栈中读取数据。</p><ol><li>可以按1<del>N的顺序从栈底向上，也可以从-1</del>-N从栈顶向下</li><li>栈中可以存储任何数据，函数、table等，空的位置用nil表示</li></ol><h2 id="前置准备"><a href="#前置准备" class="headerlink" title="前置准备"></a>前置准备</h2><p>使用Tolua的相关类和方法都需要调用命名空间LuaInterface，LuaState.Start 需要在tolua代码加载到内存后调用。如果使用assetbunblde加载lua文件，调用Start()之前assetbundle必须加载好。</p><p>调用lua脚本必须先创建一个lua虚拟机， 一般对于客户端，推荐只创建一个LuaState对象。如果要使用多State需要在Unity中设置全局宏 MULTI_STATE，创建步骤为：</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">LuaState lua = new LuaState();</span><br></pre></td></tr></table></figure><h2 id="加载脚本"><a href="#加载脚本" class="headerlink" title="加载脚本"></a>加载脚本</h2><p>重要方法lua.AddSearchPath ，通过此方法添加lua文件的路径，只有添加了文件路径之后，在该路径上的lua文件才可以被读取。这样DoFile跟Require函数可以只用文件名,无需写全路径。</p><p>在C#中运行一段lua脚本最简单的方法就是lua.DoString，该方法声明如下：</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">public object[] DoString(<span class="built_in">string</span> chunk, <span class="built_in">string</span> chunkName = <span class="string">&quot;LuaState.DoString&quot;</span>)</span><br></pre></td></tr></table></figure><p><strong>注意dofile需要扩展名</strong>, 可反复执行, 后面的变量会覆盖之前的DoFile加载的变量这里加载了就会从开始逐句执行。</p><p>LuaState.Require</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">public void Require(<span class="built_in">string</span> filename)</span><br></pre></td></tr></table></figure><p>因为Require 读取文件是会检查该文件是否被加载过，如果被加载过，则直接返回一个索引，否则则加载并返回一个索引</p><ul><li><p>使用完lua虚拟机之后记得要销毁，具体操作如下：</p></li><li><ul><li>先进行lua虚拟机的判空，具体做法为lua.CheckTop</li><li>析构掉lua虚拟机，具体做法为：lua.Dispose</li></ul></li></ul><h1 id="C-调用lua函数"><a href="#C-调用lua函数" class="headerlink" title="C#调用lua函数"></a>C#调用lua函数</h1><h2 id="调用lua方法"><a href="#调用lua方法" class="headerlink" title="调用lua方法"></a>调用lua方法</h2><p>我们可以把lua中的函数看成一个对象，在虚拟机初始化完成后，加载对应的lua文件，接着需要创建一个LuaFunction类型的对象来表示这个lua函数，可以通过调用：**<code>lua.GetFunction(&quot;方法名&quot;);</code>** 来获取对应的函数对象</p><p>获取了之后就需要在C#中调用了，主要方式有两种：</p><ol><li>直接调用LuaFunction类型的对象的func.Call 方法，完整声明为：</li></ol><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="built_in">object</span>[] <span class="title">Call</span>(<span class="params"><span class="keyword">params</span> <span class="built_in">object</span>[] args</span>)</span></span><br></pre></td></tr></table></figure><p>这种调用方法比较简单，但是有一个缺点，lua对象的内存无法被自动释放，所以当使用完这个lua函数对象之后，我们需要手动的调用LuaFunction类型的对象的func.Dispose();方法，释放掉垃圾内存，否则会造成内存泄漏！</p><p>不过选择都采用的是委托的方式，需要先进行<code>DelegateFactory.Init()；</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">int num = luaFunc.Invoke&lt;int,int&gt;(arg);</span><br></pre></td></tr></table></figure><p>或者是</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Func&lt;<span class="built_in">int</span>, <span class="built_in">int</span>&gt; Func = luaFunc.ToDelegate&lt;Func&lt;<span class="built_in">int</span>, <span class="built_in">int</span>&gt;&gt;();</span><br><span class="line">num = Func(<span class="number">123456</span>);</span><br></pre></td></tr></table></figure><ol><li>如同案例当中的CallFunc()</li></ol><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="built_in">int</span> <span class="title">CallFunc</span>()</span></span><br><span class="line">&#123;        </span><br><span class="line">    luaFunc.BeginPCall();                </span><br><span class="line">    luaFunc.Push(<span class="number">123456</span>);</span><br><span class="line">    luaFunc.PCall();        </span><br><span class="line">    <span class="built_in">int</span> num = (<span class="built_in">int</span>)luaFunc.CheckNumber();</span><br><span class="line">    luaFunc.EndPCall();</span><br><span class="line">    <span class="keyword">return</span> num;                </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先我们必须先以<code>func.BeginPCall;</code>开始，通过<code>func.Push(参数)</code>来给方法传参–通过众多重载函数来解决参数转换的gc，然后需要通过<code>func.PCall();</code>来运行，接着通过对应的<code>func.Checkxxx()</code>方法来获取返回值,最后通过<code>func.EndPCall();</code>结束–清楚函数调用导致的堆栈变化。整个流程比较繁琐且不易封装，不过优点是不会有垃圾内存，所以不用手动释放GC。</p><h2 id="获取lua中的变量"><a href="#获取lua中的变量" class="headerlink" title="获取lua中的变量"></a>获取lua中的变量</h2><h3 id="创建全局变量"><a href="#创建全局变量" class="headerlink" title="创建全局变量"></a>创建全局变量</h3><p>在lua虚拟机创建完成且初始化完毕（调用Start方法）之后，可以直接声明一个lua虚拟机的全局变量:</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">LuaState lua = <span class="keyword">new</span> LuaState();</span><br><span class="line">lua.Start();</span><br><span class="line">lua[<span class="string">&quot;Objs2Spawn&quot;</span>] = <span class="number">5</span>;</span><br></pre></td></tr></table></figure><p>获取全局变量格式是相同的，这点和lua相同，没有就创建否则就读取。值得注意的是对于获取的函数需要强制转换为LuaFunction：<code>LuaFunction func = lua[&quot;TestFunc&quot;] as LuaFunction;</code></p><h3 id="获取与创建lua的table"><a href="#获取与创建lua的table" class="headerlink" title="获取与创建lua的table"></a>获取与创建lua的table</h3><p>通过调用虚拟机的方法lua.GetTable 来获取lua中的table，用LuaTable类型来储存lua中的Table，通过调用Luatable的成员方法table.AddTable来创建lua中的table , 除了通过虚拟机的GetTable方法访问之外，直接通过 LuaTable 型变量按字典的类似方法也可以调用table </p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">LuaTable table1 = lua.GetTable(<span class="string">&quot;varTable&quot;</span>);</span><br><span class="line">Debug.Log(<span class="string">&quot;Read VarTable from lua name:&#123;0&#125;&quot;</span>, table1[map.name]);<span class="comment">//会将map.name作为整体识别为键,值为nil，不会有任何输出</span></span><br><span class="line">table1[<span class="string">&quot;map.name&quot;</span>] = <span class="string">&quot;new&quot;</span>;<span class="comment">// table字符串只能为key,现在为“new”</span></span><br><span class="line">LuaTable table2 = (LuaTable)table[<span class="string">&quot;newmap&quot;</span>];</span><br></pre></td></tr></table></figure><p>对于lua元表也能使用LuaTable的GetMetaTable()方法来获取</p><p>对于变量的获取有一点值得注意：</p><p>如同注释中的那样，[]中的string会作为整体。lua语法中，如果有一个table A，那么A.x代表的是A[“x”],表示的是由字符串 “x”索引的表， 而a[x]表示的是变量x对应的值索引的表</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">a = &#123;&#125;</span><br><span class="line">x = &quot;y&quot;</span><br><span class="line">a[x] = 10</span><br><span class="line">a.x --&gt;nil 字段“x”的值，未定义</span><br><span class="line">a.y --&gt;10, 字段“y”的值</span><br></pre></td></tr></table></figure><p>因此如果想要C#正确获取的话，需要像下面这样：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">LuaTable table = lua.GetTable(<span class="string">&quot;varTable&quot;</span>);</span><br><span class="line">LuaTable map = (LuaTable)table[<span class="string">&quot;map&quot;</span>];</span><br><span class="line">Debugger.Log(<span class="string">&quot;Read varTable from lua,  name: &#123;0&#125;&quot;</span>, map[<span class="string">&quot;name&quot;</span>]);</span><br></pre></td></tr></table></figure><p>对LuaTable类型的变量，在使用完后需要手动释放内存，否则会因为内存未自动释放造成内存泄漏，具体方法为调用LuaTable对象的方法table.Dispose();</p><h2 id="GameObject"><a href="#GameObject" class="headerlink" title="GameObject"></a>GameObject</h2><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="built_in">string</span> script =</span><br><span class="line">    <span class="string">@&quot;                                    </span></span><br><span class="line"><span class="string">        local GameObject = UnityEngine.GameObject          </span></span><br><span class="line"><span class="string">        local ParticleSystem = UnityEngine.ParticleSystem            </span></span><br><span class="line"><span class="string">        local go = GameObject(&#x27;go&#x27;)</span></span><br><span class="line"><span class="string">        go:AddComponent(typeof(ParticleSystem))</span></span><br><span class="line"><span class="string">        local node = go.transform</span></span><br><span class="line"><span class="string">        node.position = Vector3.one      </span></span><br><span class="line"><span class="string">        print(&#x27;gameObject is: &#x27;..tostring(go))    </span></span><br><span class="line"><span class="string">        GameObject.Destroy(go, 2)                        </span></span><br><span class="line"><span class="string">    &quot;</span>;</span><br><span class="line">    </span><br><span class="line">LuaState lua = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Start</span>()</span></span><br><span class="line">&#123;        </span><br><span class="line">    lua = <span class="keyword">new</span> LuaState();</span><br><span class="line">    lua.LogGC = <span class="literal">true</span>;</span><br><span class="line">    lua.Start();</span><br><span class="line">    LuaBinder.Bind(lua);</span><br><span class="line">    lua.DoString(script);            </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Update</span>()</span>&#123;</span><br><span class="line">    lua.CheckTop();</span><br><span class="line">    lua.Collect();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>LuaBinder.Bind();  ——该方法需要传入一个 <code>LuaState</code> 类型参数。该方法会将 C# 代码中定义的类、方法、属性等绑定到该 Lua 模块中。这样，Lua 脚本就可以调用 C# 代码中定义的函数和属性，而 C# 代码也可以通过 Lua 脚本调用 Lua 中的函数和属性。</p><p>lua.Collect();——垃圾回收, 对于被自动gc的LuaFunction, LuaTable, 以及委托减掉的LuaFunction, 延迟删除的Object之类。等等需要延迟处理的回收, 都在这里自动执行</p><h1 id="lua调用C-函数"><a href="#lua调用C-函数" class="headerlink" title="lua调用C#函数"></a>lua调用C#函数</h1><p>如同 案例中的那样，</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">local</span> ParticleSystem = UnityEngine.ParticleSystem</span><br><span class="line"><span class="keyword">local</span> GameObject = UnityEngine.GameObjectlocal </span><br><span class="line">go = GameObject(<span class="string">&#x27;go&#x27;</span>)</span><br><span class="line">go:AddComponent(typeof(ParticleSystem))</span><br><span class="line"><span class="keyword">local</span> node = go.transform</span><br><span class="line">node.position = Vector3.one                  </span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;gameObject is: &#x27;</span>..<span class="built_in">tostring</span>(go))</span><br></pre></td></tr></table></figure><p>对于UnityEngine下的一部分方法，lua中可以直接引用。</p><h2 id="自定义脚本"><a href="#自定义脚本" class="headerlink" title="自定义脚本"></a>自定义脚本</h2><p>对于自己实现的脚本比较麻烦，首先需要调用 LuaBinder.Bind(LuaState lua) </p><p>其次需要将自定义的类写入CustomSetting.cs文件中，你将你的自定义类加入到customTypeList数组中的末尾，如果是静态类就还需加入staticClassTypes中。然后依次点击Lua菜单中的Clear wrap files 和Gen All</p><h2 id="自定义委托"><a href="#自定义委托" class="headerlink" title="自定义委托"></a>自定义委托</h2><p>只要需要使用到delegate字段，都要调用一次DelegateFactory.Init()，如果有自定义的委托还是要添加到CustomSetting.cs中的customDelegateList</p><p>如何给按钮动态添加监听事件？ 首先我们可以定义一个LuaHelper的静态类，在其中实现一个AddButtonClick的静态函数，NGUI中给按钮添加事件代码示例：EventDelegate.Add(UIButton.onclick, Call call)</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">AddButtonClick</span>(<span class="params">GameObject g,LuaFunction callback</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    EventDelegate.Add(g.GetComponent&lt;UIButton&gt;().onClick, callback.Call);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在lua代码中只需找到对应的游戏物体</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">local</span> helper = LuaHelper</span><br><span class="line"><span class="keyword">local</span> btn = UnityEngine.GameObject.Find(<span class="string">&quot;Button&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">local</span> <span class="function"><span class="keyword">function</span> <span class="title">Onclick</span><span class="params">()</span></span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;OnClick&quot;</span>)</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line">helper.AddButtonClick(btn,Onclick)</span><br></pre></td></tr></table></figure><p>Lua调用C#的规范就是不在Start周期函数中去做初始化，而是包装好初始化相关的函数，在lua中获取该函数在调用</p><h2 id="获取C-数组元素"><a href="#获取C-数组元素" class="headerlink" title="获取C#数组元素"></a>获取C#数组元素</h2><p>lua想要访问C#数组有几种方法，</p><ul><li>通过下标访问——这与C#中一致，而且还可以通过array.Length获取数组大小</li><li>通过迭代器访问——array:GetEnumerator()获取数组的迭代器，通过iter.Current获得当前的迭代器所指向的元素值，通过iter:MoveNext()将迭代器所指位置移至下一个</li><li>调用 array:ToTable() 实现将数组对象转化为对应的lua中的Table表的形式进行访问，注意lua数组下标从0开始</li></ul><p>C#中获得lua函数的返回值，可以通过func.Checkxxx()来获得</p><p>比如</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">double</span> arg1 = func.CheckNumber();<span class="comment">//获得func函数double类型的返回值</span></span><br><span class="line"><span class="built_in">string</span> arg2 = func.CheckString();<span class="comment">//获得func函数string类型的返回值</span></span><br><span class="line"><span class="comment">// 调用通用函数时需要转换类型，避免拆成多个参数</span></span><br><span class="line"><span class="built_in">object</span>[] objs = func.Invoke((<span class="built_in">object</span>)array);</span><br><span class="line"><span class="keyword">if</span> (objs != <span class="literal">null</span>)</span><br><span class="line">&#123;</span><br><span class="line">    Debugger.Log(<span class="string">&quot;return is &#123;0&#125; &#123;1&#125; &#123;2&#125;&quot;</span>, objs[<span class="number">0</span>], objs[<span class="number">1</span>], objs[<span class="number">2</span>]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="ToLua框架UML"><a href="#ToLua框架UML" class="headerlink" title="ToLua框架UML"></a>ToLua框架UML</h1><p>LuaState，LuaFunction、LuaTable</p><p>暂时无法在莉莉丝飞书文档外展示此内容</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;ToLua 是一个用于在 Unity 中为 Lua 提供 C# 语言绑定的框架。通过 ToLua，你可以方便地将 C# 代码暴露给 Lua 脚本，并在 Lua 脚本中调用 C# 类、方法和属性。&lt;/p&gt;
&lt;h1 id=&quot;更新流程&quot;&gt;&lt;a href=&quot;#更新流程&quot; class=&quot;headerlink&quot; title=&quot;更新流程&quot;&gt;&lt;/a&gt;更新流程&lt;/h1&gt;&lt;p&gt;原理：使用AssetBundle进行资源的更新，而由于lua运行时才编译的特性，所以lua文件也可以被看成是一种资源文件（与fbx、Image等一样）可以打进ab包中&lt;/p&gt;
&lt;p&gt;流程：&lt;/p&gt;
&lt;p&gt;游戏运行时从服务器下载files.txt清单文件,与本地的files.txt清单文件进行对比。如果新下载的files里面的md5值与本地files的md5值不一样,或者本地清单里没有对应文件，那么就从服务器下载AB包，然后解压进行初始化&lt;/p&gt;
&lt;h1 id=&quot;LuaState&quot;&gt;&lt;a href=&quot;#LuaState&quot; class=&quot;headerlink&quot; title=&quot;LuaState&quot;&gt;&lt;/a&gt;LuaState&lt;/h1&gt;&lt;p&gt;C#能调用lua的原理就是创建了一个lua虚拟机，LuaState封装了对lua 主要数据结构 lua_State 指针的各种堆栈操作。&lt;/p&gt;</summary>
    
    
    
    
    <category term="lua" scheme="https://ycy666666.github.io/tags/lua/"/>
    
  </entry>
  
  <entry>
    <title>CICD中的jenkins和ansible解决方案</title>
    <link href="https://ycy666666.github.io/2023/04/29/CICD%E4%B8%AD%E7%9A%84jenkins%E5%92%8Cansible%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/"/>
    <id>https://ycy666666.github.io/2023/04/29/CICD%E4%B8%AD%E7%9A%84jenkins%E5%92%8Cansible%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/</id>
    <published>2023-04-29T12:59:11.000Z</published>
    <updated>2023-04-29T13:13:10.287Z</updated>
    
    <content type="html"><![CDATA[<p>每一次重装系统或者是需要在服务器上正确运行软件，我们都需要重新安装所有的package、dependency并进行相应配置的微调。而这一过程可能就会因为疏忽导致错误，因此需要自动化部署</p><p>持续整合，持续交付（CI&#x2F;CD）的实践，我们能够周期性的对产品进行各种专业测试，如果出现问题我们也能快速找到发生问题的最近位置。同时我们还能进行报表分析和自动通知等其他操作</p><h1 id="Ansible"><a href="#Ansible" class="headerlink" title="Ansible"></a>Ansible</h1><p>ansible就是这样一款主流的自动化部署工具，要通过ansible在被控节点（managed node）上配置环境，我们需要安装Pyhton然后通过SSH连线。</p><span id="more"></span><h2 id="安装过程"><a href="#安装过程" class="headerlink" title="安装过程"></a>安装过程</h2><p>Ansible当中，所有机器分为以下两类：</p><ul><li>控制主机（Control Machine）： 这类主机能通过Ansible的playbook（剧本）对被控节点进行部署</li><li>被控节点（Managed Machine）：又称Remote Node，这类节点就是我们通过Ansible进行部署的对象</li></ul><p><strong>值得注意的是，Ansible并不用安装在被控主机上，只需要保证能通过SSH与Control Machine沟通就可以了</strong></p><h2 id="playbook"><a href="#playbook" class="headerlink" title="playbook"></a>playbook</h2><p>我们使用playbook，这一由YAML编写的程序，来告诉Ansible需要做什么。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="bullet">-</span> <span class="attr">hosts:</span> <span class="string">server</span></span><br><span class="line">  <span class="attr">tasks:</span></span><br><span class="line">    <span class="comment"># task 1</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">test</span> <span class="string">connection</span></span><br><span class="line">      <span class="attr">ping:</span></span><br><span class="line">      <span class="attr">register:</span> <span class="string">message</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># task 2</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">print</span> <span class="string">debug</span> <span class="string">message</span></span><br><span class="line">      <span class="attr">debug:</span></span><br><span class="line">        <span class="attr">msg:</span> <span class="string">&quot;<span class="template-variable">&#123;&#123; message &#125;&#125;</span>&quot;</span></span><br></pre></td></tr></table></figure><p>task1中，调用了ansible内置模块-ping，用于测试控制主机能否与被控节点连线。如果正常，会回传“pong”信息，然后我们能通过register将被控主机回传的消息存贮在message变量中</p><p>task2中，利用debug方法将message输出到终端上</p><h3 id="如何运行playbook"><a href="#如何运行playbook" class="headerlink" title="如何运行playbook"></a>如何运行playbook</h3><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ansible<span class="literal">-playbook</span> playbook.yml</span><br></pre></td></tr></table></figure><p>但是这样ansible并不会做任何task，因为ansible应该对hosts指定的server来执行task。但是我们并没有告诉ansible哪一台是server，因此需要一个inventory来让ansible参考，具体编写需要先在ansible的config中指定inventory路径。</p><p>但是呢，不同的部署环境（比如test、development、producting）需要不同的配置细节，因此我们就可以定义多个inventory file，然后通过以下指令来实现部署</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$</span> ansible<span class="literal">-playbook</span> <span class="literal">-i</span> devl<span class="literal">-inventory</span> devl<span class="literal">-playbook</span>.yml</span><br><span class="line"><span class="variable">$</span> ansible<span class="literal">-playbook</span> <span class="literal">-i</span> prod<span class="literal">-inventory</span> prod<span class="literal">-playbook</span>.yml</span><br></pre></td></tr></table></figure><p>当然也可以写在同一文件中使用[]标识</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">[<span class="string">test</span>]</span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span> <span class="string">ansible_port=2222</span> <span class="string">ansible_user=test_user</span></span><br><span class="line"></span><br><span class="line">[<span class="string">test:vars</span>]</span><br><span class="line"><span class="string">email_receivers=test@gmail.com</span></span><br><span class="line"></span><br><span class="line">[<span class="string">devl</span>]</span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span> <span class="string">ansible_port=2222</span> <span class="string">ansible_user=devl_user</span></span><br><span class="line"></span><br><span class="line">[<span class="string">devl:vars</span>]</span><br><span class="line"><span class="string">email_receivers=devl@gmail.com</span></span><br></pre></td></tr></table></figure><h2 id="Ansible-Role"><a href="#Ansible-Role" class="headerlink" title="Ansible Role"></a>Ansible Role</h2><p>我们可以通过自定义的role来使playbook重复使用，以此来是一部分部署资源能被重复使用</p><p>Ansible会在下列路径寻找可执行roles：</p><ol><li>与playbook同一层额roles文件夹</li><li>&#x2F;etc&#x2F;ansible&#x2F;roles</li></ol><p>例如</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">workspace</span><br><span class="line">├── inventory</span><br><span class="line">├── playbook.yml</span><br><span class="line">└── roles</span><br><span class="line">    └── pip</span><br><span class="line">        └── tasks</span><br><span class="line">            └── main.yml</span><br></pre></td></tr></table></figure><p>表示pip是第一个role的名称，然后工作流程定义在tasks&#x2F;main.yml中</p><p>playbook中改为以下内容</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">---</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">hosts:</span> <span class="string">server</span></span><br><span class="line">    <span class="attr">roles:</span></span><br><span class="line">      <span class="bullet">-</span> &#123; <span class="attr">role:</span> <span class="string">pip</span>, <span class="attr">become:</span> <span class="literal">yes</span> &#125;</span><br></pre></td></tr></table></figure><h1 id="Jenkins"><a href="#Jenkins" class="headerlink" title="Jenkins"></a>Jenkins</h1><p>当前安装Jenkins的方法有许多，其中一种比较好的是利用docker来进行。因为容器本身比较轻量，资源远少于启动虚拟机；而且容器之间资源相互隔离，不存在相互污染。</p><h2 id="Jenkins-Job"><a href="#Jenkins-Job" class="headerlink" title="Jenkins Job"></a>Jenkins Job</h2><p>Job（任务）是构建持续集成流程的基本单元，Job 可以包括多个构建步骤，例如源码管理、构建、测试和发布等。</p><p>Job 的用途主要包括以下几个方面：</p><ol><li>构建持续集成流程：通过 Job，可以将代码拉取、构建、测试和部署等步骤串联起来，从而构建出一个完整的持续集成流程。这样可以实现快速、自动化的构建和部署，提高软件开发的效率和质量。</li><li>自动化测试：Job 中可以包含自动化测试步骤，例如单元测试、集成测试和端到端测试等。自动化测试可以在构建过程中自动运行，从而及早发现代码错误，减少测试成本和时间。</li><li>构建报告和通知：Job 运行后，可以生成各种构建报告，例如测试报告、代码覆盖率报告和构建日志等。同时，Jenkins 还支持各种通知方式在构建失败或成功后通知相关人员。</li><li>构建流水线：多个 Job 可以通过 Jenkins 提供的 Pipeline 功能串联起来，形成一个完整的构建流水线，实现多个 Job 的协同工作</li></ol>]]></content>
    
    
    <summary type="html">&lt;p&gt;每一次重装系统或者是需要在服务器上正确运行软件，我们都需要重新安装所有的package、dependency并进行相应配置的微调。而这一过程可能就会因为疏忽导致错误，因此需要自动化部署&lt;/p&gt;
&lt;p&gt;持续整合，持续交付（CI&amp;#x2F;CD）的实践，我们能够周期性的对产品进行各种专业测试，如果出现问题我们也能快速找到发生问题的最近位置。同时我们还能进行报表分析和自动通知等其他操作&lt;/p&gt;
&lt;h1 id=&quot;Ansible&quot;&gt;&lt;a href=&quot;#Ansible&quot; class=&quot;headerlink&quot; title=&quot;Ansible&quot;&gt;&lt;/a&gt;Ansible&lt;/h1&gt;&lt;p&gt;ansible就是这样一款主流的自动化部署工具，要通过ansible在被控节点（managed node）上配置环境，我们需要安装Pyhton然后通过SSH连线。&lt;/p&gt;</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>Unity打包流程</title>
    <link href="https://ycy666666.github.io/2023/04/29/Unity%E6%89%93%E5%8C%85%E6%B5%81%E7%A8%8B/"/>
    <id>https://ycy666666.github.io/2023/04/29/Unity%E6%89%93%E5%8C%85%E6%B5%81%E7%A8%8B/</id>
    <published>2023-04-29T12:58:43.000Z</published>
    <updated>2023-04-29T13:13:25.425Z</updated>
    
    <content type="html"><![CDATA[<h1 id="一般打包流程"><a href="#一般打包流程" class="headerlink" title="一般打包流程"></a><strong>一般打包流程</strong></h1><p>通常打包流程主要是通过 <code>Building setting</code>来选择需要打包的场景后出包到指定文件夹位置，也可以采用 <code>[MenuItem(&quot;MyMenu/Do Something&quot;)]</code>中使用static函数来选择打包路径和打包方式——需要将该脚本放置在 <code>Editor</code>文件夹下</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[<span class="meta">MenuItem(<span class="string">&quot;Test/BuildAndroid&quot;</span>)</span>]</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">BuildAndroid</span>()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">string</span> path = Path.GetFullPath(<span class="string">&quot;D:\\Packages&quot;</span>) + <span class="string">&quot;/Backbag&quot;</span> + <span class="string">&quot;.apk&quot;</span>;</span><br><span class="line">    BuildPipeline.BuildPlayer(GetBuildScence(), path, BuildTarget.Android, BuildOptions.None);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="命令行控制"><a href="#命令行控制" class="headerlink" title="命令行控制"></a><strong>命令行控制</strong></h2><ol><li>Launching Unity</li><li>首先我们需要在<code>Unity.exe</code>所在目录下执行</li><li>选择对应Option</li></ol><span id="more"></span><h3 id="命令语句解释"><a href="#命令语句解释" class="headerlink" title="命令语句解释"></a><strong>命令语句解释</strong></h3><table><thead><tr><th>命令语句</th><th>解释</th></tr></thead><tbody><tr><td>-batchmode</td><td>以批处理模式运行 Unity。在批处理模式下，Unity 无需人为操作即可运行命令行参数。它还抑制了部分弹出窗口（例如“保存场景”窗口）；但是，Unity 编辑器本身会照常打开。使用命令行参数时，您应该始终以批处理模式运行 Unity，因为它允许自动化不间断地运行</td></tr><tr><td>-quit</td><td>其他命令执行完毕后将退出Unity编辑器。但会导致错误消息被隐藏（显示在Editor.log文件）</td></tr><tr><td>-executeMethod &lt;ClassName.MethodName&gt;</td><td>Unity 打开项目后立即执行静态方法，并在可选的资产服务器更新完成后执行。执行方法所在脚本必须在Editor文件中而且是static的。要从命令行进程返回错误，要么抛出异常导致 Unity 退出并返回代码 1，要么调用 EditorApplication.Exit 并返回非零代码</td></tr></tbody></table><p>此外Unity Standalone Player平台中也能执行一些参数（官方文档中指Mac、Windows和Linux）</p><p>要在从命令行以批处理模式启动输入 <code>PATH_TO_STANDALONE_BUILD -projectPath PROJECT_PATH -batchMode</code></p><p>比如 <code>C:\projects\myproject\builds\myproject.exe </code><strong><code>-batchMode</code></strong></p><table><thead><tr><th>命令语句</th><th>解释</th></tr></thead><tbody><tr><td>-batchmode</td><td>在”headless”模式下运行游戏。游戏将不显示任何内容，或接受用户输入。主要作用于网络游戏的服务器</td></tr><tr><td>-single-instance (Linux and Windows only)</td><td>同一时候只允许一个游戏实例运行。如果另一个实例已在运行，然后再次通过 -single-instance启动它的话会调节到现有的这个实例</td></tr><tr><td>-force-(…)</td><td>强制性的使用规定的渲染方式（DirectX 、Metal、OpenGL等 ）</td></tr><tr><td>-screen-(…)</td><td>重新规定屏幕的大小或者是出现方式（弹窗或全屏）</td></tr></tbody></table><h1 id="Player-Setting——PC"><a href="#Player-Setting——PC" class="headerlink" title="Player Setting——PC"></a><strong>Player Setting——PC</strong></h1><p>Player Settings提供了各种选项来帮助你完成最终游戏的出包，虽然说有很多不同的平台，但是大体上的设置会分为以下几个部分</p><h2 id="Icon"><a href="#Icon" class="headerlink" title="Icon"></a><strong>Icon</strong></h2><p>图标，在桌面上显示的默认图标</p><h2 id="Resolution-and-Presentation"><a href="#Resolution-and-Presentation" class="headerlink" title="Resolution and Presentation"></a><strong>Resolution and Presentation</strong></h2><p>分辨率和启动前窗口设置，包括了支持的分辨率比例和是否默认全屏启动等选项；</p><h3 id="Resolution"><a href="#Resolution" class="headerlink" title="Resolution"></a><strong>Resolution</strong></h3><p><img src="/2023/04/29/Unity%E6%89%93%E5%8C%85%E6%B5%81%E7%A8%8B/168277357919210.png" alt="img"></p><ul><li>Fullscreen Mode ： 选择默认窗口模式</li><li><strong>Default Is Native Resolution</strong> ： 是游戏以默认的分辨率启动，取消勾选后可以强制游戏的分辨率。但是有一点，如果你的游戏已经打包启动过了，那下次再打包强制分辨率就没有意义了，因为Windows会将该应用最后的分辨率记录到注册表中。此时有三种解决方案：</li><li>1.改变应用的名称或公司；</li><li>2.在代码中直接控制分辨率；</li><li>3.使用Unity自带的启动前分辨率设置小窗口。</li><li>Mac Retina Support：可以使游戏在Mac高DPI的屏幕上显示的更加清晰，但是可能会占用更多的资源；</li><li><strong>Run in background</strong>：在游戏失去焦点时仍旧继续运行不会暂停，联网游戏肯定要勾选；</li></ul><h3 id="Standalone-Player-Options"><a href="#Standalone-Player-Options" class="headerlink" title="Standalone Player Options"></a><strong>Standalone Player Options</strong></h3><p><img src="/2023/04/29/Unity%E6%89%93%E5%8C%85%E6%B5%81%E7%A8%8B/16827735791901.png" alt="img"></p><p>此部分允许指定用户如何自定义屏幕。 例如可以在此处确定用户是否可以调整屏幕大小以及可以并发运行多少个实例。</p><ul><li>Capture Single Screen: 启用此选项可确保全屏模式下的独立游戏不会使多显示器设置中的辅助显示器变暗。</li><li><strong>Use Player Log</strong>:  将所有Debug.Log的信息输入到一个log文件中，默认勾选</li><li>Resizable Window: 允许玩家可以重新调整游戏窗口的大小；</li><li>Visible in Background:  即使在后台任然能正常显示</li><li><strong>Force Single Instance</strong> ： 一台主机只能由一个运行实例</li><li>Supported Aspect Ratios： 支持的纵横比</li></ul><h2 id="Splash-Image"><a href="#Splash-Image" class="headerlink" title="Splash Image"></a><strong>Splash Image</strong></h2><p>初始图象，设置允许为独立平台指定启动图像</p><p><img src="/2023/04/29/Unity%E6%89%93%E5%8C%85%E6%B5%81%E7%A8%8B/16827735791912.png" alt="img"></p><h2 id="Other-Setting"><a href="#Other-Setting" class="headerlink" title="Other Setting"></a><strong>Other Setting</strong></h2><h3 id="Rendering"><a href="#Rendering" class="headerlink" title="Rendering"></a><strong>Rendering</strong></h3><p><img src="/2023/04/29/Unity%E6%89%93%E5%8C%85%E6%B5%81%E7%A8%8B/16827735791913.png" alt="img"></p><ul><li><strong>Color Space：</strong>颜色空间，很重要的选项，手机上只能选择Gamma，而一般3A大作都是Linear，Linear显示效果更加真实</li><li>Auto Graphics API for Windows&#x2F; Mac&#x2F; Linux:  自动选择最佳的图形API，如果不勾选，可以自行添加支持的图形API</li><li><strong>Static Batching</strong>:  静态批处理。——将静态（非移动）游戏对象组合成大网格，并以更快的方式渲染它们</li><li><strong>Dynamic Batching</strong>：动态批处理，自动化Unity进程，一次性批量化渲染多个网络以优化图形性能，该技术转换 CPU 上的所有 GameObject 顶点并将许多相似的顶点组合在一起。 （当可编程渲染管线处于活动状态时，动态批处理没有效果）</li><li>GPU Skinning &#x2F; Compute Skinning : 使用GPU处理骨骼与皮肤联系的过程,释放CPU资源</li><li><strong>Graphics Jobs</strong> ： 可以使游戏将一些渲染任务交给其他CPU核心进行处理，增加游戏的处理效率</li><li>Frame Timing Stats： 帧时序状态。启用此属性以收集 CPU 和 GPU 帧时间统计信息。 将其与动态分辨率相机设置一起使用以确定您的应用程序是 CPU 还是 GPU 受限。</li></ul><h3 id="Configuration（配置）"><a href="#Configuration（配置）" class="headerlink" title="Configuration（配置）"></a><strong>Configuration（配置）</strong></h3><p><img src="/2023/04/29/Unity%E6%89%93%E5%8C%85%E6%B5%81%E7%A8%8B/16827735791914.png" alt="img"></p><ul><li><strong>Scripting Backend</strong>： 选择项目中编译和执行 C# 代码的方式。Unity 根据目标平台支持三种不同的脚本后端：Mono、.NET 和 IL2CPP。 通用 Windows 平台仅支持两种：.NET 和 IL2CPP。<ul><li><em>Mono</em>： 将 C# 代码编译成 .NET 通用中间语言 (CIL) 并使用通用语言运行时执行该 CIL</li><li><em>IL2CPP</em>： 将 C# 代码编译为 CIL，将 CIL 转换为 C++，然后将 C++ 编译为本机代码，在运行时直接执行。</li></ul></li><li><strong>API</strong> <strong>Compatibility Level</strong>： 选择在项目中使用的 .NET API。 此设置会影响第三方库的兼容性。</li><li>Use incremental GC：使用增量垃圾收集器，它将垃圾收集分布在多个帧上，以减少与 gc 相关的帧持续时间峰值。</li></ul><h3 id="Script-Compilation"><a href="#Script-Compilation" class="headerlink" title="Script Compilation"></a><strong>Script Compilation</strong></h3><p><img src="/2023/04/29/Unity%E6%89%93%E5%8C%85%E6%B5%81%E7%A8%8B/16827735791915.png" alt="img"></p><ul><li>Allow ‘unsafe’ Code： 启用对在预定义程序集中编译“不安全”C# 代码的支持（例如，Assembly-CSharp.dll）。</li><li><strong>Use Deterministic Compilation</strong>： 禁用此设置以防止使用 -deterministic C# 标志进行编译。 启用此设置后，编译后的程序集在每次编译时都是逐字节相同的。</li></ul><p>以及一部分涉及到Roslyn Analyzers的选项，它可以静态地分析代码，并在代码中检测到潜在的错误、漏洞和优化机会</p><h4 id="Scripting-Define-Symbols"><a href="#Scripting-Define-Symbols" class="headerlink" title="Scripting Define Symbols"></a><strong>Scripting Define Symbols</strong></h4><p>脚本编译时的标志设置，能够根据定义在编译阶段包含或者剔除一些代码，示例代码：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">if</span> UNITY_STANDALONE_WIN</span></span><br><span class="line"></span><br><span class="line">  Debug.Log(<span class="string">&quot;Standalone Windows&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure><p><strong>Platform scripting symbols</strong>：（平台标识）</p><table><thead><tr><th>定义</th><th>含义</th></tr></thead><tbody><tr><td>UNITY_EDITOR</td><td>用于从游戏脚本调用Editor下的符号</td></tr><tr><td>UNITY_EDITOR_XXX</td><td>在XXX平台上的Editor时编译&#x2F;执行代码</td></tr><tr><td>UNITY_STANDALONE</td><td>在任意独立平台（Mac OS X, Windows or Linux）上的应用中编译&#x2F;执行的代码</td></tr><tr><td>UNITY_STANDALONE_XXX</td><td>在XXX平台上的应用中编译&#x2F;执行的代码</td></tr><tr><td>UNITY_XXX</td><td>在XXX平台（除了独立平台外）上的编译&#x2F;执行的代码</td></tr></tbody></table><p><strong>Editor version Scripting symbols</strong>：（引擎版本标识）</p><p>可选择unity版本号，可具体到X_Y_Z任意版本</p><table><thead><tr><th>UNITY_2019</th><th>Unity2019版本，包括2019.Y.Z等所有版本</th></tr></thead><tbody><tr><td>UNITY_2019_4</td><td>Unity2019.4版本，包括2019.4.Z等所有版本</td></tr><tr><td>UNITY_2019_4_14</td><td>Unity2019.4.14版本</td></tr></tbody></table><p><strong>其余标识</strong>：</p><table><thead><tr><th>定义</th><th>含义</th></tr></thead><tbody><tr><td>CSHARP_7_3_OR_NEWER</td><td>支持 C# 7.3 及以上版本</td></tr><tr><td>ENABLE_MONO</td><td>编译方式为Mono.</td></tr><tr><td>ENABLE_IL2CPP</td><td>S编译方式为IL2CPP .</td></tr><tr><td>NET_X_Y</td><td>在Mono和IL2CPP上针对Net对应版本API兼容性生成脚本</td></tr><tr><td>UNITY_SERVER</td><td>在Build Setting勾选Server Build选项</td></tr></tbody></table><h3 id="Optimization-（优化）"><a href="#Optimization-（优化）" class="headerlink" title="Optimization （优化）"></a><strong>Optimization （优化）</strong></h3><p><img src="/2023/04/29/Unity%E6%89%93%E5%8C%85%E6%B5%81%E7%A8%8B/16827735791916.png" alt="img"></p><ul><li><strong>Prebake Collision Meshes</strong>：只在build游戏时添加碰撞盒；</li><li>Keep Loaded Shaders Alive：保证Shader不会被卸载；</li><li><strong>Preloader Assets</strong>：预先读取的Assets列表；</li><li><strong>Managed Stripping Level</strong>： 决定Unity剥离未使用的托管代码的程度。这会使生成的可执行文件变小，但可能导致错误移除实际上使用的代码</li><li><strong>Vertex Compression</strong>： 顶点压缩，选择模型会压缩的数据，比如可以选择everything，然后去掉positions和lightmap UVs。当然每个模型在导入时，该参数可以设置独立，会覆盖掉该选项</li><li>Optimize Mesh Data： 优化Mesh数据，勾选该选项会移除材质所不需要的Mesh数据，例如tangents、normals、colors、UV。</li></ul><h3 id="Logging"><a href="#Logging" class="headerlink" title="Logging"></a><strong>Logging</strong></h3><p><img src="/2023/04/29/Unity%E6%89%93%E5%8C%85%E6%B5%81%E7%A8%8B/16827735791917.png" alt="img"></p><p>可以选择在运行脚本（ScriptOnly）、任何时候（Full）或者是从不（None）的时间选择记录类型</p><h1 id="Player-Setting——Android"><a href="#Player-Setting——Android" class="headerlink" title="Player Setting——Android"></a><strong>Player Setting——Android</strong></h1><p>大多数比较类似，只介绍重要的差异部分</p><h2 id="Resolution-and-Presentation-1"><a href="#Resolution-and-Presentation-1" class="headerlink" title="Resolution and Presentation"></a><strong>Resolution and Presentation</strong></h2><h3 id="Orientation"><a href="#Orientation" class="headerlink" title="Orientation"></a><strong>Orientation</strong></h3><p>方向， 自定义与设备上应用程序方向相关的设置。</p><p><img src="/2023/04/29/Unity%E6%89%93%E5%8C%85%E6%B5%81%E7%A8%8B/16827735791918.png" alt="img"></p><table><thead><tr><th>Setting</th><th>Description</th></tr></thead><tbody><tr><td>Portrait</td><td>纵向，底部与设备顶部对齐</td></tr><tr><td>Portrait Upside Down</td><td>纵向，底部与设备底部对齐</td></tr><tr><td>Landscape Right</td><td>横向，左侧与设备顶部对齐</td></tr><tr><td>Landscape Left</td><td>横向，右侧与设备顶部对齐</td></tr><tr><td>Auto Rotation</td><td>屏幕可以旋转到您在“Allowed Orientations for Auto Rotation”部分中指定的任何方向。</td></tr></tbody></table><h2 id="Other-Setting-1"><a href="#Other-Setting-1" class="headerlink" title="Other Setting"></a><strong>Other Setting</strong></h2><h3 id="Identification"><a href="#Identification" class="headerlink" title="Identification"></a><strong>Identification</strong></h3><p><img src="/2023/04/29/Unity%E6%89%93%E5%8C%85%E6%B5%81%E7%A8%8B/16827735791919.png" alt="img"></p><table><thead><tr><th>Property</th><th>Function</th></tr></thead><tbody><tr><td>Override Default Package Name</td><td>表示是否替换掉应用的默认包名——同样会影响macOS，IOS和Android</td></tr><tr><td>Package Name</td><td>设置应用程序 ID，它可以在设备和 Google Play 商店中唯一标识您的应用程序。 应用程序 ID 必须遵循约定 com.YourCompanyName.YourProductName 并且必须仅包含字母数字和下划线字符。 每个段必须以字母字符开头。</td></tr><tr><td>Version</td><td>输入捆绑包的构建版本号，它标识捆绑包的迭代（已发布或未发布） 版本，以包含由点分隔的数字的字符串的通用格式指定（例如，4.3.2）( iOS 和Android共享)</td></tr><tr><td>Bundle Version Code</td><td>内部版本号，只用于比较哪个版本更新（数字大表示最新）,并不展示给用户。可以见x.y转换为整数或者是每次发布版本简单的加1</td></tr></tbody></table>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;一般打包流程&quot;&gt;&lt;a href=&quot;#一般打包流程&quot; class=&quot;headerlink&quot; title=&quot;一般打包流程&quot;&gt;&lt;/a&gt;&lt;strong&gt;一般打包流程&lt;/strong&gt;&lt;/h1&gt;&lt;p&gt;通常打包流程主要是通过 &lt;code&gt;Building setting&lt;/code&gt;来选择需要打包的场景后出包到指定文件夹位置，也可以采用 &lt;code&gt;[MenuItem(&amp;quot;MyMenu/Do Something&amp;quot;)]&lt;/code&gt;中使用static函数来选择打包路径和打包方式——需要将该脚本放置在 &lt;code&gt;Editor&lt;/code&gt;文件夹下&lt;/p&gt;
&lt;figure class=&quot;highlight c#&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;[&lt;span class=&quot;meta&quot;&gt;MenuItem(&lt;span class=&quot;string&quot;&gt;&amp;quot;Test/BuildAndroid&amp;quot;&lt;/span&gt;)&lt;/span&gt;]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;BuildAndroid&lt;/span&gt;()&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;built_in&quot;&gt;string&lt;/span&gt; path = Path.GetFullPath(&lt;span class=&quot;string&quot;&gt;&amp;quot;D:\\Packages&amp;quot;&lt;/span&gt;) + &lt;span class=&quot;string&quot;&gt;&amp;quot;/Backbag&amp;quot;&lt;/span&gt; + &lt;span class=&quot;string&quot;&gt;&amp;quot;.apk&amp;quot;&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    BuildPipeline.BuildPlayer(GetBuildScence(), path, BuildTarget.Android, BuildOptions.None);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;h2 id=&quot;命令行控制&quot;&gt;&lt;a href=&quot;#命令行控制&quot; class=&quot;headerlink&quot; title=&quot;命令行控制&quot;&gt;&lt;/a&gt;&lt;strong&gt;命令行控制&lt;/strong&gt;&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;Launching Unity&lt;/li&gt;
&lt;li&gt;首先我们需要在&lt;code&gt;Unity.exe&lt;/code&gt;所在目录下执行&lt;/li&gt;
&lt;li&gt;选择对应Option&lt;/li&gt;
&lt;/ol&gt;</summary>
    
    
    
    
    <category term="Unity" scheme="https://ycy666666.github.io/tags/Unity/"/>
    
  </entry>
  
  <entry>
    <title>帧同步和状态同步</title>
    <link href="https://ycy666666.github.io/2023/01/09/%E5%B8%A7%E5%90%8C%E6%AD%A5%E5%92%8C%E7%8A%B6%E6%80%81%E5%90%8C%E6%AD%A5/"/>
    <id>https://ycy666666.github.io/2023/01/09/%E5%B8%A7%E5%90%8C%E6%AD%A5%E5%92%8C%E7%8A%B6%E6%80%81%E5%90%8C%E6%AD%A5/</id>
    <published>2023-01-09T11:22:52.000Z</published>
    <updated>2023-07-24T15:08:02.671Z</updated>
    
    <content type="html"><![CDATA[<h1 id="网络同步"><a href="#网络同步" class="headerlink" title="网络同步"></a>网络同步</h1><p>网络同步主要目的在于保证各个端口的游戏表现一致，<strong>网络同步就在于实时的多段数据同步和实时的多端表现。</strong></p><p>而对于大多数游戏，不仅客户端的表现要一致，而且需要客户端和服务端的数据是一致的。所以，同步是一个网络游戏概念，只有网络游戏才需要同步，而单机游戏是不需要同步的。</p><h2 id="同步目的"><a href="#同步目的" class="headerlink" title="同步目的"></a>同步目的</h2><p>首先我们慢慢说明如何实现简单的坐标同步</p><p>很多时候我们都在讨论 “该用帧同步还是状态同步”，似乎这已经变成了一个二选一的问题。 但事实上，帧同步和状态同步不但 <strong>不是</strong> 二选一的关系，甚至可以 <strong>相互替代</strong> 和 <strong>混合使用</strong>。</p><p>因为，<strong>帧同步和状态同步最终都是同步状态。</strong></p><span id="more"></span><p>假设我们要实现一堆人在一个房间里跑，无论你用状态同步 —— 直接发送你的坐标，或是帧同步 —— 发送移动操作再由客户端计算出最终坐标，对于表现层组件而言，需要的都是你的最终状态 —— 位置坐标。 所以实际上帧同步和状态同步更多讨论的是，网络传输什么，状态在哪里计算 —— 看起来更像一个成本问题。</p><h1 id="同步策略"><a href="#同步策略" class="headerlink" title="同步策略"></a>同步策略</h1><p>–&gt;<a href="https://juejin.cn/post/7041560950897377293#comment">下述材料借鉴自这里</a>–&lt;</p><h2 id="无优化策略"><a href="#无优化策略" class="headerlink" title="无优化策略"></a>无优化策略</h2><ol><li>本地按下按键，发出操作指令。</li><li>指令发送给服务器，服务器得到最新状态，并广播给所有人。<ul><li>帧同步广播操作指令，状态同步广播结果</li></ul></li><li>前端收到服务器的发送来的新状态后，刷新界面显示</li></ol><p><img src="/2023/01/09/%E5%B8%A7%E5%90%8C%E6%AD%A5%E5%92%8C%E7%8A%B6%E6%80%81%E5%90%8C%E6%AD%A5/0c69b560fed3480f95d36ad74dae4248tplv-k3u1fbpfcp-zoom-in-crop-mark1512000.webp" alt="img"></p><p>按下左&#x2F;右按键后，需要等待服务器返回，导致操作延迟。而且逻辑帧率（每秒 3 次）慢于显示帧率（每秒 60 帧）导致画面卡顿</p><h2 id="逻辑与表现分离"><a href="#逻辑与表现分离" class="headerlink" title="逻辑与表现分离"></a>逻辑与表现分离</h2><p>多人实时游戏，通常会划分为表现层和逻辑层。 <strong>表现层指游戏画面的显示和用户输入的获取； 逻辑层指渲染无关的、只关注状态变化和计算的玩法逻辑。</strong>因此我们就能通过预测、和解、插值来消除卡顿和操作延迟</p><p>逻辑层和表现层最终是面向数据的，例如玩家的位置、生命值等，我们把这些数据统称为 <strong>状态</strong>。 我们把所有能影响状态变化的因素称为 <strong>输入</strong>，例如玩家操作（如移动）、系统事件（如被击中）、时间流逝等等</p><p>在实现逻辑层的过程中，有几个重要的点需要关注：</p><ul><li><strong>无输入，不变化</strong>：状态变更仅发生在输入时刻，没有输入时状态不会改变</li><li><strong>无外部依赖</strong>：状态计算应该没有任何外部依赖，例如 <code>Date.now()</code>、<code>Math.random()</code> 等，所有这些都应该显式成为输入的一部分</li><li><strong>结果的一致性</strong>：在相同的状态和输入下，得到的新状态应该是一致的</li></ul><h3 id="预测"><a href="#预测" class="headerlink" title="预测"></a>预测</h3><p><strong>预测就是将玩家的输入立即应用到本地状态，而无需等待服务端返回。</strong></p><p>解决方案就是：玩家做出任何操作后，立刻将输入应用到本地状态，并刷新表现层显示。 例如按下了 “右”，那么就立即向右移动，而无需等待服务端返回，效果如图：</p><p><img src="/2023/01/09/%E5%B8%A7%E5%90%8C%E6%AD%A5%E5%92%8C%E7%8A%B6%E6%80%81%E5%90%8C%E6%AD%A5/f71f9d5295b246d987fbf135af9f2634tplv-k3u1fbpfcp-zoom-in-crop-mark1512000-16902081786267.webp" alt="img"></p><p>但在移动过程中会接收来自服务端的同步，而服务端发来的状态总是滞后的，会导致抽搐。<strong>服务端同步过来的状态与本地预测的状态不一致，所以我们需要 “和解” 它们。</strong></p><h3 id="和解"><a href="#和解" class="headerlink" title="和解"></a>和解</h3><p><strong>和解：预测状态 &#x3D; 权威状态 + 预测输入</strong></p><p>我们认为服务器总是权威的，从服务端接收到的输入称为 <strong>权威输入</strong>，经权威输入计算出来的状态称为 <strong>权威状态</strong>。 同样的，当我们发出一个输入，但尚未得到服务端的返回确认时，这个输入称为非权威输入，也叫 <strong>预测输入</strong>。</p><blockquote><p>在前述预测的基础上，和解就是我们处理服务端同步的状态的方式。如果使用的是状态同步，那么这个过程是：</p><ol><li>收到服务端同步来的 <strong>权威状态</strong></li><li>将本地状态立即设为此权威状态</li><li>在权威状态的基础上，应用当前所有 <strong>预测输入</strong></li></ol><p>如果使用的是帧同步，那么这个过程是：</p><ol><li>收到服务端同步来的<strong>权威输入</strong></li><li>将本地状态立即 <strong>回滚</strong> 至 <strong>上一次的权威状态</strong></li><li>将权威输入应用到当前状态，得到此次的 <strong>权威状态</strong></li><li>在权威状态的基础上，应用当前所有 <strong>预测输入</strong></li></ol><p>由此可见，状态同步和帧同步只是网络传输的内容不同，但它们是完全可以相互替代的 —— 最终目的都是为了同步权威状态。</p></blockquote><p>在没有冲突时，网络延迟可以完全不影响操作延迟，如果不发生冲突（例如与它人碰撞），即便网络延迟有 10 秒，你也可以毫无延迟并且平滑的移动</p><h3 id="冲突"><a href="#冲突" class="headerlink" title="冲突"></a>冲突</h3><p>如果发生了冲突，比如，你发送了 4 次移动指令，但在服务端，第 2 次移动指令之后，服务端收到了另一个客户端的输入—— “你被眩晕了”。这意味着你的后两次移动指令将不会生效，详细过程如下：</p><blockquote><p>你的坐标是 <code>(0,0)</code></p><p>你发出了 2 个 <code>右移</code> 指令（每次向右移动 1 个单位），服务器尚未返回</p><ul><li>权威状态：<code>(0,0)</code></li><li>预测输入：<code>右移#1</code> <code>右移#2</code></li><li>预测状态：<code>(2,0)</code></li></ul><p>你又发出了 2 个 <code>右移</code> 指令，服务器尚未返回</p><ul><li>权威状态：<code>(0,0)</code></li><li>预测输入：<code>右移#1</code> <code>右移#2</code> <code>右移#3</code> <code>右移#4</code></li><li>预测状态：<code>(4,0)</code></li></ul><p>服务端发回了你的前 2 个右移指令</p><ul><li>权威状态：<code>(2,0)</code></li><li>预测输入：<code>右移#3</code> <code>右移#4</code> （<code>#1</code>、<code>#2</code> 变成了权威输入）</li><li>预测状态：<code>(4,0)</code></li></ul><p>服务端发回了与预期冲突的新输入</p><ul><li>上一次的权威状态：<code>(2,0)</code></li><li>权威输入：<code>你被拍晕了</code> <code>右移#3</code> <code>右移#4</code></li><li>权威状态：<code>(2,0)</code> （因为先被拍晕了，所以后两个右移指令无效）</li><li>预测输入：无 （所有预测输入都已变为权威输入）</li><li>预测状态：<code>(2,0)</code></li></ul></blockquote><p>因此你会从 <code>(4,0)</code>被拉回到 <code>(2,0)</code>, 并展示为眩晕，这在网络不良时都会经常遇见</p><h3 id="插值"><a href="#插值" class="headerlink" title="插值"></a>插值</h3><blockquote><p><strong>插值指在表现层更新 “其它人” 的状态变化时使用插值动画去平滑过渡。</strong></p><p>预测+和解是解决 <strong>自己</strong> 的问题，发生在 <strong>逻辑层</strong>；插值是解决 <strong>其它人</strong> 的问题，发生在 <strong>表现层</strong> 。</p></blockquote><p>到目前为止，本地已经输入无延迟。但在其它玩家的眼中，我们依旧是卡顿的。<strong>这是由于同步帧率和显示帧率不一致导致的</strong>，所以我们在更新其它人的状态时，并非一步到位的更新，而是通过插值动画来平滑过渡。</p><h1 id="帧同步（Lock-Step）"><a href="#帧同步（Lock-Step）" class="headerlink" title="帧同步（Lock Step）"></a><strong>帧同步（Lock Step）</strong></h1><h2 id="基本原理"><a href="#基本原理" class="headerlink" title="基本原理"></a>基本原理</h2><p>帧同步最基本的理念是，<strong>相同的输入+相同的时机&#x3D;相同的显示</strong>。简单来说，每个客户端接收到的操作是一样的，那么每个客户端的显示也是一样的。为了达成这一目标，就要保证每个客户端的运算都要绝对一致，不能依赖本地数据，而是依赖网络传输。包括一些随机数种子也是由服务器下发。</p><p><strong>帧同步的重点在于相同的输入和时序，客户端的表现和逻辑必然是分开的。</strong>为了保证所有客户端在相同的时间点得到输入指令，诞生了逻辑帧的概念，客户端和服务器遵循相同的逻辑帧，服务器在每个逻辑顿收集客户端输入，再统一下发给每个客户端。如果客户端没有收到服务器的消息那么表现就会不一致，所以客户端在收到回包之后需要确认。所以早期游戏都是用的TCP协议</p><p>显然这样有很多问题，虽然这保证了每个客户端的同步，但只要有一个客户端没有响应，便会阻断所有客户端的进程，并且也不能支持断线重连。早期的部分PC游戏，服务器只有在接受到所有客户端的输入数据后，才会继续执行，否则会等待直到认为该客户端超时断线</p><h2 id="基于UDP"><a href="#基于UDP" class="headerlink" title="基于UDP"></a>基于UDP</h2><p>基于UDP的话，服务器不在需要等待客户端数据全部传入，但这个时候就会出现延迟干扰同步，比如服务器在第二顿时收到客户端第一帧的输入数据。</p><p>UDP协议虽然快速，但是代价是不可靠，再加上网络环境的不确定性，丢包延迟的情况是不可避免的。为了在尽量使用UDP快速的优势下，又要保证传输的可靠性，所以诞生了可靠的UDP。<strong>所谓可靠的UDP，其实本质上不过是在应用层重新实现了一遍TCP协议。TCP协议为了保证可靠做了很多工作，比如确认包和滑动窗口机制等等。</strong>由应用层重新实现TCP协议，意味着应用可以自主地动态调整可靠性机制，优先保证传输速度。</p><p><strong>但只需要保证客户端接收到服务器的逻辑顿是连续的就行。</strong>客户端可以选择每帧都发送数据，没有玩家输入数据的话，就发送一个空的确认包，服务器收到客户端的确认包会更新客户端的当前帧序号。同时为了保证可靠会发送最近3帧的数据，可以保证在网络波动下能恢复丢包的数据。</p><h1 id="状态同步（State-Synchronization）"><a href="#状态同步（State-Synchronization）" class="headerlink" title="状态同步（State Synchronization）"></a><strong>状态同步（State Synchronization）</strong></h1><h2 id="基本原理-1"><a href="#基本原理-1" class="headerlink" title="基本原理"></a>基本原理</h2><p>状态同步有时也叫做快照同步，<strong>区别于帧同步策略同步每帧的输入，状态同步是同步每帧的游戏状态，或者说是每帧的游戏结果</strong>，例如物体的位置，怪物的血量变化等等。状态同步的服务器会运行所有游戏逻辑，但不包含表现（特效、UI、动画等在状态同步的服务器上是被省略的）。客户端收到服务器的每顿状态后，计算客户端的表现，包括特效、动画等。</p><p><strong>状态同步其实是一种不严谨的同步，玩家屏幕上的表现的一致性并不是重要的指标，只要保证每个操作的结果相同即可。</strong>因为表现是每个客户端独立完成的，所以状态同步只保证了核心游戏逻辑的一致性，但每个客户端的显示效果可以是不一样的。</p><h2 id="网络优化"><a href="#网络优化" class="headerlink" title="网络优化"></a>网络优化</h2><p>由于要同步游戏的所有状态变化，状态同步对网络带宽的要求比较高，这是相对于帧同步最大的缺点，所以状态同步更关注一些网络优化方法。</p><ul><li>帧同步使用的可靠UDP同样也适用于状态同步。</li><li>基于变化的属性同步，例如UE4引擎。只会同步有变化的属性，只同步属性变化的一个增量。</li><li>还需要一些手段减少每次需要同步的客户端数量，比如通过视野范围裁剪、区域裁剪、划分频道等相关性算法。计算每个客户端 (Connection) 之间的相关性，对每个客户端只同步相关性比较高的属性变化，比如在视野之外的变化不同步。</li></ul><h2 id="简单流程"><a href="#简单流程" class="headerlink" title="简单流程"></a>简单流程</h2><ol><li>客户端玩家操作后，这些指令会立刻发给服务器，同时本地开始执行预测</li><li>服务器会将这一帧收到的所有玩家的输入进行处理和计算。</li><li>服务器上每个对象的变化都会被记录并保存，并且持续积累</li><li>在每个同步间隔，服务器根据相关性算法和其他网络优化算法等计算需要同步给每个客户端 (Conenction) 的数据并同步给客户端</li><li>客户端收到服务器的数据，验证自己的预测，同时清除掉验证过的数据或者回滚。</li></ol><p><img src="/2023/01/09/%E5%B8%A7%E5%90%8C%E6%AD%A5%E5%92%8C%E7%8A%B6%E6%80%81%E5%90%8C%E6%AD%A5/image-20221109180036949.png" alt="image-20221109180036949"></p><h1 id="帧同步与状态同步的区别"><a href="#帧同步与状态同步的区别" class="headerlink" title="帧同步与状态同步的区别"></a>帧同步与状态同步的区别</h1><p><strong>两者最大的区别在于，同步的游戏逻辑运行在客户端，服务端只做转发，而状态同步的游戏逻辑运行在服务端，客户端只做表现</strong></p><table><thead><tr><th>属性</th><th>帧同步（LockStep）</th><th>状态同步</th></tr></thead><tbody><tr><td><strong>确定性</strong></td><td>逻辑上绝对一致，因此严格确定</td><td>表现不一定一致，只要保证每个操作的结果相同即可</td></tr><tr><td>响应速度</td><td>操作需要发送到服务器再等服务器返回按帧执行，也可以做预表现但很受限，<strong>响应性较差</strong></td><td>更好的进行预表现，<strong>响应性较好</strong>，因此大多FPS采用</td></tr><tr><td>带宽</td><td>人数少时极低，带宽随人数增加而增加，<strong>不适合多人游戏</strong></td><td>需要发送各种状态数据，带宽占用比较高。可以通过压缩、裁剪、增量等方式优化。</td></tr><tr><td>网络延迟</td><td>要求较低的延迟。如果延迟较高，极容易产生卡顿</td><td><strong>适应性较高</strong>，方便做各种插值优化</td></tr><tr><td>开发难度</td><td>框架容易实现，但是难以解决bug和完善系统。比如浮点数、随机数、执行顺序导致计算结果不一致</td><td>框架复杂，每个功能都需要客户端服务端联调</td></tr><tr><td>跨平台</td><td><strong>不适合跨平台</strong>，不同硬件和编译器导致浮点数计算不一致</td><td>适合。有权威服务器</td></tr><tr><td>反外挂</td><td>不适合反外挂，如果引入战斗服务器来校验各个客户端结果，可以解决常见外挂</td><td>与服务器加入校验机制，<strong>可以起到比较好的反外挂效果</strong>。</td></tr><tr><td>断线重连</td><td><strong>比较复杂。</strong>可以通过快捷播放服务器同步的帧数据来快速跟上游戏</td><td>容易。由于实时记录了各个对象的状态信息，所以直接创建这些对象并同步信息即可</td></tr><tr><td>回放（离线）</td><td>本身收集了所有玩家的输入信息进行逻辑推进，<strong>天然支持回放</strong></td><td>逻辑比较复杂，需要不断记录状态信息，同时回放时候需要读取合适的时间。</td></tr><tr><td>回放（实时）</td><td><strong>比较复杂</strong>，客户端需要本地对全场状态进行序列化，才能回到目标时间。播完回放后还需要加速追上实时游戏状态</td><td><strong>相对容易</strong>，可以方便的记录快照信息，并按照录制内容随时播放</td></tr></tbody></table><h2 id="回放系统"><a href="#回放系统" class="headerlink" title="回放系统"></a>回放系统</h2><p>帧同步的回放比状态同步好做得多，因为只需要保存每局所有人的操作就好了。但是实时回放的话（比如死亡回放），客户端需要本地对全场状态进行序列化，才能回到目标时间。播完回放后还需要加速追上实时游戏状态</p><p>而状态同步的回放，需要有一个回放服务器，当一局战斗打响，战斗服务器在给客户端发送消息的同时，还需要把这些消息发给回放服务器，回放服务器做储存，如果有其他客户端请求回放或者观战，则回放服务器把储存起来的消息按时间发给客户端。守望先锋的死亡回放、全场最佳、赛后回放使用了另一个EntityAdmin（ECS的术语）</p><h2 id="断线重连"><a href="#断线重连" class="headerlink" title="断线重连"></a>断线重连</h2><p>断线重连则相反，因为帧同步将数据大多放在客户端，而且基于UDP的帧同步会默认玩家网络会存在问题，重连时倍速播放服务端同步的帧数据来跟上正常进度。</p><p>状态同步只需要根据服务端记录下的状态信息创建对象并同步就行了</p>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;网络同步&quot;&gt;&lt;a href=&quot;#网络同步&quot; class=&quot;headerlink&quot; title=&quot;网络同步&quot;&gt;&lt;/a&gt;网络同步&lt;/h1&gt;&lt;p&gt;网络同步主要目的在于保证各个端口的游戏表现一致，&lt;strong&gt;网络同步就在于实时的多段数据同步和实时的多端表现。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;而对于大多数游戏，不仅客户端的表现要一致，而且需要客户端和服务端的数据是一致的。所以，同步是一个网络游戏概念，只有网络游戏才需要同步，而单机游戏是不需要同步的。&lt;/p&gt;
&lt;h2 id=&quot;同步目的&quot;&gt;&lt;a href=&quot;#同步目的&quot; class=&quot;headerlink&quot; title=&quot;同步目的&quot;&gt;&lt;/a&gt;同步目的&lt;/h2&gt;&lt;p&gt;首先我们慢慢说明如何实现简单的坐标同步&lt;/p&gt;
&lt;p&gt;很多时候我们都在讨论 “该用帧同步还是状态同步”，似乎这已经变成了一个二选一的问题。 但事实上，帧同步和状态同步不但 &lt;strong&gt;不是&lt;/strong&gt; 二选一的关系，甚至可以 &lt;strong&gt;相互替代&lt;/strong&gt; 和 &lt;strong&gt;混合使用&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;因为，&lt;strong&gt;帧同步和状态同步最终都是同步状态。&lt;/strong&gt;&lt;/p&gt;</summary>
    
    
    
    
    <category term="Unity" scheme="https://ycy666666.github.io/tags/Unity/"/>
    
  </entry>
  
  <entry>
    <title>lua面向对象</title>
    <link href="https://ycy666666.github.io/2022/12/26/lua%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/"/>
    <id>https://ycy666666.github.io/2022/12/26/lua%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/</id>
    <published>2022-12-26T14:26:47.000Z</published>
    <updated>2023-04-29T13:12:25.032Z</updated>
    
    <content type="html"><![CDATA[<h1 id="简单的类实现"><a href="#简单的类实现" class="headerlink" title="简单的类实现"></a>简单的类实现</h1><p>LUA中最基本的结构是table，用table来描述对象的属性。lua 中的 function 可以用来表示方法。</p><p><strong>那么LUA中的类可以通过 table + function 模拟出来。</strong></p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">Student = &#123;</span><br><span class="line">    age = <span class="number">1</span>,</span><br><span class="line">    growUp = <span class="function"><span class="keyword">function</span><span class="params">()</span></span></span><br><span class="line">        <span class="comment">-- print(age) 这样写与表中没有任何关系，他打印age这个全局变量</span></span><br><span class="line">        <span class="comment">-- 一定要调用表名.属性来指明是谁做的</span></span><br><span class="line">        <span class="built_in">print</span>(Student.age)</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">-- 声明表之后 ，仍可以在表外生命变量和方法</span></span><br><span class="line">Student.name = <span class="string">&quot;Name&quot;</span></span><br><span class="line">Student.Speak = <span class="function"><span class="keyword">function</span><span class="params">()</span></span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;说话&quot;</span>)</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 第三种函数的声明方法</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Student.Speak2</span><span class="params">()</span></span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;说话2&quot;</span>)</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 使用冒号 : 来将调用时冒号前的变量作为self</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Student:Speak3</span><span class="params">()</span></span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">self</span>.name..<span class="string">&quot;说话3&quot;</span>)</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(Student.age)</span><br><span class="line">Student.Speak()</span><br><span class="line">Student.Speak2()</span><br><span class="line">Student:Speak3() <span class="comment">-- Student 作为self</span></span><br><span class="line"><span class="comment">--[[输出结果</span></span><br><span class="line"><span class="comment">1</span></span><br><span class="line"><span class="comment">说话</span></span><br><span class="line"><span class="comment">说话2</span></span><br><span class="line"><span class="comment">Name说话3</span></span><br><span class="line"><span class="comment">--]]</span></span><br></pre></td></tr></table></figure><span id="more"></span><h1 id="Lua封装"><a href="#Lua封装" class="headerlink" title="Lua封装"></a>Lua封装</h1><p>类都是基于table来实现的</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">Object = &#123;&#125;</span><br><span class="line">Object.id = <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 冒号 会自动调用这个函数的对象，作为第一个参数传入</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Object:new</span><span class="params">()</span></span></span><br><span class="line">    <span class="comment">-- self 表示我们默认传入的第一个参数</span></span><br><span class="line">    <span class="keyword">local</span> obj = &#123;&#125;</span><br><span class="line">    <span class="comment">--__index当找不到自己的变量时就去元表当中查找__index指向的内容</span></span><br><span class="line">    <span class="built_in">self</span>.<span class="built_in">__index</span> = <span class="built_in">self</span></span><br><span class="line">    <span class="built_in">setmetatable</span>(obj, <span class="built_in">self</span>)</span><br><span class="line">    <span class="comment">-- 返回出去的本质上是表对象</span></span><br><span class="line">    <span class="keyword">return</span> obj</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Object:Test</span><span class="params">()</span></span></span><br><span class="line">    <span class="built_in">print</span>(<span class="built_in">self</span>.id)</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">local</span> myObj = Object:new()</span><br><span class="line"><span class="built_in">print</span>(myObj)</span><br><span class="line"><span class="built_in">print</span>(myObj.id)</span><br><span class="line">myObj:Test()</span><br><span class="line"></span><br><span class="line"><span class="comment">--[[输出</span></span><br><span class="line"><span class="comment">table: 00B09730</span></span><br><span class="line"><span class="comment">1</span></span><br><span class="line"><span class="comment">1--]]</span></span><br></pre></td></tr></table></figure><p>myObj就是个空表，但是因为指定了__index所以会返回Object中的id</p><h1 id="Lua继承"><a href="#Lua继承" class="headerlink" title="Lua继承"></a>Lua继承</h1><p>继承是指一个对象直接使用另一对象的属性和方法。可用于扩展基础类的属性和方法。</p><p>以下演示了一个简单的继承实例, 沿用Lua封装中的代码</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Object:subClass</span><span class="params">(className)</span></span></span><br><span class="line">    <span class="comment">-- 大G表存储了所有的非local变量，相当于创建了一个名为className的空表</span></span><br><span class="line">    <span class="built_in">_G</span>[className] = &#123;&#125;</span><br><span class="line">    <span class="comment">-- 写继承相关的规则</span></span><br><span class="line">    <span class="keyword">local</span> obj = <span class="built_in">_G</span>[className]</span><br><span class="line">    <span class="comment">-- 将元表的index设为自己，这样obj找不到某个值时会去传入的self查找</span></span><br><span class="line">    <span class="built_in">self</span>.<span class="built_in">__index</span> = <span class="built_in">self</span></span><br><span class="line">    <span class="comment">-- 给子类定义base属性代表父类</span></span><br><span class="line">    obj.base = <span class="built_in">self</span></span><br><span class="line">    <span class="built_in">setmetatable</span>(obj, <span class="built_in">self</span>)</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">Object:subClass(<span class="string">&quot;Person&quot;</span>)</span><br><span class="line"><span class="keyword">local</span> p1 = Person:new()</span><br><span class="line"><span class="built_in">print</span>(p1.id)</span><br><span class="line">p1.id = <span class="number">100</span></span><br><span class="line"><span class="built_in">print</span>(p1.id)</span><br><span class="line">p1:Test()</span><br><span class="line"></span><br><span class="line">Object:subClass(<span class="string">&quot;Monster&quot;</span>)</span><br><span class="line"><span class="keyword">local</span> m1 = Monster:new()</span><br><span class="line"><span class="built_in">print</span>(m1.id)</span><br><span class="line">m1.id = <span class="number">200</span></span><br><span class="line"><span class="built_in">print</span>(m1.id)</span><br><span class="line">m1:Test()</span><br><span class="line"></span><br><span class="line"><span class="comment">--[[输出结果</span></span><br><span class="line"><span class="comment">1</span></span><br><span class="line"><span class="comment">100</span></span><br><span class="line"><span class="comment">100</span></span><br><span class="line"><span class="comment">1</span></span><br><span class="line"><span class="comment">200</span></span><br><span class="line"><span class="comment">200--]]</span></span><br></pre></td></tr></table></figure><blockquote><p><strong>引用参数self:<strong>指向</strong>调用者自身</strong>,相当于this指针</p><p><strong>冒号引用：</strong>self指针指向冒号之前的对象，相当于把将独显赋值给self。</p><p>总之就相当于 <strong>冒号定义的函数如果用点来调用，那么第一个参数就视为self</strong></p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">myclass = &#123;age = <span class="number">10</span>, name=<span class="string">&quot;aa&quot;</span>&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">myclass:fun</span><span class="params">(p)</span></span></span><br><span class="line"> <span class="built_in">print</span>(<span class="built_in">self</span>)</span><br><span class="line"> <span class="built_in">print</span>(<span class="built_in">self</span>.age)</span><br><span class="line"> <span class="built_in">print</span>(p)</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">myclass:fun(<span class="string">&quot;22&quot;</span>) </span><br><span class="line"><span class="comment">--[[输出table: 00D69810</span></span><br><span class="line"><span class="comment">10</span></span><br><span class="line"><span class="comment">22]]</span><span class="comment">--</span></span><br><span class="line"></span><br><span class="line">myclass.fun(<span class="string">&quot;22&quot;</span>)</span><br><span class="line"><span class="comment">--[[输出22</span></span><br><span class="line"><span class="comment">nil</span></span><br><span class="line"><span class="comment">nil]]</span><span class="comment">--</span></span><br><span class="line"></span><br><span class="line">myclass.fun(myclass, <span class="string">&quot;22&quot;</span>)</span><br><span class="line"><span class="comment">--[[输出table: 00F298B0</span></span><br><span class="line"><span class="comment">10</span></span><br><span class="line"><span class="comment">22]]</span><span class="comment">--</span></span><br></pre></td></tr></table></figure></blockquote><h1 id="Lua多态"><a href="#Lua多态" class="headerlink" title="Lua多态"></a>Lua多态</h1><p>多态：不同表现相同行为，还是沿用之前的部分代码</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">Object:subClass(<span class="string">&quot;GameObject&quot;</span>)</span><br><span class="line">GameObject.posX = <span class="number">0</span></span><br><span class="line">GameObject.posY = <span class="number">0</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">GameObject:Move</span><span class="params">()</span></span></span><br><span class="line">    <span class="built_in">self</span>.posX = <span class="built_in">self</span>.posX + <span class="number">1</span></span><br><span class="line">    <span class="built_in">self</span>.posY = <span class="built_in">self</span>.posY + <span class="number">1</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="built_in">self</span>.posX)</span><br><span class="line">    <span class="built_in">print</span>(<span class="built_in">self</span>.posY)</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">GameObject:subClass(<span class="string">&quot;Player&quot;</span>)</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Player:Move</span><span class="params">()</span></span> <span class="comment">-- 重写同名方法</span></span><br><span class="line">    <span class="comment">-- 因为lua继承是我们自己实现的，所以也就不能用base.Move()这种形式来调用父类的方法</span></span><br><span class="line">    <span class="built_in">self</span>.base:Move() <span class="comment">-- 使用冒号调用，就相当于把Gameobject作为self传入方法中，就相当于所有实例公用了同一张表，这是不行的</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">--正确调用方法</span></span><br><span class="line">    <span class="built_in">self</span>.base.Move(<span class="built_in">self</span>) <span class="comment">-- 将调用者传入作为Move方法中的self</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">local</span> player1 = Player:new()</span><br><span class="line">player1:Move() <span class="comment">-- self 指向player1</span></span><br><span class="line"><span class="keyword">local</span> player2 = Player:new()</span><br><span class="line">player2:Move() <span class="comment">-- self 指向player2</span></span><br><span class="line"></span><br><span class="line"><span class="comment">--[[</span></span><br><span class="line"><span class="comment">错误调用的输出 1 1 2 2</span></span><br><span class="line"><span class="comment">正确调用的输出 1 1 1 1</span></span><br><span class="line"><span class="comment">--]]</span></span><br></pre></td></tr></table></figure><h1 id="Lua包"><a href="#Lua包" class="headerlink" title="Lua包"></a>Lua包</h1><p><strong>定义:包是一种组织代码的方式。</strong></p><h2 id="简单的多脚本执行"><a href="#简单的多脚本执行" class="headerlink" title="简单的多脚本执行"></a>简单的多脚本执行</h2><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- test.lua</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;successful&quot;</span>)</span><br><span class="line">A = <span class="string">&quot;123&quot;</span></span><br><span class="line"><span class="keyword">local</span> locA = <span class="string">&quot;234&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- main.lua</span></span><br><span class="line"><span class="built_in">require</span>(<span class="string">&quot;test&quot;</span>) <span class="comment">-- 加载执行test.lua脚本</span></span><br><span class="line"><span class="built_in">print</span>(A)</span><br><span class="line"><span class="built_in">print</span>(localA)</span><br><span class="line"></span><br><span class="line"><span class="comment">--[[输出结果</span></span><br><span class="line"><span class="comment">successful </span></span><br><span class="line"><span class="comment">123</span></span><br><span class="line"><span class="comment">nil</span></span><br><span class="line"><span class="comment">]]</span><span class="comment">--</span></span><br></pre></td></tr></table></figure><ul><li>脚本不仅会加载，还会执行</li><li>可以使用<code>package.loaded[&quot;脚本名&quot;]</code>，返回值是该脚本是否被执行的boolean</li><li>如果想要卸载脚本，<code>package.loaded[&quot;脚本名&quot;] = nil</code></li></ul><p>如果我们想要获取另一脚本的local变量，我们可以return出来。比如在上诉的 <code>test.lua</code>中 添加<code>return localA</code></p><p>然后再 <code>main.lua</code>中创建变量接受他 <code>testLocalA = require(&quot;test&quot;)</code></p><p>可以使用大G表，所有声明的全局变量都将会存储在里面，local 变量不会在里面</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> k,v <span class="keyword">in</span> <span class="built_in">pairs</span>(<span class="built_in">_G</span>) <span class="keyword">do</span></span><br><span class="line"><span class="built_in">print</span>(k,v)</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><h2 id="包使用实例"><a href="#包使用实例" class="headerlink" title="包使用实例"></a>包使用实例</h2><p>一般在一个Lua文件内以module函数开始定义一个包。<strong>module同时定义了一个新的包的函数环境,以使在此包中定义的全局变量都在这个环境中,而非使用包的函数的环境中。</strong></p><p>自定义包</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- mypack.lua</span></span><br><span class="line"><span class="built_in">module</span>(..., <span class="built_in">package</span>.<span class="built_in">seeall</span>) <span class="comment">--定义包,包的名字与定义包的文件的名字相同,并且在包的函数环境里可以访问使用包的函数环境</span></span><br><span class="line">ver = <span class="string">&quot;0.1 alpha&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">aFunInMyPack</span><span class="params">()</span></span> </span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Hello!&quot;</span>)</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">_G</span>.aFuncFromMyPack = aFunInMyPack</span><br></pre></td></tr></table></figure><p>测试代码</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- hello.lua</span></span><br><span class="line"><span class="keyword">local</span> pack = <span class="built_in">require</span> <span class="string">&quot;mypack&quot;</span>  <span class="comment">--导入包,导入的包必须被置于包路径(packagepath)上。包路径可以通过package.path或者环境变量来设定</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(ver <span class="keyword">or</span> <span class="string">&quot;No ver defined!&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(pack.ver)</span><br><span class="line"></span><br><span class="line">pack.aFunInMyPack()</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(aFunInMyPack <span class="keyword">or</span> <span class="string">&quot;No aFunInMyPack defined!&quot;</span>)</span><br><span class="line">aFuncFromMyPack()</span><br><span class="line"><span class="comment">--[[输出结果</span></span><br><span class="line"><span class="comment">No ver defined!</span></span><br><span class="line"><span class="comment">0.1 alpha</span></span><br><span class="line"><span class="comment">Hello!</span></span><br><span class="line"><span class="comment">No aFunInMyPack defined!</span></span><br><span class="line"><span class="comment">Hello!</span></span><br><span class="line"><span class="comment">--]]</span></span><br></pre></td></tr></table></figure><p>require 用于使用模块，module 用于创建模块。</p><h2 id="创建包"><a href="#创建包" class="headerlink" title="创建包"></a>创建包</h2><p>简单的说，一个模块就是一个程序库，可以通过 require 来加载。<strong>然后便得到了一个全局变量，表示一个 table</strong>。这个 table 就像是一个命名空间，其内容就是模块中导出的所有东西，比如函数和常量</p><p>如果不用module 函数创建包</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">local</span> M = &#123;&#125;;</span><br><span class="line"><span class="keyword">local</span> modelName = ...;</span><br><span class="line"><span class="built_in">_G</span>[modelName] = M;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">M.play</span><span class="params">()</span></span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;那么，开始吧&quot;</span>);</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">M.quit</span><span class="params">()</span></span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;你走吧，我保证你不会出事的，呵，呵呵&quot;</span>);</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> M;</span><br><span class="line"></span><br><span class="line"><span class="comment">----或者是下面这样----</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">local</span> M = &#123;&#125;;</span><br><span class="line"><span class="keyword">local</span> modelName = ...;</span><br><span class="line"><span class="built_in">_G</span>[modelName] = M;</span><br><span class="line"><span class="built_in">package</span>.<span class="built_in">loaded</span>[modname] = M</span><br><span class="line"><span class="built_in">setfenv</span>(<span class="number">1</span>, M);</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">play</span><span class="params">()</span></span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;那么，开始吧&quot;</span>);</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">quit</span><span class="params">()</span></span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;你走吧，我保证你不会出事的，呵，呵呵&quot;</span>);</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> M;</span><br></pre></td></tr></table></figure><p><strong>在调用 module 函数时，多传入一个 package.seeall 的参数，相当于 setmetatable(M, {__index &#x3D; _G})</strong> </p><h1 id="Lua实战——实现2048"><a href="#Lua实战——实现2048" class="headerlink" title="Lua实战——实现2048"></a>Lua实战——实现2048</h1><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">local</span> <span class="function"><span class="keyword">function</span> <span class="title">initGrid</span><span class="params">(m,n)</span></span></span><br><span class="line">    <span class="keyword">local</span> grid = &#123;&#125;</span><br><span class="line">    <span class="keyword">for</span> i=<span class="number">1</span>,m <span class="keyword">do</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> grid[i] <span class="keyword">then</span></span><br><span class="line">            grid[i] = &#123;&#125;</span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">        <span class="keyword">for</span> j=<span class="number">1</span>,n <span class="keyword">do</span></span><br><span class="line">            grid[i][j] = <span class="number">0</span></span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">return</span> grid</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"><span class="keyword">local</span> <span class="function"><span class="keyword">function</span> <span class="title">printGrid</span><span class="params">(grid)</span></span></span><br><span class="line">    <span class="keyword">local</span> celllen = <span class="number">8</span>  <span class="comment">-- 每个格子占用字符数</span></span><br><span class="line">    <span class="keyword">local</span> gridStrLines = &#123;&#125;</span><br><span class="line">    <span class="built_in">table</span>.<span class="built_in">insert</span>(gridStrLines,<span class="string">&quot;-------------------------------------&quot;</span>)</span><br><span class="line">    <span class="keyword">for</span> i,row <span class="keyword">in</span> <span class="built_in">ipairs</span>(grid) <span class="keyword">do</span></span><br><span class="line">        <span class="keyword">local</span> line = &#123;&#125;</span><br><span class="line">        <span class="keyword">for</span> _,num <span class="keyword">in</span> <span class="built_in">ipairs</span>(row) <span class="keyword">do</span></span><br><span class="line">            <span class="keyword">if</span> num==<span class="number">0</span> <span class="keyword">then</span></span><br><span class="line">                <span class="keyword">local</span> pres = <span class="string">&quot;&quot;</span></span><br><span class="line">                <span class="keyword">for</span> tmp=<span class="number">1</span>,celllen <span class="keyword">do</span></span><br><span class="line">                    pres = pres .. <span class="string">&quot; &quot;</span></span><br><span class="line">                <span class="keyword">end</span></span><br><span class="line">                <span class="keyword">local</span> s = <span class="built_in">string</span>.<span class="built_in">format</span>(<span class="string">&quot;%s&quot;</span>,pres)</span><br><span class="line">                <span class="built_in">table</span>.<span class="built_in">insert</span>(line,s)</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                <span class="keyword">local</span> s = <span class="built_in">tostring</span>(num)</span><br><span class="line">                <span class="keyword">local</span> l = <span class="built_in">string</span>.<span class="built_in">len</span>(s)</span><br><span class="line">                <span class="keyword">local</span> l = (celllen-l)/<span class="number">2</span></span><br><span class="line">                <span class="keyword">local</span> prel = <span class="built_in">math</span>.<span class="built_in">floor</span>(l)</span><br><span class="line">                <span class="keyword">local</span> sufl = <span class="built_in">math</span>.<span class="built_in">ceil</span>(l)</span><br><span class="line">                <span class="keyword">local</span> pres = <span class="string">&quot;&quot;</span></span><br><span class="line">                <span class="keyword">for</span> tmp=<span class="number">1</span>,prel <span class="keyword">do</span></span><br><span class="line">                    pres = pres .. <span class="string">&quot; &quot;</span></span><br><span class="line">                <span class="keyword">end</span></span><br><span class="line">                <span class="keyword">local</span> sufs = pres</span><br><span class="line">                <span class="keyword">if</span> sufl&gt;prel <span class="keyword">then</span></span><br><span class="line">                    sufs = pres.. <span class="string">&quot; &quot;</span></span><br><span class="line">                <span class="keyword">end</span></span><br><span class="line">                <span class="keyword">local</span> s = <span class="built_in">string</span>.<span class="built_in">format</span>(<span class="string">&quot;%s%s%s&quot;</span>,pres,s,sufs)</span><br><span class="line">                <span class="built_in">table</span>.<span class="built_in">insert</span>(line,s)</span><br><span class="line">            <span class="keyword">end</span></span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">        <span class="keyword">local</span> line = <span class="built_in">table</span>.<span class="built_in">concat</span>(line,<span class="string">&quot;|&quot;</span>)</span><br><span class="line">        line = <span class="string">&quot;|&quot;</span> .. line .. <span class="string">&quot;|&quot;</span></span><br><span class="line">        <span class="built_in">table</span>.<span class="built_in">insert</span>(gridStrLines,line)</span><br><span class="line">        <span class="built_in">table</span>.<span class="built_in">insert</span>(gridStrLines,<span class="string">&quot;-------------------------------------&quot;</span>)</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">local</span> gridStr = <span class="built_in">table</span>.<span class="built_in">concat</span>(gridStrLines,<span class="string">&quot;\n&quot;</span>)</span><br><span class="line">    <span class="built_in">print</span>(gridStr)</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"><span class="keyword">local</span> <span class="function"><span class="keyword">function</span> <span class="title">randomGrid</span><span class="params">(grid)</span></span></span><br><span class="line">    <span class="keyword">local</span> m = #grid</span><br><span class="line">    <span class="keyword">local</span> n = #grid[<span class="number">1</span>]</span><br><span class="line">    <span class="keyword">for</span> i=<span class="number">1</span>,m <span class="keyword">do</span></span><br><span class="line">        <span class="keyword">for</span> j=<span class="number">1</span>,n <span class="keyword">do</span></span><br><span class="line">            <span class="keyword">local</span> r = <span class="built_in">math</span>.<span class="built_in">random</span>(<span class="number">1</span>,<span class="number">5</span>)</span><br><span class="line">            <span class="keyword">local</span> num = <span class="number">2</span>^r</span><br><span class="line">            grid[i][j] = num</span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"><span class="keyword">local</span> <span class="function"><span class="keyword">function</span> <span class="title">getRandomZeroPos</span><span class="params">(grid)</span></span></span><br><span class="line">    <span class="keyword">local</span> m = #grid</span><br><span class="line">    <span class="keyword">local</span> n = #grid[<span class="number">1</span>]</span><br><span class="line">    <span class="keyword">local</span> zeros = &#123;&#125;</span><br><span class="line">    <span class="keyword">for</span> i=<span class="number">1</span>,m <span class="keyword">do</span></span><br><span class="line">        <span class="keyword">for</span> j=<span class="number">1</span>,n <span class="keyword">do</span></span><br><span class="line">            <span class="keyword">if</span> grid[i][j]==<span class="number">0</span> <span class="keyword">then</span></span><br><span class="line">                <span class="built_in">table</span>.<span class="built_in">insert</span>(zeros,&#123;i=i,j=j&#125;)</span><br><span class="line">            <span class="keyword">end</span></span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">if</span> #zeros&gt;<span class="number">0</span> <span class="keyword">then</span></span><br><span class="line">        <span class="keyword">local</span> r = <span class="built_in">math</span>.<span class="built_in">random</span>(<span class="number">1</span>,#zeros)</span><br><span class="line">        <span class="keyword">return</span> zeros[r].i,zeros[r].j</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"><span class="keyword">local</span> <span class="function"><span class="keyword">function</span> <span class="title">randomNum</span><span class="params">(grid)</span></span></span><br><span class="line">    <span class="keyword">local</span> i,j = getRandomZeroPos(grid)</span><br><span class="line">    <span class="keyword">if</span> i <span class="keyword">and</span> j <span class="keyword">then</span></span><br><span class="line">        <span class="keyword">local</span> r = <span class="built_in">math</span>.<span class="built_in">random</span>()</span><br><span class="line">        <span class="keyword">if</span> r&lt;<span class="number">0.9</span> <span class="keyword">then</span></span><br><span class="line">            grid[i][j] = <span class="number">2</span></span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            grid[i][j] = <span class="number">4</span></span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">        <span class="keyword">return</span> i,j</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"><span class="keyword">local</span> <span class="function"><span class="keyword">function</span> <span class="title">moveLeft</span><span class="params">(grid)</span></span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;==============moveLeft===============&quot;</span>)</span><br><span class="line">    <span class="keyword">local</span> m = #grid</span><br><span class="line">    <span class="keyword">local</span> n = #grid[<span class="number">1</span>]</span><br><span class="line">    <span class="keyword">for</span> i=<span class="number">1</span>,m <span class="keyword">do</span></span><br><span class="line">        <span class="keyword">local</span> line = &#123;&#125;</span><br><span class="line">        <span class="keyword">for</span> j=<span class="number">1</span>,n <span class="keyword">do</span></span><br><span class="line">            <span class="keyword">if</span> grid[i][j]~=<span class="number">0</span> <span class="keyword">then</span></span><br><span class="line">                <span class="built_in">table</span>.<span class="built_in">insert</span>(line,grid[i][j])</span><br><span class="line">            <span class="keyword">end</span></span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">        <span class="keyword">local</span> k=#line</span><br><span class="line">        <span class="keyword">for</span> j=<span class="number">1</span>,n <span class="keyword">do</span></span><br><span class="line">            <span class="keyword">if</span> j&lt;=k <span class="keyword">then</span></span><br><span class="line">                grid[i][j] = line[j]</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                grid[i][j] = <span class="number">0</span></span><br><span class="line">            <span class="keyword">end</span></span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">        <span class="keyword">for</span> j=<span class="number">1</span>,k<span class="number">-1</span> <span class="keyword">do</span></span><br><span class="line">            <span class="keyword">if</span> grid[i][j]==grid[i][j+<span class="number">1</span>] <span class="keyword">then</span></span><br><span class="line">                grid[i][j+<span class="number">1</span>] = grid[i][j] + grid[i][j+<span class="number">1</span>]</span><br><span class="line">                <span class="keyword">for</span> x=j,n<span class="number">-1</span> <span class="keyword">do</span></span><br><span class="line">                    grid[i][x] = grid[i][x+<span class="number">1</span>]</span><br><span class="line">                <span class="keyword">end</span></span><br><span class="line">                grid[i][n] = <span class="number">0</span></span><br><span class="line">            <span class="keyword">end</span></span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"><span class="keyword">local</span> <span class="function"><span class="keyword">function</span> <span class="title">moveRight</span><span class="params">(grid)</span></span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;==============moveRight==============&quot;</span>)</span><br><span class="line">    <span class="keyword">local</span> m = #grid</span><br><span class="line">    <span class="keyword">local</span> n = #grid[<span class="number">1</span>]</span><br><span class="line">    <span class="keyword">for</span> i=<span class="number">1</span>,m <span class="keyword">do</span></span><br><span class="line">        <span class="keyword">local</span> line = &#123;&#125;</span><br><span class="line">        <span class="keyword">for</span> j=n,<span class="number">1</span>,<span class="number">-1</span> <span class="keyword">do</span></span><br><span class="line">            <span class="keyword">if</span> grid[i][j]~=<span class="number">0</span> <span class="keyword">then</span></span><br><span class="line">                <span class="built_in">table</span>.<span class="built_in">insert</span>(line,grid[i][j])</span><br><span class="line">            <span class="keyword">end</span></span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">        <span class="keyword">local</span> k = #line</span><br><span class="line">        <span class="keyword">for</span> j=n,<span class="number">1</span>,<span class="number">-1</span> <span class="keyword">do</span></span><br><span class="line">            <span class="keyword">if</span> n-j+<span class="number">1</span>&lt;=k <span class="keyword">then</span></span><br><span class="line">                grid[i][j] = line[n-j+<span class="number">1</span>]</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                grid[i][j] = <span class="number">0</span></span><br><span class="line">            <span class="keyword">end</span></span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">        <span class="keyword">for</span> j=n,n-k+<span class="number">2</span>,<span class="number">-1</span> <span class="keyword">do</span></span><br><span class="line">            <span class="keyword">if</span> grid[i][j]==grid[i][j<span class="number">-1</span>] <span class="keyword">then</span></span><br><span class="line">                grid[i][j<span class="number">-1</span>] = grid[i][j] + grid[i][j<span class="number">-1</span>]</span><br><span class="line">                <span class="keyword">for</span> x=j,<span class="number">2</span>,<span class="number">-1</span> <span class="keyword">do</span></span><br><span class="line">                    grid[i][x] = grid[i][x<span class="number">-1</span>]</span><br><span class="line">                <span class="keyword">end</span></span><br><span class="line">                grid[i][<span class="number">1</span>] = <span class="number">0</span></span><br><span class="line">            <span class="keyword">end</span></span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"><span class="keyword">local</span> <span class="function"><span class="keyword">function</span> <span class="title">moveUp</span><span class="params">(grid)</span></span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;===============moveUp================&quot;</span>)</span><br><span class="line">    <span class="keyword">local</span> m = #grid</span><br><span class="line">    <span class="keyword">local</span> n = #grid[<span class="number">1</span>]</span><br><span class="line">    <span class="keyword">for</span> j=<span class="number">1</span>,n <span class="keyword">do</span></span><br><span class="line">        <span class="keyword">local</span> line = &#123;&#125;</span><br><span class="line">        <span class="keyword">for</span> i=<span class="number">1</span>,m <span class="keyword">do</span></span><br><span class="line">            <span class="keyword">if</span> grid[i][j]~=<span class="number">0</span> <span class="keyword">then</span></span><br><span class="line">                <span class="built_in">table</span>.<span class="built_in">insert</span>(line,grid[i][j])</span><br><span class="line">            <span class="keyword">end</span></span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">        <span class="keyword">local</span> k = #line</span><br><span class="line">        <span class="keyword">for</span> i=<span class="number">1</span>,m <span class="keyword">do</span></span><br><span class="line">            <span class="keyword">if</span> i&lt;=k <span class="keyword">then</span></span><br><span class="line">                grid[i][j] = line[i]</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                grid[i][j] = <span class="number">0</span></span><br><span class="line">            <span class="keyword">end</span></span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">        <span class="keyword">for</span> i=<span class="number">1</span>,k<span class="number">-1</span> <span class="keyword">do</span></span><br><span class="line">            <span class="keyword">if</span> grid[i][j]==grid[i+<span class="number">1</span>][j] <span class="keyword">then</span></span><br><span class="line">                grid[i+<span class="number">1</span>][j] = grid[i][j] + grid[i+<span class="number">1</span>][j]</span><br><span class="line">                <span class="keyword">for</span> x=i,m<span class="number">-1</span> <span class="keyword">do</span></span><br><span class="line">                    grid[x][j] = grid[x+<span class="number">1</span>][j]</span><br><span class="line">                <span class="keyword">end</span></span><br><span class="line">                grid[m][j] = <span class="number">0</span></span><br><span class="line">            <span class="keyword">end</span></span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"><span class="keyword">local</span> <span class="function"><span class="keyword">function</span> <span class="title">moveDown</span><span class="params">(grid)</span></span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;==============moveDown===============&quot;</span>)</span><br><span class="line">    <span class="keyword">local</span> m = #grid</span><br><span class="line">    <span class="keyword">local</span> n = #grid[<span class="number">1</span>]</span><br><span class="line">    <span class="keyword">for</span> j=<span class="number">1</span>,n <span class="keyword">do</span></span><br><span class="line">        <span class="keyword">local</span> line = &#123;&#125;</span><br><span class="line">        <span class="keyword">for</span> i=m,<span class="number">1</span>,<span class="number">-1</span> <span class="keyword">do</span></span><br><span class="line">            <span class="keyword">if</span> grid[i][j]~=<span class="number">0</span> <span class="keyword">then</span></span><br><span class="line">                <span class="built_in">table</span>.<span class="built_in">insert</span>(line,grid[i][j])</span><br><span class="line">            <span class="keyword">end</span></span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">        <span class="keyword">local</span> k = #line</span><br><span class="line">        <span class="keyword">for</span> i=m,<span class="number">1</span>,<span class="number">-1</span> <span class="keyword">do</span></span><br><span class="line">            <span class="keyword">if</span> m-i+<span class="number">1</span>&lt;=k <span class="keyword">then</span></span><br><span class="line">                grid[i][j] = line[m-i+<span class="number">1</span>]</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                grid[i][j] = <span class="number">0</span></span><br><span class="line">            <span class="keyword">end</span></span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">        <span class="keyword">for</span> i=m,m-k+<span class="number">2</span>,<span class="number">-1</span> <span class="keyword">do</span></span><br><span class="line">            <span class="keyword">if</span> grid[i][j]==grid[i<span class="number">-1</span>][j] <span class="keyword">then</span></span><br><span class="line">                grid[i<span class="number">-1</span>][j] = grid[i][j] + grid[i<span class="number">-1</span>][j]</span><br><span class="line">                <span class="keyword">for</span> x=i,<span class="number">2</span>,<span class="number">-1</span> <span class="keyword">do</span></span><br><span class="line">                    grid[x][j] = grid[x<span class="number">-1</span>][j]</span><br><span class="line">                <span class="keyword">end</span></span><br><span class="line">                grid[<span class="number">1</span>][j] = <span class="number">0</span></span><br><span class="line">            <span class="keyword">end</span></span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"><span class="keyword">local</span> <span class="function"><span class="keyword">function</span> <span class="title">canMove</span><span class="params">(grid)</span></span></span><br><span class="line">    <span class="keyword">local</span> m = #grid</span><br><span class="line">    <span class="keyword">local</span> n = #grid[<span class="number">1</span>]</span><br><span class="line">    <span class="keyword">for</span> i=<span class="number">1</span>,m <span class="keyword">do</span></span><br><span class="line">        <span class="keyword">for</span> j=<span class="number">1</span>,n <span class="keyword">do</span></span><br><span class="line">            <span class="keyword">if</span> grid[i][j]==<span class="number">0</span> <span class="keyword">then</span></span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">            <span class="keyword">end</span></span><br><span class="line">            <span class="keyword">if</span> (i&lt;m <span class="keyword">and</span> j&lt;n)</span><br><span class="line">            <span class="keyword">and</span> (grid[i][j]==grid[i][j+<span class="number">1</span>]</span><br><span class="line">                <span class="keyword">or</span> grid[i][j]==grid[i+<span class="number">1</span>][j]) <span class="keyword">then</span></span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">            <span class="keyword">end</span></span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"><span class="keyword">local</span> <span class="function"><span class="keyword">function</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line">    <span class="keyword">local</span> grid = initGrid(<span class="number">4</span>,<span class="number">4</span>)</span><br><span class="line">    randomNum(grid)</span><br><span class="line">    printGrid(grid)</span><br><span class="line">    <span class="built_in">io</span>.<span class="built_in">write</span>(<span class="string">&quot;next step &#x27;a&#x27;[←],&#x27;w&#x27;[↑],&#x27;s&#x27;[↓],&#x27;d&#x27;[→],&#x27;q&#x27;[exit] &gt;&gt; &quot;</span>)</span><br><span class="line">    <span class="keyword">local</span> <span class="built_in">input</span> = <span class="built_in">io</span>.<span class="built_in">read</span>()</span><br><span class="line">    <span class="keyword">while</span> <span class="built_in">input</span>~=<span class="string">&quot;q&quot;</span> <span class="keyword">do</span></span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">input</span>==<span class="string">&quot;a&quot;</span> <span class="keyword">or</span> <span class="built_in">input</span>==<span class="string">&quot;w&quot;</span> <span class="keyword">or</span> <span class="built_in">input</span>==<span class="string">&quot;s&quot;</span> <span class="keyword">or</span> <span class="built_in">input</span>==<span class="string">&quot;d&quot;</span> <span class="keyword">then</span></span><br><span class="line">            <span class="keyword">if</span> <span class="built_in">input</span>==<span class="string">&quot;a&quot;</span> <span class="keyword">then</span></span><br><span class="line">                moveLeft(grid)</span><br><span class="line">            <span class="keyword">elseif</span> <span class="built_in">input</span>==<span class="string">&quot;w&quot;</span> <span class="keyword">then</span></span><br><span class="line">                moveUp(grid)</span><br><span class="line">            <span class="keyword">elseif</span> <span class="built_in">input</span>==<span class="string">&quot;s&quot;</span> <span class="keyword">then</span></span><br><span class="line">                moveDown(grid)</span><br><span class="line">            <span class="keyword">elseif</span> <span class="built_in">input</span>==<span class="string">&quot;d&quot;</span> <span class="keyword">then</span></span><br><span class="line">                moveRight(grid)</span><br><span class="line">            <span class="keyword">end</span></span><br><span class="line">            randomNum(grid)</span><br><span class="line">            printGrid(grid)</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&quot;error input. please input &#x27;a&#x27;[←] or &#x27;w&#x27;[↑] or &#x27;s&#x27;[↓] or &#x27;d&#x27;[→] or &#x27;q&#x27;[exit]&quot;</span>)</span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">        <span class="built_in">io</span>.<span class="built_in">write</span>(<span class="string">&quot;next step &#x27;a&#x27;[←],&#x27;w&#x27;[↑],&#x27;s&#x27;[↓],&#x27;d&#x27;[→],&#x27;q&#x27;[exit] &gt;&gt; &quot;</span>)</span><br><span class="line">        <span class="built_in">input</span> = <span class="built_in">io</span>.<span class="built_in">read</span>()</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line">main()</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;简单的类实现&quot;&gt;&lt;a href=&quot;#简单的类实现&quot; class=&quot;headerlink&quot; title=&quot;简单的类实现&quot;&gt;&lt;/a&gt;简单的类实现&lt;/h1&gt;&lt;p&gt;LUA中最基本的结构是table，用table来描述对象的属性。lua 中的 function 可以用来表示方法。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;那么LUA中的类可以通过 table + function 模拟出来。&lt;/strong&gt;&lt;/p&gt;
&lt;figure class=&quot;highlight lua&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;21&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;22&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;23&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;24&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;25&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;26&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;27&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;28&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;29&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;30&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;31&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;32&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;33&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;34&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;Student = &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    age = &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    growUp = &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;comment&quot;&gt;-- print(age) 这样写与表中没有任何关系，他打印age这个全局变量&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;comment&quot;&gt;-- 一定要调用表名.属性来指明是谁做的&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;built_in&quot;&gt;print&lt;/span&gt;(Student.age)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;end&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;-- 声明表之后 ，仍可以在表外生命变量和方法&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;Student.name = &lt;span class=&quot;string&quot;&gt;&amp;quot;Name&amp;quot;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;Student.Speak = &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&lt;span class=&quot;built_in&quot;&gt;print&lt;/span&gt;(&lt;span class=&quot;string&quot;&gt;&amp;quot;说话&amp;quot;&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;end&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;-- 第三种函数的声明方法&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;Student.Speak2&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&lt;span class=&quot;built_in&quot;&gt;print&lt;/span&gt;(&lt;span class=&quot;string&quot;&gt;&amp;quot;说话2&amp;quot;&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;end&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;-- 使用冒号 : 来将调用时冒号前的变量作为self&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;Student:Speak3&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&lt;span class=&quot;built_in&quot;&gt;print&lt;/span&gt;(&lt;span class=&quot;built_in&quot;&gt;self&lt;/span&gt;.name..&lt;span class=&quot;string&quot;&gt;&amp;quot;说话3&amp;quot;&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;end&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;built_in&quot;&gt;print&lt;/span&gt;(Student.age)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;Student.Speak()&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;Student.Speak2()&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;Student:Speak3() &lt;span class=&quot;comment&quot;&gt;-- Student 作为self&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;--[[输出结果&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;1&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;说话&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;说话2&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;Name说话3&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;--]]&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;</summary>
    
    
    
    
    <category term="lua" scheme="https://ycy666666.github.io/tags/lua/"/>
    
  </entry>
  
  <entry>
    <title>lua 基本语法</title>
    <link href="https://ycy666666.github.io/2022/12/23/lua-%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95/"/>
    <id>https://ycy666666.github.io/2022/12/23/lua-%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95/</id>
    <published>2022-12-23T12:40:07.000Z</published>
    <updated>2023-04-29T13:12:40.012Z</updated>
    
    <content type="html"><![CDATA[<h1 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h1><p>lua是动态语言类型，变量不需要类型定义，只需要为变量赋值</p><p>lua有8个基本类型：</p><table><thead><tr><th align="left">数据类型</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left">nil</td><td align="left">这个最简单，只有值nil属于该类，表示一个无效值（在条件表达式中相当于false）。</td></tr><tr><td align="left">boolean</td><td align="left">包含两个值：false和true。</td></tr><tr><td align="left">number</td><td align="left">表示双精度类型的实浮点数</td></tr><tr><td align="left">string</td><td align="left">字符串由一对双引号或单引号来表示</td></tr><tr><td align="left">function</td><td align="left">由 C 或 Lua 编写的函数</td></tr><tr><td align="left">userdata</td><td align="left">表示任意存储在变量中的C数据结构</td></tr><tr><td align="left">thread</td><td align="left">表示执行的独立线路，用于执行协同程序</td></tr><tr><td align="left">table</td><td align="left">Lua 中的表（table）其实是一个”关联数组”（associative arrays），数组的索引可以是数字、字符串或表类型。在 Lua 里，table 的创建是通过”构造表达式”来完成，最简单构造表达式是{}，用来创建一个空表。</td></tr></tbody></table><span id="more"></span><h2 id="nil-空"><a href="#nil-空" class="headerlink" title="nil(空)"></a>nil(空)</h2><p>表示没有任何有效值，例如打印一个没有赋值的变量，便会输出一个 nil 值</p><p>对于全局变量和 table，nil 还有一个”删除”作用，给全局变量或者 table 表里的变量赋一个 nil 值，等同于把它们删掉</p><p> type(X) 实质是返回的 <strong>“nil”</strong> 字符串，是一个 string 类型，所以nil作比较时应该加上双引号 <strong>“</strong></p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&gt; <span class="built_in">type</span>(X)</span><br><span class="line"><span class="literal">nil</span></span><br><span class="line">&gt; <span class="built_in">type</span>(X)==<span class="literal">nil</span></span><br><span class="line"><span class="literal">false</span></span><br><span class="line">&gt; <span class="built_in">type</span>(X)==<span class="string">&quot;nil&quot;</span></span><br><span class="line"><span class="literal">true</span></span><br></pre></td></tr></table></figure><h2 id="boolean（布尔）"><a href="#boolean（布尔）" class="headerlink" title="boolean（布尔）"></a>boolean（布尔）</h2><p>boolean 类型只有两个可选值：true（真） 和 false（假），<strong>Lua 把 false 和 nil 看作是 false，其他的都为 true</strong></p><h2 id="number（数字）"><a href="#number（数字）" class="headerlink" title="number（数字）"></a>number（数字）</h2><p>Lua 默认只有一种 number 类型 – double</p><h2 id="string（字符串）"><a href="#string（字符串）" class="headerlink" title="string（字符串）"></a>string（字符串）</h2><p>字符串由一对双引号或单引号来表示。也可以用 2 个方括号 “[[]]” 来表示”一块”字符串。</p><p>在对一个数字字符串上进行算术操作时，Lua 会尝试将这个数字字符串转成一个数字，字符串连接使用的是 ..</p><p>使用 # 来计算字符串的长度，放在字符串前面</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&gt; <span class="built_in">print</span>(<span class="string">&quot;2 + 6&quot;</span>)</span><br><span class="line"><span class="number">2</span> + <span class="number">6</span></span><br><span class="line">&gt; <span class="built_in">print</span>(<span class="number">157</span> .. <span class="number">428</span>)</span><br><span class="line"><span class="number">157428</span></span><br><span class="line"></span><br><span class="line">&gt; <span class="built_in">len</span> = <span class="string">&quot;www.runoob.com&quot;</span></span><br><span class="line">&gt; <span class="built_in">print</span>(#<span class="built_in">len</span>)</span><br><span class="line"><span class="number">14</span></span><br><span class="line">&gt; <span class="built_in">print</span>(#<span class="string">&quot;www.runoob.com&quot;</span>)</span><br><span class="line"><span class="number">14</span></span><br></pre></td></tr></table></figure><h2 id="table（表）"><a href="#table（表）" class="headerlink" title="table（表）"></a>table（表）</h2><p>在 Lua 里，table 的创建是通过”构造表达式”来完成，最简单构造表达式是{}，用来创建一个空表。也可以在表里添加一些数据</p><p>其实是一个”关联数组”（associative arrays），数组的索引可以是数字或者是字符串。</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">a = &#123;&#125;</span><br><span class="line">a[<span class="string">&quot;key&quot;</span>] = <span class="string">&quot;value&quot;</span></span><br><span class="line">key = <span class="number">10</span></span><br><span class="line">a[key] = <span class="number">22</span></span><br><span class="line"><span class="keyword">for</span> k, v <span class="keyword">in</span> <span class="built_in">pairs</span>(a) <span class="keyword">do</span></span><br><span class="line">    <span class="built_in">print</span>(k .. <span class="string">&quot; : &quot;</span> .. v)</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"><span class="comment">--[[执行结果为</span></span><br><span class="line"><span class="comment">key : value</span></span><br><span class="line"><span class="comment">10 : 22</span></span><br><span class="line"><span class="comment">]]</span><span class="comment">--</span></span><br></pre></td></tr></table></figure><p><strong>在 Lua 里表的默认初始索引一般以 1 开始。</strong></p><h2 id="function（函数）"><a href="#function（函数）" class="headerlink" title="function（函数）"></a>function（函数）</h2><p>在 Lua 中，函数是被看作是”第一类值（First-Class Value）”，函数可以存在变量里:</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">factorial1</span><span class="params">(n)</span></span></span><br><span class="line">    <span class="keyword">if</span> n == <span class="number">0</span> <span class="keyword">then</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> n * factorial1(n - <span class="number">1</span>)</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"><span class="built_in">print</span>(factorial1(<span class="number">5</span>))</span><br><span class="line">factorial2 = factorial1</span><br><span class="line"><span class="built_in">print</span>(factorial2(<span class="number">5</span>))</span><br></pre></td></tr></table></figure><p>function 可以以匿名函数的方式通过参数传递:</p><h2 id="thread（线程）"><a href="#thread（线程）" class="headerlink" title="thread（线程）"></a>thread（线程）</h2><p>在 Lua 里，最主要的线程是协同程序（coroutine）。它跟线程（thread）差不多，拥有自己独立的栈、局部变量和指令指针，可以跟其他协同程序共享全局变量和其他大部分东西。</p><p><strong>线程跟协程的区别：线程可以同时多个运行，而协程任意时刻只能运行一个，并且处于运行状态的协程只有被挂起（suspend）时才会暂停。</strong></p><h2 id="userdata（自定义类型）"><a href="#userdata（自定义类型）" class="headerlink" title="userdata（自定义类型）"></a>userdata（自定义类型）</h2><p>userdata 是一种用户自定义数据，用于表示一种由应用程序或 C&#x2F;C++ 语言库所创建的类型，可以将任意 C&#x2F;C++ 的任意数据类型的数据（通常是 struct 和 指针）存储到 Lua 变量中调用。</p><h1 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h1><p>Lua 变量有三种类型：全局变量、局部变量、表中的域。</p><p><strong>Lua 中的变量默认为全局变量且默认值均为 nil</strong>，哪怕是语句块或是函数里，除非用 local 显式声明为局部变量。</p><h2 id="赋值"><a href="#赋值" class="headerlink" title="赋值"></a>赋值</h2><p>Lua 可以对多个变量同时赋值，变量列表和值列表的各个元素用逗号分开，赋值语句右边的值会依次赋给左边的变量。</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">a, b = <span class="number">10</span>, <span class="number">2</span>*x       <span class="comment">--&gt;       a=10; b=2*x</span></span><br></pre></td></tr></table></figure><p>遇到赋值语句Lua会先计算右边所有的值然后再执行赋值操作，所以我们可以这样进行交换变量的值：</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">x, y = y, x                     <span class="comment">-- swap &#x27;x&#x27; for &#x27;y&#x27;</span></span><br></pre></td></tr></table></figure><p>但变量个数大于值的个数时，会用nil补足；若小于值的个数则多余的值会被忽略</p><h1 id="流程控制"><a href="#流程控制" class="headerlink" title="流程控制"></a>流程控制</h1><h2 id="循环"><a href="#循环" class="headerlink" title="循环"></a>循环</h2><h3 id="for"><a href="#for" class="headerlink" title="for"></a>for</h3><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> var=exp1,exp2,exp3 <span class="keyword">do</span>  </span><br><span class="line">    &lt;执行体&gt;  </span><br><span class="line"><span class="keyword">end</span>  </span><br><span class="line"><span class="comment">-- var 从 exp1 变化到 exp2，每次变化以 exp3 为步长递增 var，并执行一次 &quot;执行体&quot;。exp3 是可选的，如果不指定，默认为1。</span></span><br></pre></td></tr></table></figure><p>三个表达式都只会在循环开始前执行一次求值，之后不再求值</p><p><strong>泛型：</strong></p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">a = &#123;<span class="string">&quot;one&quot;</span>, <span class="string">&quot;two&quot;</span>, <span class="string">&quot;three&quot;</span>&#125;</span><br><span class="line"><span class="keyword">for</span> i, v <span class="keyword">in</span> <span class="built_in">ipairs</span>(a) <span class="keyword">do</span></span><br><span class="line">    <span class="built_in">print</span>(i, v)</span><br><span class="line"><span class="keyword">end</span> </span><br></pre></td></tr></table></figure><blockquote><p>在lua中pairs与ipairs两个迭代器的用法相近，但有一点是不一样的：</p><p>pairs可以遍历表中所有的key，并且除了迭代器本身以及遍历表本身还可以返回nil;</p><p>但是ipairs则不能返回nil,只能返回数字0，如果遇到nil则退出。它只能遍历到表中出现的第一个不是整数的key</p></blockquote><h3 id="repeat"><a href="#repeat" class="headerlink" title="repeat"></a>repeat</h3><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">repeat</span></span><br><span class="line">   statements</span><br><span class="line"><span class="keyword">until</span>( condition )</span><br></pre></td></tr></table></figure><p>条件进行判断前循环体都会执行一次。</p><p>如果条件判断为 false，循环会重新开始执行，直到为 true 才会停止执行</p><h2 id="判断"><a href="#判断" class="headerlink" title="判断"></a>判断</h2><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(布尔表达式)</span><br><span class="line"><span class="keyword">then</span></span><br><span class="line">   <span class="comment">--[ 在布尔表达式为 true 时执行的语句 --]</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">   <span class="comment">--[ 布尔表达式为 false 时执行该语句块 --]</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><h1 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h1><p><strong>函数定义格式：</strong></p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">optional_function_scope <span class="function"><span class="keyword">function</span> <span class="title">function_name</span><span class="params">( argument1, argument2, argument3..., argumentn)</span></span></span><br><span class="line">    function_body</span><br><span class="line">    <span class="keyword">return</span> result_params_comma_separated</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><ul><li><strong>optional_function_scope:</strong> 未设置该参数默认为全局函数，如果你需要设置函数为局部函数需要使用关键字 <strong>local</strong>。</li><li><strong>function_name:</strong> 指定函数名称。</li><li><strong>argument1, argument2, argument3…, argumentn:</strong> 函数参数，多个参数以逗号隔开，函数也可以不带参数。</li><li><strong>function_body:</strong> 函数体，函数中需要执行的代码语句块。</li><li><strong>result_params_comma_separated:</strong> 函数返回值，<strong>Lua语言函数可以返回多个值，每个值以逗号隔开。</strong></li></ul><h2 id="多返回值"><a href="#多返回值" class="headerlink" title="多返回值"></a>多返回值</h2><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">maximum</span> <span class="params">(a)</span></span></span><br><span class="line">    <span class="keyword">local</span> mi = <span class="number">1</span>             <span class="comment">-- 最大值索引</span></span><br><span class="line">    <span class="keyword">local</span> m = a[mi]          <span class="comment">-- 最大值</span></span><br><span class="line">    <span class="keyword">for</span> i,val <span class="keyword">in</span> <span class="built_in">ipairs</span>(a) <span class="keyword">do</span></span><br><span class="line">       <span class="keyword">if</span> val &gt; m <span class="keyword">then</span></span><br><span class="line">           mi = i</span><br><span class="line">           m = val</span><br><span class="line">       <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">return</span> m, mi</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(maximum(&#123;<span class="number">8</span>,<span class="number">10</span>,<span class="number">23</span>,<span class="number">12</span>,<span class="number">5</span>&#125;))</span><br><span class="line"><span class="comment">--输出23   3</span></span><br></pre></td></tr></table></figure><h2 id="可变参数"><a href="#可变参数" class="headerlink" title="可变参数"></a>可变参数</h2><p>Lua 函数可以接受可变数目的参数，<strong>在函数参数列表中使用三点 … 表示函数有可变的参数。</strong></p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span><span class="params">(...)</span></span>  </span><br><span class="line"><span class="keyword">local</span> s = <span class="number">0</span>  </span><br><span class="line">  <span class="keyword">for</span> i, v <span class="keyword">in</span> <span class="built_in">ipairs</span>&#123;...&#125; <span class="keyword">do</span>   <span class="comment">--&gt; &#123;...&#125; 表示一个由所有变长参数构成的数组  </span></span><br><span class="line">    s = s + v  </span><br><span class="line">  <span class="keyword">end</span>  </span><br><span class="line">  <span class="keyword">return</span> s  </span><br><span class="line"><span class="keyword">end</span>  </span><br><span class="line"><span class="built_in">print</span>(add(<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>))  <span class="comment">---&gt;25</span></span><br></pre></td></tr></table></figure><p>通常在遍历变长参数的时候只需要使用 <strong>{…}<strong>，然而变长参数可能会包含一些 <strong>nil</strong>，那么就可以用 <strong>select</strong> 函数来访问变长参数了：</strong>select(‘#’, …)</strong> 或者 <strong>select(n, …)</strong></p><ul><li><strong>select(‘#’, …)</strong> 返回可变参数的长度</li><li><strong>select(n, …)</strong> 用于返回从起点 <strong>n</strong> 开始到结束位置的所有参数列表。</li></ul><p><strong>来获取可变参数的数量:</strong></p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">test</span><span class="params">(...)</span></span></span><br><span class="line">   <span class="built_in">print</span>(<span class="string">&quot;总共传入 &quot;</span> .. <span class="built_in">select</span>(<span class="string">&quot;#&quot;</span>,...) .. <span class="string">&quot; 个数&quot;</span>)</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(test(<span class="number">10</span>,<span class="number">5</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>))</span><br><span class="line"><span class="comment">-- 总共传入 6 个数</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span><span class="params">(...)</span></span></span><br><span class="line">    a = <span class="built_in">select</span>(<span class="number">3</span>,...)  <span class="comment">--&gt;从第三个位置开始，变量 a 对应右边变量列表的第一个参数</span></span><br><span class="line">    <span class="built_in">print</span> (a)</span><br><span class="line">    <span class="built_in">print</span> (<span class="built_in">select</span>(<span class="number">3</span>,...)) <span class="comment">--&gt;打印所有列表参数</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">f(<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>)</span><br><span class="line"><span class="comment">--[[ 输出结果：</span></span><br><span class="line"><span class="comment">2</span></span><br><span class="line"><span class="comment">2 3 4 5--]]</span></span><br></pre></td></tr></table></figure><h1 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h1><p>Lua 语言中字符串可以使用以下三种方式来表示：</p><ul><li>单引号间的一串字符。</li><li>双引号间的一串字符。</li><li><strong>[[</strong> 与 <strong>]]</strong> 间的一串字符。</li></ul><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">string1 = <span class="string">&quot;Lua&quot;</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;\&quot;字符串 1 是\&quot;&quot;</span>,string1)</span><br><span class="line">string2 = <span class="string">&#x27;runoob.com&#x27;</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;字符串 2 是&quot;</span>,string2)</span><br><span class="line"></span><br><span class="line">string3 = <span class="string">[[&quot;Lua 教程&quot;]]</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;字符串 3 是&quot;</span>,string3)</span><br><span class="line"><span class="comment">--[[&quot;字符串 1 是&quot;    Lua</span></span><br><span class="line"><span class="comment">字符串 2 是    runoob.com</span></span><br><span class="line"><span class="comment">字符串 3 是    &quot;Lua 教程&quot;--]]</span></span><br></pre></td></tr></table></figure><h2 id="字符串操作"><a href="#字符串操作" class="headerlink" title="字符串操作"></a>字符串操作</h2><table><thead><tr><th>方法</th><th>用途</th></tr></thead><tbody><tr><td>string.upper(argument)</td><td>全部转为大写字母</td></tr><tr><td>string.lower(argument)</td><td>全部转为小写字母</td></tr><tr><td><strong>string.gsub(mainString,findString,replaceString,num)</strong></td><td>mainString 为要操作的字符串， findString 为被替换的字符，replaceString 要替换的字符，num 替换次数（可以忽略，则全部替换）</td></tr><tr><td><strong>string.find (str, substr, [init, [plain]])</strong></td><td>在一个指定字符串 str 中搜索指定内容 substr，如果找到了匹配子串，就会返回这个子串的起始索引和结束索引，不存在则返回 nil。</td></tr><tr><td>string.sub(s, i [, j])</td><td>用于截取字符串，  <strong>s：</strong>要截取的字符串。 <strong>i：</strong>截取开始位置。 <strong>j：</strong>截取结束位置，默认为 -1，最后一个字符。</td></tr><tr><td><strong>string.rep(string, n)</strong></td><td>返回字符串string的n个拷贝，&gt; string.rep(“abcd”,2) 输出abcdabcd</td></tr><tr><td><strong>string.len(arg)</strong></td><td>计算字符串长度</td></tr></tbody></table><h1 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h1><p>Lua 数组的索引键值可以使用整数表示，<strong>数组的大小不是固定的。</strong></p><h2 id="一维数组"><a href="#一维数组" class="headerlink" title="一维数组"></a>一维数组</h2><p>其逻辑结构是线性表。一维数组可以用for循环出数组中的元素</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">array = &#123;<span class="string">&quot;Lua&quot;</span>, <span class="string">&quot;Tutorial&quot;</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i= <span class="number">0</span>, <span class="number">2</span> <span class="keyword">do</span></span><br><span class="line">   <span class="built_in">print</span>(array[i])</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="comment">--以上代码执行输出结果为：</span></span><br><span class="line"></span><br><span class="line"><span class="literal">nil</span> <span class="comment">-- 因为lua下标从1开始，所以0下标元素为nil</span></span><br><span class="line">Lua</span><br><span class="line">Tutorial</span><br></pre></td></tr></table></figure><p>我们还能指定负数为索引</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">array = &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i= <span class="number">-2</span>, <span class="number">2</span> <span class="keyword">do</span></span><br><span class="line">   array[i] = i *<span class="number">2</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i = <span class="number">-2</span>,<span class="number">2</span> <span class="keyword">do</span></span><br><span class="line">   <span class="built_in">print</span>(array[i])</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><h2 id="多维数组"><a href="#多维数组" class="headerlink" title="多维数组"></a>多维数组</h2><p>一维数组的索引键对应一个数组</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 初始化数组</span></span><br><span class="line">array = &#123;&#125;</span><br><span class="line"><span class="keyword">for</span> i=<span class="number">1</span>,<span class="number">3</span> <span class="keyword">do</span></span><br><span class="line">   array[i] = &#123;&#125;</span><br><span class="line">      <span class="keyword">for</span> j=<span class="number">1</span>,<span class="number">3</span> <span class="keyword">do</span></span><br><span class="line">         array[i][j] = i*j</span><br><span class="line">      <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><h1 id="table（表）-1"><a href="#table（表）-1" class="headerlink" title="table（表）"></a>table（表）</h1><p>Lua table 使用关联型数组，你可以用任意类型的值来作数组的索引，但这个值不能是 nil。</p><p>Lua table 是不固定大小的，你可以根据自己需要进行扩容。</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 初始化表</span></span><br><span class="line">mytable = &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 指定值</span></span><br><span class="line">mytable[<span class="number">1</span>]= <span class="string">&quot;Lua&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 移除引用</span></span><br><span class="line">mytable = <span class="literal">nil</span></span><br><span class="line"><span class="comment">-- lua 垃圾回收会释放内存</span></span><br></pre></td></tr></table></figure><h2 id="Table-操作"><a href="#Table-操作" class="headerlink" title="Table 操作"></a>Table 操作</h2><table><thead><tr><th>方法</th><th>用途</th></tr></thead><tbody><tr><td><strong>table.insert (table, [pos,] value）</strong></td><td>在table的数组部分指定位置(pos)插入值为value的一个元素. pos参数可选, 默认为数组部分末尾.</td></tr><tr><td><strong>table.remove (table [, pos])</strong></td><td>返回table数组部分位于pos位置的元素. 其后的元素会被前移. pos参数可选, 默认为table长度, 即从最后一个元素删起。</td></tr><tr><td><strong>table.sort (table [, comp])</strong></td><td>对给定的table进行升序排序。</td></tr><tr><td><strong>table.concat (table [, sep [, start [, end]]]):</strong></td><td>concat是concatenate(连锁, 连接)的缩写. table.concat()函数列出参数中指定table的数组部分从start位置到end位置的所有元素, 元素间以指定的分隔符(sep)隔开。</td></tr></tbody></table><blockquote><p>当我们获取 table 的长度的时候无论是使用 <strong>#</strong> 还是 <strong>table.getn</strong> 其都会在索引中断的地方停止计数，而导致无法正确取得 table 的长度。</p><p>可以使用以下方法来代替：</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">table_leng</span><span class="params">(t)</span></span></span><br><span class="line"><span class="keyword">local</span> leng=<span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> k, v <span class="keyword">in</span> <span class="built_in">pairs</span>(t) <span class="keyword">do</span></span><br><span class="line"> leng=leng+<span class="number">1</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"><span class="keyword">return</span> leng;</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure></blockquote><h1 id="Metatable（元表）"><a href="#Metatable（元表）" class="headerlink" title="Metatable（元表）"></a>Metatable（元表）</h1><p>Lua无法对两个table进行操作（比如相加），<strong>因此lua提供了metatable，允许我们改变table的行为</strong>。</p><p>任何表变量都可以作为另一个表变量的元表，当我们在表中进行一些特定操作的时候会执行元表当中的内容</p><blockquote><p>当 Lua 试图对两个表进行相加时，先检查两者之一是否有元表，之后检查是否有一个叫 <strong>__add</strong> 的字段，若找到，则调用对应的值。 <strong>__add</strong> 等即时字段，其对应的值（往往是一个函数或是 table）就是”元方法”。</p></blockquote><p>有两个重要函数来处理元表：</p><ul><li><strong>setmetatable(table,metatable):</strong> 对指定 table 设置元表(metatable)，如果元表(metatable)中存在 __metatable 键值，setmetatable 会失败。</li><li><strong>getmetatable(table):</strong> 返回对象的元表(metatable)。</li></ul><p>代码示例：</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">myTable1 = &#123;&#125;                          <span class="comment">-- 普通表</span></span><br><span class="line">meta1 = &#123;&#125;                      <span class="comment">-- 元表</span></span><br><span class="line"><span class="built_in">setmetatable</span>(myTable1,meta1)     <span class="comment">-- 把 meta1 设为 myTable1 的元表</span></span><br><span class="line"><span class="built_in">getmetatable</span>(myTable1)                 <span class="comment">-- meta1</span></span><br></pre></td></tr></table></figure><h2 id="tostring元方法"><a href="#tostring元方法" class="headerlink" title="__tostring元方法"></a>__tostring元方法</h2><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">meta2 = &#123;</span><br><span class="line"><span class="comment">-- 当要被当做字符串使用时，会默认调用该方法</span></span><br><span class="line">    <span class="built_in">__tostring</span> = <span class="function"><span class="keyword">function</span><span class="params">(t)</span></span></span><br><span class="line">        <span class="keyword">return</span> t.name</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">&#125;</span><br><span class="line">myTable2 =&#123;</span><br><span class="line">    name = <span class="string">&quot;Name&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">setmetatable</span>(myTable2, meta2)</span><br><span class="line"><span class="built_in">print</span>(myTable2)</span><br></pre></td></tr></table></figure><h2 id="call元方法"><a href="#call元方法" class="headerlink" title="__call元方法"></a>__call元方法</h2><p>__call 元方法会在表被当作函数使用的时候调用                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          </p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">meta3 = &#123;</span><br><span class="line">    <span class="comment">-- 注意第一个参数是表本身，类似于 : 调用</span></span><br><span class="line"><span class="built_in">__call</span> = <span class="function"><span class="keyword">function</span><span class="params">(a,b)</span></span></span><br><span class="line">        <span class="built_in">print</span>(a)</span><br><span class="line">        <span class="built_in">print</span>(b)</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;__call被调用&quot;</span>)</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">&#125;</span><br><span class="line">myTable3 = &#123;&#125;</span><br><span class="line"><span class="built_in">setmetatable</span>(myTable3, meta3)</span><br><span class="line"></span><br><span class="line">myTable3(<span class="number">1</span>)</span><br><span class="line"><span class="comment">--[[输出结果</span></span><br><span class="line"><span class="comment">table: 00A89640</span></span><br><span class="line"><span class="comment">1</span></span><br><span class="line"><span class="comment">__call被调用</span></span><br><span class="line"><span class="comment">--]]</span></span><br></pre></td></tr></table></figure><h2 id="index元方法"><a href="#index元方法" class="headerlink" title="__index元方法"></a>__index元方法</h2><p>当你通过键来访问 table 的时候，<strong>如果这个键没有值，那么Lua就会寻找该table的metatable（假定有metatable）中的index 键。</strong></p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">meta = &#123;</span><br><span class="line">    <span class="built_in">__index</span> = &#123;age = <span class="number">1</span>&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">-- 注意!如果表找不到某一属性是去 元表的__index 查找</span></span><br><span class="line"><span class="comment">-- 也可以在外面写 meta.__index = &#123;age = 1&#125;</span></span><br><span class="line"></span><br><span class="line">myTable = &#123;&#125;</span><br><span class="line"><span class="built_in">setmetatable</span>(myTable, meta)</span><br><span class="line"><span class="built_in">print</span>(myTable.age)</span><br></pre></td></tr></table></figure><p><strong>总结</strong></p><p>Lua 查找一个表元素时的规则，其实就是如下 3 个步骤:</p><ul><li>1.在表中查找，如果找到，返回该元素，找不到则继续</li><li>2.判断该表是否有元表，如果没有元表，返回 nil，有元表则继续。</li><li>3.判断元表有没有 __index 方法，如果 __index 方法为 nil，则返回 nil；如果 __index 方法是一个表，则重复 1、2、3；如果 __index 方法是一个函数，则返回该函数的返回值。</li></ul><h2 id="newindex-元方法"><a href="#newindex-元方法" class="headerlink" title="__newindex 元方法"></a>__newindex 元方法</h2><p>__newindex 元方法用来对表更新，__index则用来对表访问 。</p><p>当你给表的一个缺少的索引赋值，解释器就会查找__newindex 元方法：如果存在则将这个值赋值到newindex所指向的表中，不会修改自己</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">meta = &#123;&#125;</span><br><span class="line">meta.<span class="built_in">__newindex</span> = &#123;&#125;</span><br><span class="line">myTable = &#123;&#125;</span><br><span class="line"><span class="built_in">setmetatable</span>(myTable, meta)</span><br><span class="line"></span><br><span class="line">myTable.age = <span class="number">1</span></span><br><span class="line"><span class="built_in">print</span>(myTable.age)</span><br><span class="line"><span class="comment">-- 输出 nil</span></span><br></pre></td></tr></table></figure><p>此外，可以使用 <code>rawset</code> 和 <code>rawget</code>来设置和获取当前表的变量，而不在元表中获取</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span>(<span class="built_in">rawget</span>(myTable, <span class="string">&quot;age&quot;</span>)) <span class="comment">-- 输出nil</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">rawset</span>(myTable, <span class="string">&quot;age&quot;</span>, <span class="number">2</span>) </span><br><span class="line"><span class="built_in">print</span>(myTable.age) <span class="comment">-- 输出 2</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">rawget</span>(myTable, <span class="string">&quot;age&quot;</span>)) <span class="comment">-- 输出2</span></span><br></pre></td></tr></table></figure><h2 id="运算符元方法"><a href="#运算符元方法" class="headerlink" title="运算符元方法"></a>运算符元方法</h2><table><thead><tr><th align="left">模式</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left">__add</td><td align="left">对应的运算符 ‘+’.</td></tr><tr><td align="left">__sub</td><td align="left">对应的运算符 ‘-‘.</td></tr><tr><td align="left">__mul</td><td align="left">对应的运算符 ‘*’.</td></tr><tr><td align="left">__div</td><td align="left">对应的运算符 ‘&#x2F;‘.</td></tr><tr><td align="left">__mod</td><td align="left">对应的运算符 ‘%’.</td></tr><tr><td align="left">__unm</td><td align="left">对应的运算符 ‘-‘.</td></tr><tr><td align="left">__concat</td><td align="left">对应的运算符 ‘..’.</td></tr><tr><td align="left">__eq</td><td align="left">对应的运算符 ‘&#x3D;&#x3D;’.</td></tr><tr><td align="left">__lt</td><td align="left">对应的运算符 ‘&lt;’.</td></tr><tr><td align="left">__le</td><td align="left">对应的运算符 ‘&lt;&#x3D;’.</td></tr></tbody></table><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">meta = &#123;</span><br><span class="line"><span class="built_in">__add</span> = <span class="function"><span class="keyword">function</span><span class="params">(t1,t2)</span></span></span><br><span class="line"><span class="keyword">return</span> t1.age + t2.age</span><br><span class="line"><span class="keyword">end</span>, <span class="comment">-- 注意用 , 隔开 </span></span><br><span class="line"><span class="built_in">__sub</span> = <span class="function"><span class="keyword">function</span><span class="params">(t1,t2)</span></span></span><br><span class="line"><span class="keyword">return</span> t1.age - t2.age</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">myTable1 = &#123;age = <span class="number">1</span>&#125;</span><br><span class="line"><span class="built_in">setmetatable</span>(myTable1, meta)</span><br><span class="line">myTable2 = &#123;age = <span class="number">2</span>&#125;</span><br><span class="line"><span class="built_in">setmetatable</span>(myTable2, meta)</span><br></pre></td></tr></table></figure><p>注意如果要重载比较预算符的话，要两个表的元表都相同才是能做比较</p><h1 id="模块与包"><a href="#模块与包" class="headerlink" title="模块与包"></a>模块与包</h1><p>可以把一些公用的代码放在一个文件里，以 API 接口的形式在其他地方调用，有利于代码的重用和降低代码耦合度。</p><p>Lua 的模块是由变量、函数等已知元素组成的 table，因此创建一个模块很简单，就是创建一个 table，然后把需要导出的常量、函数放入其中，最后返回这个 table 就行。</p><p>创建自定义模块 <code>module.lua</code></p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 文件名为 module.lua</span></span><br><span class="line"><span class="comment">-- 定义一个名为 module 的模块</span></span><br><span class="line"><span class="built_in">module</span> = &#123;&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">-- 定义一个常量</span></span><br><span class="line"><span class="built_in">module</span>.constant = <span class="string">&quot;这是一个常量&quot;</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">-- 定义一个函数</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">module.func1</span><span class="params">()</span></span></span><br><span class="line">    <span class="built_in">io</span>.<span class="built_in">write</span>(<span class="string">&quot;这是一个公有函数！\n&quot;</span>)</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">local</span> <span class="function"><span class="keyword">function</span> <span class="title">func2</span><span class="params">()</span></span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;这是一个私有函数！&quot;</span>)</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">module.func3</span><span class="params">()</span></span></span><br><span class="line">    func2()</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="built_in">module</span></span><br></pre></td></tr></table></figure><p>func2 声明为程序块的局部变量，即表示一个私有函数</p><h2 id="加载"><a href="#加载" class="headerlink" title="加载"></a>加载</h2><p>Lua提供了一个名为require的函数用来加载模块。 <code>require(&quot;&lt;模块名&gt;&quot;)</code></p><p>可以直接使用<code>module.constant</code>，也可以使用别名</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- test_module2.lua 文件</span></span><br><span class="line"><span class="comment">-- module 模块为上文提到到 module.lua</span></span><br><span class="line"><span class="comment">-- 别名变量 m</span></span><br><span class="line"><span class="keyword">local</span> m = <span class="built_in">require</span>(<span class="string">&quot;module&quot;</span>)</span><br><span class="line"> </span><br><span class="line"><span class="built_in">print</span>(m.constant)</span><br><span class="line"> </span><br><span class="line">m.func3()</span><br></pre></td></tr></table></figure><h2 id="加载路径"><a href="#加载路径" class="headerlink" title="加载路径"></a>加载路径</h2><p>对于自定义的模块，模块文件不是放在哪个文件目录都行，函数 require 有它自己的文件路径加载策略，它会尝试从 Lua 文件或 C 程序库中加载模块。</p><p>Lua和C是很容易结合的，与Lua中写包不同，C包在使用以前必须首先加载并连接，在大多数系统中最容易的实现方式是通过动态连接库机制。</p><p>loadlib 函数加载指定的库并且连接到 Lua，然而它并不打开库（也就是说没有调用初始化函数），反之他返回初始化函数作为 Lua 的一个函数，这样我们就可以直接在Lua中调用他。</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">local</span> <span class="built_in">path</span> = <span class="string">&quot;/usr/local/lua/lib/libluasocket.so&quot;</span></span><br><span class="line"><span class="comment">-- 或者 path = &quot;C:\\windows\\luasocket.dll&quot;，这是 Window 平台下</span></span><br><span class="line"><span class="keyword">local</span> f = <span class="built_in">assert</span>(<span class="built_in">loadlib</span>(<span class="built_in">path</span>, <span class="string">&quot;luaopen_socket&quot;</span>))</span><br><span class="line">f()  <span class="comment">-- 真正打开库</span></span><br></pre></td></tr></table></figure><h1 id="协同程序"><a href="#协同程序" class="headerlink" title="协同程序"></a>协同程序</h1><p>Lua 协同程序(coroutine)与线程比较类似：拥有独立的堆栈，独立的局部变量，独立的指令指针，同时又与其它协同程序共享全局变量和其它大部分东西。</p><h2 id="线程和协同程序区别"><a href="#线程和协同程序区别" class="headerlink" title="线程和协同程序区别"></a>线程和协同程序区别</h2><p>线程与协同程序的主要区别在于，一个具有多个线程的程序可以同时运行几个线程，而协同程序却需要彼此协作的运行。</p><p>在任一指定时刻只有一个协同程序在运行，并且这个正在运行的协同程序只有在明确的被要求挂起的时候才会被挂起。</p><p>协同程序有点类似同步的多线程，在等待同一个线程锁的几个线程有点类似协同。</p><h2 id="基本语法"><a href="#基本语法" class="headerlink" title="基本语法"></a>基本语法</h2><table><thead><tr><th align="left">方法</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left">coroutine.create()</td><td align="left">创建 coroutine，返回 coroutine， 参数是一个函数，当和 resume 配合使用的时候就唤醒函数调用</td></tr><tr><td align="left">coroutine.resume()</td><td align="left">重启 coroutine，和 create 配合使用</td></tr><tr><td align="left">coroutine.yield()</td><td align="left">挂起 coroutine，将 coroutine 设置为挂起状态，这个和 resume 配合使用能有很多有用的效果</td></tr><tr><td align="left">coroutine.status()</td><td align="left">查看 coroutine 的状态 注：coroutine 的状态有三种：dead，suspended，running</td></tr><tr><td align="left">coroutine.wrap（）</td><td align="left">创建 coroutine，返回一个函数，一旦你调用这个函数，就进入 coroutine，和 create 功能重复</td></tr><tr><td align="left">coroutine.running()</td><td align="left">返回正在跑的 coroutine，一个 coroutine 就是一个线程，当使用running的时候，就是返回一个 corouting 的线程号</td></tr></tbody></table><p>coroutine.running就可以看出来,coroutine在底层实现就是一个线程。</p><p>当create一个coroutine的时候就是在新线程中注册了一个事件。</p><p>当使用resume触发事件的时候，create的coroutine函数就被执行了，当遇到yield的时候就代表挂起当前线程，等候再次resume触发事件。</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">co = <span class="built_in">coroutine</span>.<span class="built_in">create</span>(<span class="function"><span class="keyword">function</span> <span class="params">(a)</span></span></span><br><span class="line">    <span class="keyword">local</span> r = <span class="built_in">coroutine</span>.<span class="built_in">yield</span>(a+<span class="number">1</span>)       <span class="comment">-- yield()返回a+1给调用它的resume()函数，即2</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;r=&quot;</span> ..r)                       <span class="comment">-- r的值是第2次resume()传进来的，100</span></span><br><span class="line"><span class="keyword">end</span>)</span><br><span class="line"><span class="built_in">status</span>, r = <span class="built_in">coroutine</span>.<span class="built_in">resume</span>(co, <span class="number">1</span>)     <span class="comment">-- resume()返回两个值，一个是自身的状态true，一个是yield的返回值2</span></span><br><span class="line"><span class="built_in">coroutine</span>.<span class="built_in">resume</span>(co, <span class="number">100</span>)     <span class="comment">--resume()返回true</span></span><br><span class="line"></span><br><span class="line"><span class="comment">------------输出结果</span></span><br><span class="line">r=<span class="number">100</span> <span class="comment">--只会打印一次</span></span><br></pre></td></tr></table></figure><ul><li><p>调用resume，将协同程序唤醒,resume操作成功返回true，否则返回false；           </p></li><li><p>resume处于主程中，它将外部状态（数据）传入到协同程序内部；而yield则将内部的状态（数据）返回到主程中。</p></li></ul><p>更详细的一个实例</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span> <span class="params">(a)</span></span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;foo 函数输出&quot;</span>, a)</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">coroutine</span>.<span class="built_in">yield</span>(<span class="number">2</span> * a) <span class="comment">-- 返回  2*a 的值</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"> </span><br><span class="line">co = <span class="built_in">coroutine</span>.<span class="built_in">create</span>(<span class="function"><span class="keyword">function</span> <span class="params">(a , b)</span></span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;第一次协同程序执行输出&quot;</span>, a, b) <span class="comment">-- co-body 1 10</span></span><br><span class="line">    <span class="keyword">local</span> r = foo(a + <span class="number">1</span>)</span><br><span class="line">     </span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;第二次协同程序执行输出&quot;</span>, r)</span><br><span class="line">    <span class="keyword">local</span> r, s = <span class="built_in">coroutine</span>.<span class="built_in">yield</span>(a + b, a - b)  <span class="comment">-- a，b的值为第一次调用协同程序时传入</span></span><br><span class="line">     </span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;第三次协同程序执行输出&quot;</span>, r, s)</span><br><span class="line">    <span class="keyword">return</span> b, <span class="string">&quot;结束协同程序&quot;</span>                   <span class="comment">-- b的值为第二次调用协同程序时传入</span></span><br><span class="line"><span class="keyword">end</span>)</span><br><span class="line">       </span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;main&quot;</span>, <span class="built_in">coroutine</span>.<span class="built_in">resume</span>(co, <span class="number">1</span>, <span class="number">10</span>)) <span class="comment">-- true, 4</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;--分割线----&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;main&quot;</span>, <span class="built_in">coroutine</span>.<span class="built_in">resume</span>(co, <span class="string">&quot;r&quot;</span>)) <span class="comment">-- true 11 -9</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;---分割线---&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;main&quot;</span>, <span class="built_in">coroutine</span>.<span class="built_in">resume</span>(co, <span class="string">&quot;x&quot;</span>, <span class="string">&quot;y&quot;</span>)) <span class="comment">-- true 10 end</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;---分割线---&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;main&quot;</span>, <span class="built_in">coroutine</span>.<span class="built_in">resume</span>(co, <span class="string">&quot;x&quot;</span>, <span class="string">&quot;y&quot;</span>)) <span class="comment">-- cannot resume dead coroutine</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;---分割线---&quot;</span>)</span><br></pre></td></tr></table></figure><p>输出结果</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">第一次协同程序执行输出    1    10</span><br><span class="line">foo 函数输出    2</span><br><span class="line">main    true    4</span><br><span class="line">--分割线----</span><br><span class="line">第二次协同程序执行输出    r</span><br><span class="line">main    true    11    -9</span><br><span class="line">---分割线---</span><br><span class="line">第三次协同程序执行输出    x    y</span><br><span class="line">main    true    10    结束协同程序</span><br><span class="line">---分割线---</span><br><span class="line">main    false    cannot resume dead coroutine</span><br><span class="line">---分割线---</span><br></pre></td></tr></table></figure><h1 id="迭代器"><a href="#迭代器" class="headerlink" title="迭代器"></a>迭代器</h1><p>迭代器（iterator）是一种对象，它能够用来遍历标准模板库容器中的部分或全部元素，每个迭代器对象代表容器中的确定的地址。</p><h2 id="ipairs-和-pairs"><a href="#ipairs-和-pairs" class="headerlink" title="ipairs 和 pairs"></a>ipairs 和 pairs</h2><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">t = &#123;[<span class="number">0</span>] = <span class="number">1</span>, <span class="number">2</span>, [<span class="number">-1</span>] = <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, [<span class="number">5</span>] = <span class="number">6</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- ipairs遍历</span></span><br><span class="line"><span class="comment">-- ipairs遍历还是从1开始往后遍历， &lt;= 0的值都无法遍历，而且如果不连续中断，也无法遍历后面的值</span></span><br><span class="line"><span class="keyword">for</span> k, v <span class="keyword">in</span> <span class="built_in">ipairs</span>(t) <span class="keyword">do</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;ipairs遍历&quot;</span>..k..<span class="string">&quot;-&quot;</span>..v)</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"><span class="comment">-- 只能得到 2，4，5</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- pairs遍历</span></span><br><span class="line"><span class="comment">-- 能够把所有的键都找到，通过键也就能得到值</span></span><br><span class="line"><span class="keyword">for</span> k, v <span class="keyword">in</span> <span class="built_in">pairs</span>(t) <span class="keyword">do</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;pairs遍历&quot;</span>..k..<span class="string">&quot;-&quot;</span>..v)</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><p>上面代码中，i,k, v分别为变量列表的索引、键、值；pairs(t)为表达式列表。</p><p>在Lua中我们常常使用函数来描述迭代器，每次调用该函数就返回集合的下一个元素。Lua 的迭代器包含以下两种类型：</p><ul><li>无状态的迭代器</li><li>多状态的迭代器</li></ul><h2 id="无状态的迭代器"><a href="#无状态的迭代器" class="headerlink" title="无状态的迭代器"></a>无状态的迭代器</h2><p>无状态的迭代器是指不保留任何状态的迭代器，因此在循环中我们可以利用无状态迭代器避免创建闭包花费额外的代价。</p><p>每一次迭代，迭代函数都是用两个变量（状态常量和控制变量）的值作为参数被调用，一个无状态的迭代器只利用这两个值可以获取下一个元素。</p><p>这种无状态迭代器的典型的简单的例子是 ipairs，它遍历数组的每一个元素，元素的索引需要是数值。</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 函数定义</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">square</span><span class="params">(iteratorMaxCount,currentNumber)</span></span></span><br><span class="line">   <span class="keyword">if</span> currentNumber&lt;iteratorMaxCount</span><br><span class="line">   <span class="keyword">then</span></span><br><span class="line">      currentNumber = currentNumber+<span class="number">1</span></span><br><span class="line">   <span class="keyword">return</span> currentNumber, currentNumber*currentNumber</span><br><span class="line">   <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 迭代器遍历</span></span><br><span class="line"><span class="keyword">for</span> i,n <span class="keyword">in</span> square,<span class="number">3</span>,<span class="number">0</span></span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">   <span class="built_in">print</span>(i,n)</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><p><strong>迭代的状态包括被遍历的表（循环过程中不会改变的状态常量）和当前的索引下标（控制变量）</strong></p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">iter</span> <span class="params">(a, i)</span></span></span><br><span class="line">    i = i + <span class="number">1</span></span><br><span class="line">    <span class="keyword">local</span> v = a[i]</span><br><span class="line">    <span class="keyword">if</span> v <span class="keyword">then</span></span><br><span class="line">       <span class="keyword">return</span> i, v</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">ipairs</span> <span class="params">(a)</span></span></span><br><span class="line">    <span class="keyword">return</span> iter, a, <span class="number">0</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><p>当 Lua 调用 ipairs(a) 开始循环时，他获取三个值：迭代函数 iter、状态常量 a、控制变量初始值 0；</p><p>然后 Lua 调用 iter(a,0) 返回 1, a[1]（除非 a[1]&#x3D;nil）；</p><p>第二次迭代调用 iter(a,1) 返回 2, a[2]……直到第一个 nil 元素。</p><h2 id="多状态的迭代器"><a href="#多状态的迭代器" class="headerlink" title="多状态的迭代器"></a>多状态的迭代器</h2><p>迭代器需要保存多个状态信息而不是简单的状态常量和控制变量</p><p>一种方法就是将所有的状态信息封装到 table 内，将 table 作为迭代器的状态常量，因为这种情况下可以将所有的信息存放在 table 内，所以迭代函数通常不需要第二个参数。</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">array = &#123;<span class="string">&quot;Google&quot;</span>, <span class="string">&quot;Runoob&quot;</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">elementIterator</span> <span class="params">(collection)</span></span></span><br><span class="line">   <span class="keyword">local</span> index = <span class="number">0</span></span><br><span class="line">   <span class="keyword">local</span> count = #collection</span><br><span class="line">   <span class="comment">-- 闭包函数</span></span><br><span class="line">   <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> <span class="params">()</span></span></span><br><span class="line">      index = index + <span class="number">1</span></span><br><span class="line">      <span class="keyword">if</span> index &lt;= count</span><br><span class="line">      <span class="keyword">then</span></span><br><span class="line">         <span class="comment">--  返回迭代器的当前元素</span></span><br><span class="line">         <span class="keyword">return</span> collection[index]</span><br><span class="line">      <span class="keyword">end</span></span><br><span class="line">   <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> element <span class="keyword">in</span> elementIterator(array)</span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">   <span class="built_in">print</span>(element)</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="comment">--输出</span></span><br><span class="line">Google</span><br><span class="line">Runoob</span><br></pre></td></tr></table></figure><h1 id="垃圾回收"><a href="#垃圾回收" class="headerlink" title="垃圾回收"></a>垃圾回收</h1><p>Lua 采用了自动内存管理。 这意味着你不用操心新创建的对象需要的内存如何分配出来， 也不用考虑在对象不再被使用后怎样释放它们所占用的内存。</p><p>Lua 运行了一个<strong>垃圾收集器</strong>来收集所有<strong>死对象</strong> （即在 Lua 中不可能再访问到的对象）来完成自动内存管理的工作。 Lua 中所有用到的内存，都服从自动管理。</p><h2 id="工作原理"><a href="#工作原理" class="headerlink" title="工作原理"></a>工作原理</h2><p>Lua 实现了一个增量标记-扫描收集器。 它使用这两个数字来控制垃圾收集循环： <strong>垃圾收集器间歇率和垃圾收集器步进倍率</strong>。 这两个数字都使用百分数为单位 （例如：值 100 在内部表示 1 ）。</p><ul><li>垃圾收集器间歇率控制着收集器需要在开启新的循环前要等待多久。 增大这个值会减少收集器的积极性。 当这个值比 100 小的时候，收集器在开启新的循环前不会有等待。 设置这个值为 200 就会让收集器等到总内存使用量达到 之前的两倍时才开始新的循环。</li><li>垃圾收集器步进倍率控制着收集器运作速度相对于内存分配速度的倍率。 增大这个值不仅会让收集器更加积极，还会增加每个增量步骤的长度。 不要把这个值设得小于 100 ， 那样的话收集器就工作的太慢了以至于永远都干不完一个循环。 默认值是 200 ，这表示收集器以内存分配的”两倍”速工作。</li></ul><h2 id="相关函数"><a href="#相关函数" class="headerlink" title="相关函数"></a>相关函数</h2><p>**collectgarbage ([opt [, arg]])**用来控制自动内存管理</p><ul><li><p><strong>collectgarbage(“collect”):</strong> 做一次完整的垃圾收集循环。通过参数 opt 它提供了一组不同的功能：</p></li><li><p><strong>collectgarbage(“count”):</strong> 以 K 字节数为单位返回 Lua 使用的总内存数。 这个值有小数部分，所以只需要乘上 1024 就能得到 Lua 使用的准确字节数（除非溢出）</p></li><li><p><strong>collectgarbage(“setpause”):</strong> 将 arg 设为收集器的 间歇率。 返回 间歇率 的前一个值。</p></li><li><p><strong>collectgarbage(“setstepmul”):</strong> 返回 步进倍率 的前一个值。</p></li></ul><blockquote><p><strong>collectgarbage(“setpause”, 200)</strong> ： 内存增大 2 倍（200&#x2F;100）时自动释放一次内存 （200 是默认值）。</p><p><strong>collectgarbage(“setstepmul”, 200)</strong> ：收集器单步收集的速度相对于内存分配速度的倍率，设置 200 的倍率等于 2 倍（200&#x2F;100）。（200 是默认值）</p></blockquote>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;数据类型&quot;&gt;&lt;a href=&quot;#数据类型&quot; class=&quot;headerlink&quot; title=&quot;数据类型&quot;&gt;&lt;/a&gt;数据类型&lt;/h1&gt;&lt;p&gt;lua是动态语言类型，变量不需要类型定义，只需要为变量赋值&lt;/p&gt;
&lt;p&gt;lua有8个基本类型：&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th align=&quot;left&quot;&gt;数据类型&lt;/th&gt;
&lt;th align=&quot;left&quot;&gt;描述&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;&lt;tr&gt;
&lt;td align=&quot;left&quot;&gt;nil&lt;/td&gt;
&lt;td align=&quot;left&quot;&gt;这个最简单，只有值nil属于该类，表示一个无效值（在条件表达式中相当于false）。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&quot;left&quot;&gt;boolean&lt;/td&gt;
&lt;td align=&quot;left&quot;&gt;包含两个值：false和true。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&quot;left&quot;&gt;number&lt;/td&gt;
&lt;td align=&quot;left&quot;&gt;表示双精度类型的实浮点数&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&quot;left&quot;&gt;string&lt;/td&gt;
&lt;td align=&quot;left&quot;&gt;字符串由一对双引号或单引号来表示&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&quot;left&quot;&gt;function&lt;/td&gt;
&lt;td align=&quot;left&quot;&gt;由 C 或 Lua 编写的函数&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&quot;left&quot;&gt;userdata&lt;/td&gt;
&lt;td align=&quot;left&quot;&gt;表示任意存储在变量中的C数据结构&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&quot;left&quot;&gt;thread&lt;/td&gt;
&lt;td align=&quot;left&quot;&gt;表示执行的独立线路，用于执行协同程序&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&quot;left&quot;&gt;table&lt;/td&gt;
&lt;td align=&quot;left&quot;&gt;Lua 中的表（table）其实是一个”关联数组”（associative arrays），数组的索引可以是数字、字符串或表类型。在 Lua 里，table 的创建是通过”构造表达式”来完成，最简单构造表达式是{}，用来创建一个空表。&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;&lt;/table&gt;</summary>
    
    
    
    
    <category term="lua" scheme="https://ycy666666.github.io/tags/lua/"/>
    
  </entry>
  
  <entry>
    <title>Unity + Mirror实现局域网联机自制卡牌游戏</title>
    <link href="https://ycy666666.github.io/2022/12/05/Unity-Mirror%E5%AE%9E%E7%8E%B0%E5%B1%80%E5%9F%9F%E7%BD%91%E8%81%94%E6%9C%BA%E8%87%AA%E5%88%B6%E5%8D%A1%E7%89%8C%E6%B8%B8%E6%88%8F/"/>
    <id>https://ycy666666.github.io/2022/12/05/Unity-Mirror%E5%AE%9E%E7%8E%B0%E5%B1%80%E5%9F%9F%E7%BD%91%E8%81%94%E6%9C%BA%E8%87%AA%E5%88%B6%E5%8D%A1%E7%89%8C%E6%B8%B8%E6%88%8F/</id>
    <published>2022-12-05T09:30:49.000Z</published>
    <updated>2022-12-09T10:58:22.435Z</updated>
    
    <content type="html"><![CDATA[<h1 id="资源下载地址"><a href="#资源下载地址" class="headerlink" title="资源下载地址"></a>资源下载地址</h1><p>局域网联机插件 Mirror：<a href="https://assetstore.unity.com/packages/tools/network/mirror-129321">Mirror | 网络 | Unity Asset Store</a></p><p>本地客户端测试多人游戏（不用打包）插件 ： <a href="https://github.com/VeriorPies/ParrelSync">ParrelSync</a></p><p>Mirror官方文档：<a href="https://mirror-networking.gitbook.io/docs/general">General - Mirror (gitbook.io)</a></p><h1 id="Mirror使用"><a href="#Mirror使用" class="headerlink" title="Mirror使用"></a>Mirror使用</h1><h2 id="前置准备"><a href="#前置准备" class="headerlink" title="前置准备"></a>前置准备</h2><ol><li>导入Mirror Package</li><li>创建空物体，添加 <code>Network Manager</code>， <code>Network Manager HUD</code>以及 <code>KCP Transport</code>（也可以选择其他网络连接方式）</li><li>导入<code>ParrelSync</code>， 并为其clone当前项目，在此之后clone后的项目能同步你在本项目的所有修改</li></ol><span id="more"></span><h3 id="演示场景"><a href="#演示场景" class="headerlink" title="演示场景"></a>演示场景</h3><p>点击开始之后会看到如下界面，需要其中一台电脑作为Host，其他玩家点击Client就可以直接连接</p><p><img src="/2022/12/05/Unity-Mirror%E5%AE%9E%E7%8E%B0%E5%B1%80%E5%9F%9F%E7%BD%91%E8%81%94%E6%9C%BA%E8%87%AA%E5%88%B6%E5%8D%A1%E7%89%8C%E6%B8%B8%E6%88%8F/image-20221128153741347.png" alt="image-20221128153741347"></p><p>Mirror演示场景连接成功效果：</p><p><img src="/2022/12/05/Unity-Mirror%E5%AE%9E%E7%8E%B0%E5%B1%80%E5%9F%9F%E7%BD%91%E8%81%94%E6%9C%BA%E8%87%AA%E5%88%B6%E5%8D%A1%E7%89%8C%E6%B8%B8%E6%88%8F/image-20221128154024366.png" alt="image-20221128154024366"></p><h3 id="同步"><a href="#同步" class="headerlink" title="同步"></a>同步</h3><p>首先需要注意的事情：</p><ul><li>在你需要用到联网功能的脚本中都要添加 <code>use Mirror</code>来使用相应Api，并且继承自 <code>NetWorkBehavior</code>而不是 <code>MonoBehavior</code></li><li>在涉及到玩家输入时，首先先要进行 <code>isLocalPlayer</code>的判断</li><li>如果游戏玩家有 <code>Prefab</code>，需要在<code>prefab</code>添加 <code>NetworkIdentity</code>组件并将其拖入到 <code>NetworkManager</code>组件的 <code>PlayerPrefab</code>中</li></ul><h2 id="服务端与客户端通信"><a href="#服务端与客户端通信" class="headerlink" title="服务端与客户端通信"></a>服务端与客户端通信</h2><h3 id="概念含义"><a href="#概念含义" class="headerlink" title="概念含义"></a>概念含义</h3><h4 id="Network-Identity"><a href="#Network-Identity" class="headerlink" title="Network Identity"></a>Network Identity</h4><p>该组件控制着游戏物体在网络中的独特ID，他的 <code>Server Only</code>选项表示是否确保物体只生成在服务端。</p><blockquote><p><strong>注意：Mirror不支持嵌套的 <code>Network Identity</code>，确保父物体是唯一一个具有该组件的物体，子物体通过 <code>GetComponentInParent</code>去查找</strong></p></blockquote><p>在每一个运行过程中生成的预制体都需要添加该组件。</p><h4 id="Network-Authority"><a href="#Network-Authority" class="headerlink" title="Network Authority"></a>Network Authority</h4><p>Authority（权限）决定着谁拥有并控制着这个物体，默认情况下服务器拥有所有物体的权限</p><p>但有时候我们需要客户端拥有权限，比如玩家输入，我们有以下方法将权限给到客户端：</p><ul><li><p>**<code>NetworkServer.Spawn</code>**： 在创建物体时给出权限</p></li><li><p>**<code>NetworkServer.AddPlayerForConnection</code>**，生成玩家物体时自动添加权限</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">GameObject go = Instantiate(prefab);</span><br><span class="line">NetworkServer.Spawn(go, connectionToClient);</span><br></pre></td></tr></table></figure></li><li><p>**<code>AssignClientAuthority</code>**： 在任何时候添加权限</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">identity.AssignClientAuthority(conn);</span><br></pre></td></tr></table></figure></li></ul><p>给物体赋予权限后，我们就能在ClientRpc中根据<code>IsOwn</code>来根据是否是自己的物体来执行不同函数，比如本游戏中，将卡牌放置在不同区域</p><h3 id="回调函数"><a href="#回调函数" class="headerlink" title="回调函数"></a>回调函数</h3><p>在需要使用服务端、客户端开始结束时回调的脚本中继承自NetworkBehavior，本例子继承自Network Manager是为了方便不再添加一个Network Manager组件</p><h4 id="仅在server上执行"><a href="#仅在server上执行" class="headerlink" title="仅在server上执行"></a>仅在server上执行</h4><p>Server Only ——</p><ul><li>OnStartServer:在服务端上生成时调用</li><li>OnStopServer:在服务器上销毁或者取消生成时调用</li><li>OnSerialize:在他在发送到客户端序列化之前调用， 同时确保调用 <code>base.OnSerialize</code></li></ul><h4 id="仅在Client-上执行"><a href="#仅在Client-上执行" class="headerlink" title="仅在Client 上执行"></a>仅在Client 上执行</h4><p>Client Only ——</p><ul><li>OnStartClient: 在客户端上生成时调用</li><li>OnStartLocalPlayer: 仅在client执行,当脚本所在物体为玩家角色时调用，用来设置跟踪相机等</li><li>OnStopClient: 当对象在客户端上被<code>ObjectDestroyMessage</code>或<code>ObjectHideMessage</code>消息销毁时调用</li><li>OnstartAuthority() 仅在client执行，当物体生产时，同时在该客户端有权限时执行</li><li>OnStopAuthority()仅在client执行，当客户端失去该物体权限时调用</li></ul><p>Awake() 最先无论client还是server。<br>Start() 顺序不定，通常在最后但不保证每次都是，所以不建议将网络数据放这里处理。</p><p><img src="/2022/12/05/Unity-Mirror%E5%AE%9E%E7%8E%B0%E5%B1%80%E5%9F%9F%E7%BD%91%E8%81%94%E6%9C%BA%E8%87%AA%E5%88%B6%E5%8D%A1%E7%89%8C%E6%B8%B8%E6%88%8F/image-20221129181141214.png" alt="image-20221129181141214"></p><h3 id="能够传输的数据类型"><a href="#能够传输的数据类型" class="headerlink" title="能够传输的数据类型"></a>能够传输的数据类型</h3><ul><li>C#基本类型——int, char, float 等</li><li>Untiy 数学类型——Vector3, Rect等</li><li>NetworlIdentity ——这就是为什么要给预制体添加这个组件</li><li>只包含上述类型的class、ScriptableObject（这两个会在接收端重新实例化从而产生垃圾）以及数组</li></ul><h3 id="特性"><a href="#特性" class="headerlink" title="特性"></a>特性</h3><p>知道何时以及如何使用以下特性，首先要明确你要同步什么变量，应该服务端执行还是客户端执行，以及传递的参数（尤其是涉及到GameObject的isOwned）在不同客户端下的不同执行情况</p><h4 id="Command"><a href="#Command" class="headerlink" title="[Command]"></a>[Command]</h4><p>拥有这个特性下的函数从客户端发送，由服务端执行。函数开头需要加上 <code>Cmd</code>前缀</p><p>避免每一帧都调用Cmd方法，这会产生巨大的流量</p><h4 id="ClientRpc"><a href="#ClientRpc" class="headerlink" title="[ClientRpc]"></a>[ClientRpc]</h4><p>服务端发送该函数，到客户端执行函数。开头需要加上 <code>Rpc</code>前缀</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Player</span> : <span class="title">NetworkBehaviour</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">int</span> health;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">TakeDamage</span>(<span class="params"><span class="built_in">int</span> amount</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (!isServer) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">        health -= amount;</span><br><span class="line">        RpcDamage(amount);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    [<span class="meta">ClientRpc</span>]</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">RpcDamage</span>(<span class="params"><span class="built_in">int</span> amount</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        Debug.Log(<span class="string">&quot;Took damage:&quot;</span> + amount);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用本地客户端作为主机运行游戏时，将在本地客户端上调用 ClientRpc 调用，即使它与服务器处于同一进程中</p><h4 id="TargetRpc"><a href="#TargetRpc" class="headerlink" title="[TargetRpc]"></a>[TargetRpc]</h4><p>clientRpc是会向所有client回调这个方法，有时候我们想让特定的client接受特定的回调，于是就有了回调特定client的方法</p><p>TargetRpc 函数由服务器上的用户代码调用，然后在指定网络连接的客户端上的相应客户端对象上调用。函数开头需要加上 <code>Target</code>前缀</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">public <span class="class"><span class="keyword">class</span> <span class="title">Player</span> :</span> NetworkBehaviour</span><br><span class="line">&#123;</span><br><span class="line">    public <span class="type">int</span> health;</span><br><span class="line"></span><br><span class="line">    [Command]</span><br><span class="line">    <span class="type">void</span> <span class="title function_">CmdMagic</span><span class="params">(GameObject target, <span class="type">int</span> damage)</span></span><br><span class="line">    &#123;</span><br><span class="line">        target.GetComponent&lt;Player&gt;().health -= damage;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 重点，尽管target没有在TargetDoMagic中使用，但必须传入</span></span><br><span class="line">        NetworkIdentity opponentIdentity = target.GetComponent&lt;NetworkIdentity&gt;();</span><br><span class="line">        TargetDoMagic(opponentIdentity.connectionToClient, damage);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    [TargetRpc]</span><br><span class="line">    public <span class="type">void</span> <span class="title function_">TargetDoMagic</span><span class="params">(NetworkConnection target, <span class="type">int</span> damage)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 这会出现在对手的客户端中，而不是攻击者的</span></span><br><span class="line">        Debug.Log($<span class="string">&quot;Magic Damage = &#123;damage&#125;&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 治疗自己</span></span><br><span class="line">    [Command]</span><br><span class="line">    public <span class="type">void</span> <span class="title function_">CmdHealMe</span><span class="params">()</span></span><br><span class="line">    &#123;</span><br><span class="line">        health += <span class="number">10</span>;</span><br><span class="line">        TargetHealed(<span class="number">10</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    [TargetRpc]</span><br><span class="line">    public <span class="type">void</span> <span class="title function_">TargetHealed</span><span class="params">(<span class="type">int</span> amount)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 没有指定NetworkConnection变量，因此出现在物体拥有者中</span></span><br><span class="line">        Debug.Log($<span class="string">&quot;Health increased by &#123;amount&#125;&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="SyncVar"><a href="#SyncVar" class="headerlink" title="[SyncVar]"></a>[SyncVar]</h4><p>SyncVar 是从 NetworkBehavior 继承的类的属性，这些类从服务器同步到客户端。当生成游戏对象或新玩家加入正在进行的游戏时，将向他们发送对他们可见的网络对象上所有 SyncVar 的最新状态。使用[SyncVar]指定脚本中要同步的变量。</p><p>能用Hook指定变量发生变量时将要调用的函数</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[<span class="meta">SyncVar(hook = nameof(OnHolaCountChanged))</span>]</span><br><span class="line"><span class="built_in">int</span> holaCount = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">OnHolaCountChanged</span>(<span class="params"><span class="built_in">int</span> oldCount, <span class="built_in">int</span> newCount</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    Debug.Log(<span class="string">$&quot;We had <span class="subst">&#123;oldCount&#125;</span> holas, but now we have <span class="subst">&#123;newCount&#125;</span> holas!&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>假设您正在制作一个库存系统。假设玩家 A、B 和 C 位于同一区域。整个网络中总共有 12 个对象：</p><ul><li>客户端 A 有玩家 A（他自己）、玩家 B 和玩家 C</li><li>客户端 B 有玩家 A、玩家 B（他自己）和玩家 C</li><li>客户端 C 有玩家 A、玩家 B 和玩家 C（他自己）</li><li>服务器有玩家 A、玩家 B、玩家 C</li></ul><p>除了服务器和客户端A之外，其他人没必要也不应该知道A的库存，典型用例包括任务、玩家在纸牌游戏中的手牌、技能、经验或您不需要与其他玩家共享的任何其他数据。</p><h3 id="演示"><a href="#演示" class="headerlink" title="演示"></a>演示</h3><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Update</span>()</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (!isLocalPlayer) <span class="keyword">return</span>;</span><br><span class="line">    HandleMovement();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (Input.GetKeyDown(KeyCode.X))</span><br><span class="line">    &#123;</span><br><span class="line">        Debug.Log(<span class="string">&quot;Sending Hola to Server!&quot;</span>);</span><br><span class="line">        CmdHola();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">[<span class="meta">Command</span>]</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">CmdHola</span>()</span></span><br><span class="line">&#123;</span><br><span class="line">    Debug.Log(<span class="string">&quot;Received Hola from Client!&quot;</span>);</span><br><span class="line">    TargetReplyHola();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">[<span class="meta">TargetRpc</span>]</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">TargetReplyHola</span>()</span></span><br><span class="line">&#123;</span><br><span class="line">    Debug.Log(<span class="string">&quot;Received Hola from Server!&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>客户端点击X：</p><p><img src="/2022/12/05/Unity-Mirror%E5%AE%9E%E7%8E%B0%E5%B1%80%E5%9F%9F%E7%BD%91%E8%81%94%E6%9C%BA%E8%87%AA%E5%88%B6%E5%8D%A1%E7%89%8C%E6%B8%B8%E6%88%8F/image-20221129145336669.png" alt="image-20221129145336669"></p><p>Host端点击X</p><p><img src="/2022/12/05/Unity-Mirror%E5%AE%9E%E7%8E%B0%E5%B1%80%E5%9F%9F%E7%BD%91%E8%81%94%E6%9C%BA%E8%87%AA%E5%88%B6%E5%8D%A1%E7%89%8C%E6%B8%B8%E6%88%8F/image-20221129145422279.png" alt="image-20221129145422279"></p><h1 id="游戏编写"><a href="#游戏编写" class="headerlink" title="游戏编写"></a>游戏编写</h1><h2 id="PlayPrefab"><a href="#PlayPrefab" class="headerlink" title="PlayPrefab"></a>PlayPrefab</h2><p>我们如果想要获取当前玩家的一些参数，需要按照以下代码获取——PlayerManger挂载在playerPrefab上</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 获取玩家预制体的NetworkIdentity</span></span><br><span class="line">NetworkIdentity networkIdentity = NetworkClient.connection.identity;</span><br><span class="line">playerManager = networkIdentity.GetComponent&lt;PlayerManager&gt;();</span><br></pre></td></tr></table></figure><p>这样我们调用 <code>PlayerManager.Function</code>时就是调用当前玩家的方法，记住这个方法在 <code>ClientRpc</code>中会很有用，比如给特定ID的玩家设定称号，就需要获取当前ID是否与特定ID相等</p><p>因为你必须确定是当前玩家的PlayerManager触发的函数，所以Cmd方法最好写在PlayerManager中，这个肯定会涉及到耦合。如果不想这样，可以自己新建一个类，但必须确认你调用的时候是当前玩家控制下的对应实例</p><h2 id="是否添加NetworkBehavior"><a href="#是否添加NetworkBehavior" class="headerlink" title="是否添加NetworkBehavior"></a>是否添加NetworkBehavior</h2><p>不是所有的物体都添加该组件，本游戏中比如玩家手牌，以及一些Manger管理器都是不用通信交互的，因为他们没必要让其他玩家知道。</p><p>但是呢，我们可以通过网络通信方法，TargetRpc、ClientRpc来改变这些没有networkBehavior的实例。</p><p>需要添加的一般有其中一个特征：</p><ul><li>连接之后创建的物体</li><li>需要进行同步的物体，比如玩家本身或者跟随其的宠物</li></ul><p>如果添加了这个组件都要拖拽到NetworkManager组件中的 <code>Registered Spawnable Prefab</code>中，这代表NetworkManager会同步这个物体的状态</p><h2 id="创建物体"><a href="#创建物体" class="headerlink" title="创建物体"></a>创建物体</h2><p>在服务器上“生成”游戏对象意味着在连接到服务器的客户端上创建游戏对象，并由生成系统管理。</p><p>使用此系统生成游戏对象后，只要服务器上的游戏对象发生更改，状态更新就会发送到客户端。当 Mirror 销毁服务器上的游戏对象时，也会销毁客户端上的游戏对象。服务器将生成的游戏对象与所有其他联网游戏对象一起管理，以便在其他客户端稍后加入游戏时，服务器可以在该客户端上生成游戏对象。这些生成的游戏对象具有称为“netId”的唯一网络实例 ID，该 ID 在每个游戏对象的服务器和客户端上都是相同的。</p><h2 id="游戏演示视频"><a href="#游戏演示视频" class="headerlink" title="游戏演示视频"></a>游戏演示视频</h2><p><a href="https://www.bilibili.com/video/BV1s44y1Q7VT/?vd_source=19c97c7473d6fc1c378d64079dda7638">Good Lock 演示视频_哔哩哔哩_bilibili</a></p><h2 id="模型锚点"><a href="#模型锚点" class="headerlink" title="模型锚点"></a>模型锚点</h2><p>网上找到的.fbx模型，一般里面的模型中心不在锚点上，这种一般的处理方法就是创建一个空的父物体，父物体的锚点控制在模型中心，但这样一个个改太慢了</p><p>写了一个脚本自动化改，放在Assets\Editor文件夹下</p><details>       <summary>具体代码：点击查看详细内容</summary>       <pre><code>using UnityEngine;using System.Collections;using System.Collections.Generic;using UnityEditor;public static class PivotEazier&#123;    [MenuItem("GameObject/Pivot/Create Pivot", false, 0)]    static void CreatePivotObject()    &#123;        if (Selection.activeGameObject != null)        &#123;            var pivot = CreatePivotObject(Selection.activeGameObject);            Selection.activeGameObject = pivot;        &#125;    &#125;    [MenuItem("GameObject/Pivot/Create Pivot (Local Zero)", false, 0)]    static void CreatePivotObjectAtParentPos()    &#123;        if (Selection.activeGameObject != null)        &#123;            var pivot = CreatePivotObjectAtParentPos(Selection.activeGameObject);            Selection.activeGameObject = pivot;        &#125;    &#125;    [MenuItem("GameObject/Pivot/Delete Pivot", false, 0)]    static void DeletePivotObject()    &#123;        GameObject objSelectionAfter = null;<pre><code>    if (Selection.activeGameObject != null)    &#123;        if (Selection.activeGameObject.transform.childCount &gt; 0)        &#123;            objSelectionAfter = Selection.activeGameObject.transform.GetChild(0).gameObject;        &#125;        else if (Selection.activeGameObject.transform.parent != null)        &#123;            objSelectionAfter = Selection.activeGameObject.transform.parent.gameObject;        &#125;        DeletePivotObject(Selection.activeGameObject);        Selection.activeGameObject = objSelectionAfter;    &#125;&#125;private static GameObject CreatePivotObjectAtParentPos(GameObject current)&#123;    if (current == null)    &#123;        return null;    &#125;    int siblingIndex = current.transform.GetSiblingIndex();    GameObject newObject = new GameObject(current.name);    newObject.transform.SetParent(current.transform.parent);    newObject.transform.localPosition = Vector3.zero;    newObject.transform.localScale = Vector3.one;    newObject.transform.localRotation = Quaternion.identity;    newObject.transform.SetSiblingIndex(siblingIndex);    current.transform.SetParent(newObject.transform);    return newObject;&#125;private static GameObject CreatePivotObject(GameObject current)&#123;    if (current == null)    &#123;        return null;    &#125;    int siblingIndex = current.transform.GetSiblingIndex();    GameObject newObject = new GameObject(&quot;Pivot&quot;);    newObject.transform.SetParent(current.transform.parent);    newObject.transform.position = current.transform.position;    newObject.transform.localScale = current.transform.localScale;    newObject.transform.rotation = current.transform.rotation;    newObject.transform.SetSiblingIndex(siblingIndex);    current.transform.SetParent(newObject.transform);    return newObject;&#125;private static GameObject DeletePivotObject(GameObject current)&#123;    Transform parent = current.transform.parent;    int childrenCount = current.transform.childCount;    int siblingIndex = current.transform.GetSiblingIndex();    Transform[] children = new Transform[childrenCount];    for (int i = 0; i &lt; childrenCount; i++)    &#123;        children[i] = current.transform.GetChild(i);    &#125;    for (int i = 0; i &lt; childrenCount; i++)    &#123;        children[i].SetParent(parent);        children[i].SetSiblingIndex(siblingIndex + i);    &#125;    if (Application.isPlaying)    &#123;        GameObject.Destroy(current);    &#125;    else    &#123;        GameObject.DestroyImmediate(current);    &#125;    if (children.Length &gt; 0)    &#123;        return children[0].gameObject;    &#125;    else    &#123;        return null;    &#125;&#125;</code></pre><p>}</p></code></pre> <p></p></details><p>使用方法是将模式中心对齐其父物体中心，在Hierarchy窗口中右键<code>Create Pivot (Local Zero)</code>就可以</p>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;资源下载地址&quot;&gt;&lt;a href=&quot;#资源下载地址&quot; class=&quot;headerlink&quot; title=&quot;资源下载地址&quot;&gt;&lt;/a&gt;资源下载地址&lt;/h1&gt;&lt;p&gt;局域网联机插件 Mirror：&lt;a href=&quot;https://assetstore.unity.com/packages/tools/network/mirror-129321&quot;&gt;Mirror | 网络 | Unity Asset Store&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;本地客户端测试多人游戏（不用打包）插件 ： &lt;a href=&quot;https://github.com/VeriorPies/ParrelSync&quot;&gt;ParrelSync&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Mirror官方文档：&lt;a href=&quot;https://mirror-networking.gitbook.io/docs/general&quot;&gt;General - Mirror (gitbook.io)&lt;/a&gt;&lt;/p&gt;
&lt;h1 id=&quot;Mirror使用&quot;&gt;&lt;a href=&quot;#Mirror使用&quot; class=&quot;headerlink&quot; title=&quot;Mirror使用&quot;&gt;&lt;/a&gt;Mirror使用&lt;/h1&gt;&lt;h2 id=&quot;前置准备&quot;&gt;&lt;a href=&quot;#前置准备&quot; class=&quot;headerlink&quot; title=&quot;前置准备&quot;&gt;&lt;/a&gt;前置准备&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;导入Mirror Package&lt;/li&gt;
&lt;li&gt;创建空物体，添加 &lt;code&gt;Network Manager&lt;/code&gt;， &lt;code&gt;Network Manager HUD&lt;/code&gt;以及 &lt;code&gt;KCP Transport&lt;/code&gt;（也可以选择其他网络连接方式）&lt;/li&gt;
&lt;li&gt;导入&lt;code&gt;ParrelSync&lt;/code&gt;， 并为其clone当前项目，在此之后clone后的项目能同步你在本项目的所有修改&lt;/li&gt;
&lt;/ol&gt;</summary>
    
    
    
    
    <category term="Unity" scheme="https://ycy666666.github.io/tags/Unity/"/>
    
  </entry>
  
  <entry>
    <title>游戏优化之空间划分</title>
    <link href="https://ycy666666.github.io/2022/11/20/%E6%B8%B8%E6%88%8F%E4%BC%98%E5%8C%96%E4%B9%8B%E7%A9%BA%E9%97%B4%E5%88%92%E5%88%86/"/>
    <id>https://ycy666666.github.io/2022/11/20/%E6%B8%B8%E6%88%8F%E4%BC%98%E5%8C%96%E4%B9%8B%E7%A9%BA%E9%97%B4%E5%88%92%E5%88%86/</id>
    <published>2022-11-20T13:19:24.000Z</published>
    <updated>2022-11-21T04:10:12.724Z</updated>
    
    <content type="html"><![CDATA[<h1 id="使用的动机"><a href="#使用的动机" class="headerlink" title="使用的动机"></a>使用的动机</h1><p><strong>定义：将对象根据它们的位置存储在数据结构中，来高效地定位对象。</strong></p><p>在游戏中，AI向最近的敌人攻击是很常见的，但如果有很多单位的话，他们AI需要频繁的查找单位，然后在检测是不是距离最近的单位，时间复杂度是o(n ^ 2)</p><p>之所以会出现这个问题，是因为我们没有指明潜在的对象顺序。假如我们游戏的所有单位都只在一条直线上，我们只需要二分查找就可以找到最近对象了。操作系统中，有着局部性原理，我们也可以根据游戏物体的位置来存储对象，这样就能更快的找到他们</p><p><strong>注意事项：</strong></p><p>空间分区的存在是为了将<em>O(n)<em>或者</em>O(n²)</em> 的操作降到更加可控的数量级。 你拥有的对象<em>越多</em>，这就越重要。相反的，如果<em>n</em>足够小，也许不需要担心这个</p><p>这不仅能够用于存储可移动的游戏对象，还可用于静态美术等场景资源。如果对象发生移动，我们需要在数据结构中重新追踪该对象，这也会增加CPU消耗。</p><span id="more"></span><h1 id="实现方法"><a href="#实现方法" class="headerlink" title="实现方法"></a>实现方法</h1><p>实现模式有很多种，都有各自的性能优势</p><h2 id="固定网格"><a href="#固定网格" class="headerlink" title="固定网格"></a>固定网格</h2><p>将整个游戏战场分割为固定大小的网格中，每个格子分别存储一组单位，对象在网格中的存储方式应该是双向链表，因为他增删结点比较迅速</p><p><img src="/2022/11/20/%E6%B8%B8%E6%88%8F%E4%BC%98%E5%8C%96%E4%B9%8B%E7%A9%BA%E9%97%B4%E5%88%92%E5%88%86/spatial-partition-grid.png" alt="spatial-partition-grid"></p><p>在单位移动需要改变位置时，我们需要先判断是否穿越了格子的边界，如果穿越，我们需要先移除再添加到网格中</p><p>对于近距离攻击来说，只运算网格中的单位相互攻击是没啥大问题的。但是对于其他的攻击方式形成了新的问题，比如有一个远距离攻击的法师单位或者是能够冲锋的骑兵单位，就不能只判断单一网格。</p><p><img src="/2022/11/20/%E6%B8%B8%E6%88%8F%E4%BC%98%E5%8C%96%E4%B9%8B%E7%A9%BA%E9%97%B4%E5%88%92%E5%88%86/spatial-partition-adjacent.png" alt="spatial-partition-adjacent"></p><p>这时候我们不仅需要比较同一网格，还需要比较邻近网格对象</p><h1 id="空间划分依据"><a href="#空间划分依据" class="headerlink" title="空间划分依据"></a>空间划分依据</h1><h2 id="层次和平面划分"><a href="#层次和平面划分" class="headerlink" title="层次和平面划分"></a>层次和平面划分</h2><p><strong>层次划分：</strong></p><p><img src="/2022/11/20/%E6%B8%B8%E6%88%8F%E4%BC%98%E5%8C%96%E4%B9%8B%E7%A9%BA%E9%97%B4%E5%88%92%E5%88%86/2020062721372651.png" alt="2020062721372651"></p><p>层次空间划分将空间分成几个区域。 然后，如果其中一个区域还包含多个对象，再划分它。 这个过程递归进行，直到每个区域都有少于最大数量的对象在其中。</p><ul><li>处理空区域时更有效率，大片的空区域在单个划分上，不需要遍历很多个空的小空间</li><li>处理密集空间时也更有效率，当对象都聚集在一起时，每个网格仍然只有少量单位。</li></ul><p><strong>平面划分：</strong></p><p>内存使用量确定，因为划分不会有增删，分区的内存使用量固定</p><p>在对象改变位置时更新得更快，层次更新则需要多层级调整，甚至改变层次划分</p><h2 id="是否与对象有关"><a href="#是否与对象有关" class="headerlink" title="是否与对象有关"></a>是否与对象有关</h2><p><strong>与对象有关：</strong></p><p>固定划分中，移动单位意味着只需要从网格中删除，在加入到另一个网格中就可以了，但不是固定划分的话就需要改变边界，<strong>对象可以增量添加</strong>。 添加对象意味着找到正确的划分然后放入，这点可以一次性完成，没有任何性能问题。</p><p><strong>与对象无关：</strong></p><p>在BSP和KD树中这样各地适应对象划分世界，可以让每个部分都包含接近数目的对象，划分边界时需要考虑每一边各有多少对象。</p><p><img src="/2022/11/20/%E6%B8%B8%E6%88%8F%E4%BC%98%E5%8C%96%E4%B9%8B%E7%A9%BA%E9%97%B4%E5%88%92%E5%88%86/image-20221120192931583.png" alt="image-20221120192931583"></p><p>Oct-Tree：八叉树，对于三维空间中的一个场景将其横竖切三刀，切成八块，在二维空间表现为四叉。。</p><p>KD-Tree：k-d树每次只会选取一个基轴方向进行分割，比如二维空间中先沿x方向分割，然后再沿y轴方向分割。</p><p>BSP-Tree：也是每次划分选择一个方向将空间分成两部分，与KD-Tree相比它不是横平竖直的划分，不好计算</p><p><strong>其中八叉树可以拥有两者的优点：对象能够批量增加马，移动对象很快，分区是平衡的</strong></p><h2 id="存储是否唯一"><a href="#存储是否唯一" class="headerlink" title="存储是否唯一"></a>存储是否唯一</h2><p>空间划分还有一个值得注意的问题，空间分区是否是游戏对象存储的唯一地方</p><p>**如果唯一:**这能够减少内存消耗</p><p><strong>如果不是：</strong>如果我们需要用除了位置关系外其他的方式来访问对象，比如特定种类的兵种，有了其他的数据保存结构我们能够更快的访问</p><h2 id="使用的数据结构"><a href="#使用的数据结构" class="headerlink" title="使用的数据结构"></a>使用的数据结构</h2><p>选择一套数据结构来存储网格及对象，这里要考虑静态场景和动态场景的区别</p><p><img src="/2022/11/20/%E6%B8%B8%E6%88%8F%E4%BC%98%E5%8C%96%E4%B9%8B%E7%A9%BA%E9%97%B4%E5%88%92%E5%88%86/image-20221121120551536.png" alt="image-20221121120551536"></p><p>方案a就是用的之前讲的双向链表，但其会造成内存浪费也会降低cpu cache命中</p><p>方案b用数组取代了链表来存储场景中的对象。<strong>数组是一块连续的内存地址，可以提高cpu cache的命中</strong>，而且相对于链表可以节省内存空间。每一个网格需要记录存储对象的其实位置，以及所属对象的个数。这需要遍历两次场景第一次确定每个网格的对象数量及对象的总数，第二次遍历分配场景对象。方案b适合静态场景，并且可以离线预处理</p><p>还有种方案是，如果场景很大但是游戏角色并不多，比如Apex等吃鸡游戏，那么就可以使用哈希表来存储，避免了大量检索空的网格</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>每种空间分区数据结构基本上都是将一维数据结构扩展成更高维度的数据结构。 </p><ul><li>网格是连续的桶排序</li><li>BSPs，k-d trees和包围盒是线性搜索树</li><li>四叉树和八叉树是多叉树</li></ul>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;使用的动机&quot;&gt;&lt;a href=&quot;#使用的动机&quot; class=&quot;headerlink&quot; title=&quot;使用的动机&quot;&gt;&lt;/a&gt;使用的动机&lt;/h1&gt;&lt;p&gt;&lt;strong&gt;定义：将对象根据它们的位置存储在数据结构中，来高效地定位对象。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;在游戏中，AI向最近的敌人攻击是很常见的，但如果有很多单位的话，他们AI需要频繁的查找单位，然后在检测是不是距离最近的单位，时间复杂度是o(n ^ 2)&lt;/p&gt;
&lt;p&gt;之所以会出现这个问题，是因为我们没有指明潜在的对象顺序。假如我们游戏的所有单位都只在一条直线上，我们只需要二分查找就可以找到最近对象了。操作系统中，有着局部性原理，我们也可以根据游戏物体的位置来存储对象，这样就能更快的找到他们&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;注意事项：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;空间分区的存在是为了将&lt;em&gt;O(n)&lt;em&gt;或者&lt;/em&gt;O(n²)&lt;/em&gt; 的操作降到更加可控的数量级。 你拥有的对象&lt;em&gt;越多&lt;/em&gt;，这就越重要。相反的，如果&lt;em&gt;n&lt;/em&gt;足够小，也许不需要担心这个&lt;/p&gt;
&lt;p&gt;这不仅能够用于存储可移动的游戏对象，还可用于静态美术等场景资源。如果对象发生移动，我们需要在数据结构中重新追踪该对象，这也会增加CPU消耗。&lt;/p&gt;</summary>
    
    
    
    
    <category term="Unity" scheme="https://ycy666666.github.io/tags/Unity/"/>
    
  </entry>
  
  <entry>
    <title>Unity 资源热更新</title>
    <link href="https://ycy666666.github.io/2022/11/17/Unity-%E8%B5%84%E6%BA%90%E7%83%AD%E6%9B%B4%E6%96%B0/"/>
    <id>https://ycy666666.github.io/2022/11/17/Unity-%E8%B5%84%E6%BA%90%E7%83%AD%E6%9B%B4%E6%96%B0/</id>
    <published>2022-11-17T12:25:44.000Z</published>
    <updated>2022-12-09T10:40:07.807Z</updated>
    
    <content type="html"><![CDATA[<h1 id="热更新流程"><a href="#热更新流程" class="headerlink" title="热更新流程"></a>热更新流程</h1><ol><li>启动游戏</li><li>根据当前版本号，和平台号去<strong>版本服务器</strong>上检查是否有热更</li><li>从<strong>热更服务器</strong>上下载md5文件，比对需要热更的具体文件列表</li><li>从<strong>热更服务器</strong>上下载需要热更的资源，解压到热更资源目录</li><li>游戏运行加载资源，优先到热更目录中加载，再到母包资源目录加载</li></ol><p>这些目录包含着不同版本的资源文件，以及用于版本控制的<code>Files.txt</code>，里面存放着资源文件的名称和md5码。</p><blockquote><p>客户端版本号我们是4位来标识，假设是X.Y.Z.W</p><p>X：【巨大版本号】这一位其实就是1，没事一般不会动他，除非有太巨大的变化，目前反正还是1；<br>Y：【整包更新版本号】：我们游戏一般一个月会有一个比较大的版本迭代，这种版本会走商店，每次提交Y值+1；<br>Z：【服务器协议版本号】，一个月度版本周期内，万一SDK有问题或者C#层有发现bug，需要更新商店，这一位会+1，这里单独留一个Z处理这种商店版本号，是因为不想影响Y值，而商店提交新包要求版本号必须有增加，buildNum也是商店要求必须要升的；<br>W：【编译版本号\热更版本号】，每次热更都+1 。<br>【第2位加1之后，3、4位全部清0】</p></blockquote><span id="more"></span><h2 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h2><p>相对于Resources下的资源，AB包可以更好地管理资源，更灵活方便，更易于做热更新相关工作</p><p><img src="/2022/11/17/Unity-%E8%B5%84%E6%BA%90%E7%83%AD%E6%9B%B4%E6%96%B0/image-20221117200824511.png" alt="image-20221117200824511"></p><h1 id="AssetBundle"><a href="#AssetBundle" class="headerlink" title="AssetBundle"></a>AssetBundle</h1><p><strong>AssetBundle</strong> 是一个存档文件，包含可在运行时由 Unity 加载的特定于平台的非代码资源（比如模型、纹理、预制件、音频剪辑甚至整个场景）。AssetBundle 可以表示彼此之间的依赖关系；例如，一个 AssetBundle 中的材质可以引用另一个 AssetBundle 中的纹理。</p><p><strong>AssetBundle对于可下载内容(DLC)、减少初始安装大小、加载针对最终用户平台优化的资产以及减少运行时内存压力都很有用</strong></p><p><strong>AssetBundle里面包含了什么？</strong></p><ul><li>首先是磁盘上的实际文件，这称为AssetBundle archive。AssetBundle archive是一个容器，就像一个文件夹一样，其中包含了额外的文件。这些额外的文件包括两类:<ul><li>序列化文件，其中包含分解为各个对象并写入此单个文件的资源。</li><li>资源文件，这是为某些资源（纹理和音频）单独存储的二进制数据块，允许 Unity 高效地在另一个线程上从磁盘加载它们。</li></ul></li><li>也可以指：通过代码进行交互以便从特定 AssetBundle 存档加载资源的实际 AssetBundle 对象。该对象包含添加到此存档文件的资源的所有文件路径的映射</li></ul><h1 id="游戏资源目录"><a href="#游戏资源目录" class="headerlink" title="游戏资源目录"></a>游戏资源目录</h1><ul><li><strong>Resources</strong>：全部资源都会被压缩，转化成二进制。打包后该路径不存在，不可写也不可读。只能使用<code>Resources.Load</code>加载资源。</li><li><strong>Streaming Assets</strong>：全部资源原封不动打包。<strong>在移动平台下，是只读的</strong>，不能写入数据，其他平台下可以使用<code>System.File</code>类进行读写。在任意平台都可以使用<code>AssetBundle.LoadFromFile</code>来从此文件夹读取加载ab包。</li></ul><h1 id="AssetBundle管理"><a href="#AssetBundle管理" class="headerlink" title="AssetBundle管理"></a>AssetBundle管理</h1><p><img src="/2022/11/17/Unity-%E8%B5%84%E6%BA%90%E7%83%AD%E6%9B%B4%E6%96%B0/v2-530769033485f56fde4dd46f8e5fc78d_720w.jpg" alt="v2-530769033485f56fde4dd46f8e5fc78d_720w"></p><h2 id="打包资源"><a href="#打包资源" class="headerlink" title="打包资源"></a>打包资源</h2><p>将需要同时加载的资源放在同一个包里，各个包之间会保存相互依赖的信息</p><p>分组依据：</p><ul><li>逻辑实体分组：是指根据资源所代表的项目功能部分将资源分配给 AssetBundle。这包括各种不同部分，比如一组角色的所有模型和动画、多个关卡之间共享的景物的纹理和模型</li><li>类型分组：要构建供多个平台使用的 AssetBundle，类型分组是最佳策略之一。如果音频压缩设置在 Windows 和 Mac 平台上完全相同，则可以将所有音频数据打包到 AssetBundle 并重复使用，而着色器往往使用更多特定于平台的选项进行编译</li><li>并发内容分组： 将需要同时加载和使用的资源捆绑在一起。可以将这些类型的捆绑包用于基于关卡的游戏（其中每个关卡包含完全独特的角色、纹理、音乐等）。</li></ul><h2 id="卸载资源"><a href="#卸载资源" class="headerlink" title="卸载资源"></a>卸载资源</h2><p>在管理Asset和AssetBundle时，最重要的一点是调用<code>AssetBundle.unload</code>时的方式，unload参数为true或false。</p><blockquote><p>此API将卸载正在调用的AssetBundle的包头信息。unload参数决定是否也卸载从此AssetBundle实例化的所有对象。如果设置为true，那么从AssetBundle创建的所有对象也将立即卸载，即使它们目前正在活动场景中被引用。</p></blockquote><p><img src="/2022/11/17/Unity-%E8%B5%84%E6%BA%90%E7%83%AD%E6%9B%B4%E6%96%B0/image-20221117193014125.png" alt="image-20221117193014125"></p><p>如果调用了<code>AssetBundle.Unload(True)</code>，则M将从场景中移除，销毁并卸载。但是，如果调用<code>AssetBundle.Unload(False)</code>，则AB的包头信息将被卸载，但M将保持在场景中，并且仍然是可用的。</p><p>调用<code>AssetBundle.Unload(False)</code>破坏了M和AB之间的链接。如果AB稍后再次加载，则AB中包含的对象的新副本将会被加载到内存中。此后如果再次加载AB，将再次加载这个包头信息的新副本，但是M和这个包并不会重新建立连接。如果此时调用<code>AssetBundle.LoadAsset()</code>来重新加载M，将会有两个相同的副本M在现场。</p><p><img src="/2022/11/17/Unity-%E8%B5%84%E6%BA%90%E7%83%AD%E6%9B%B4%E6%96%B0/image-20221117193416358.png" alt="image-20221117193416358"></p><p>为了避免这种情况，应该使用<code>AssetBundle.Unload(True)</code>，并来确保对象不被复制，具体做法是：</p><ol><li>在应用程序的生命周期内定义一个合适的节点，并在此期间卸载不需要的AssetBundle，例如<strong>在关卡切换或加载屏幕期间</strong>。这是最简单和最常见的选择。</li><li>维护单个对象的引用计数，并<strong>仅当所有组成对象都未使用时才卸载AssetBundle</strong>。这允许应用程序在不重复内存的情况下卸载和重新加载单个对象</li></ol><p>另一个问题是：如果AssetBundle卸载后重新加载一个对象，重新加载将失败，该对象将以（Missing）对象的形式出现在Unity编辑器的层次结构中，材质会呈现洋红色。主要会发生在Unity失去并试图恢复对其图形上下文的控制时，例如当移动应用程序被挂起或用户锁定他们的PC时</p><h2 id="加载AssetBundles"><a href="#加载AssetBundles" class="headerlink" title="加载AssetBundles"></a>加载AssetBundles</h2><p>AssetBundles可以通过四个不同的API进行加载。但受限于两个标准，这四个API的行为是不同的。两个标准如下：</p><ul><li>AssetBundles的压缩方式：LZMA、LZ4、还是未压缩的。</li><li>AssetBundles的加载平台。</li></ul><p>而四个API分别是：</p><ul><li><code>AssetBundle.LoadFromMemory(Async optional)</code>：<strong>不要使用这个API</strong>，因为他会冗余多次</li><li><code>AssetBundle.LoadFromFile(Async optional)</code>：用于从本地存储（如硬盘或SD卡）加载<strong>未压缩或LZ4压缩格式</strong>的AssetBundle。</li><li><code>UnityWebRequest&#39;s DownloadHandlerAssetBundle</code></li><li><code>WWW.LoadFromCacheOrDownload</code> (on Unity 5.6 or older)</li></ul><p>一般来说，只要有可能，就应该使用<code>AssetBundle.LoadFromFile</code>。这个API在速度、磁盘使用和运行时内存使用方面是最有效的。</p><h2 id="从AssetBundles中加载Assets"><a href="#从AssetBundles中加载Assets" class="headerlink" title="从AssetBundles中加载Assets"></a>从AssetBundles中加载Assets</h2><p>Unity提供了三个不同的API从AssetBundles加载<code>UnityEngine.Objects</code>，这些API都绑定到AssetBundle对象上，并且这些API具有同步和异步变体，这些API的<strong>同步版本总是比异步版本快至少一个帧</strong>（因为异步版本为了确保异步，都至少延迟了1帧）：</p><ul><li><code>LoadAsset (LoadAssetAsync)</code></li><li><code>LoadAllAssets (LoadAllAssetsAsync)</code></li><li><code>LoadAssetWithSubAssets (LoadAssetWithSubAssetsAsync)</code></li></ul><blockquote><p>加载多个独立的<code>UnityEngine.Objects</code>时应使用<code>LoadAllAsset</code>。并且只有在需要加载AssetBundle中的大多数或所有对象时，才应该使用它。<code>LoadAllAsset</code>比对<code>LoadAsset</code>的多个单独调用略快一些</p></blockquote><p><strong>Object加载是在主线程上执行，但数据从工作线程上的存储中读取</strong>。任何不触碰Unity系统中线程敏感部分（脚本、图形）的工作都将在工作线程上转换。例如，VBO将从网格创建，纹理将被解压等等。<strong>当一个Object完成加载时，它的Awake回调将被调用，该对象的其余部分将在下一个帧中对UnityEngine可用。</strong></p>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;热更新流程&quot;&gt;&lt;a href=&quot;#热更新流程&quot; class=&quot;headerlink&quot; title=&quot;热更新流程&quot;&gt;&lt;/a&gt;热更新流程&lt;/h1&gt;&lt;ol&gt;
&lt;li&gt;启动游戏&lt;/li&gt;
&lt;li&gt;根据当前版本号，和平台号去&lt;strong&gt;版本服务器&lt;/strong&gt;上检查是否有热更&lt;/li&gt;
&lt;li&gt;从&lt;strong&gt;热更服务器&lt;/strong&gt;上下载md5文件，比对需要热更的具体文件列表&lt;/li&gt;
&lt;li&gt;从&lt;strong&gt;热更服务器&lt;/strong&gt;上下载需要热更的资源，解压到热更资源目录&lt;/li&gt;
&lt;li&gt;游戏运行加载资源，优先到热更目录中加载，再到母包资源目录加载&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;这些目录包含着不同版本的资源文件，以及用于版本控制的&lt;code&gt;Files.txt&lt;/code&gt;，里面存放着资源文件的名称和md5码。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;客户端版本号我们是4位来标识，假设是X.Y.Z.W&lt;/p&gt;
&lt;p&gt;X：【巨大版本号】这一位其实就是1，没事一般不会动他，除非有太巨大的变化，目前反正还是1；&lt;br&gt;Y：【整包更新版本号】：我们游戏一般一个月会有一个比较大的版本迭代，这种版本会走商店，每次提交Y值+1；&lt;br&gt;Z：【服务器协议版本号】，一个月度版本周期内，万一SDK有问题或者C#层有发现bug，需要更新商店，这一位会+1，这里单独留一个Z处理这种商店版本号，是因为不想影响Y值，而商店提交新包要求版本号必须有增加，buildNum也是商店要求必须要升的；&lt;br&gt;W：【编译版本号\热更版本号】，每次热更都+1 。&lt;br&gt;【第2位加1之后，3、4位全部清0】&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    
    <category term="Unity" scheme="https://ycy666666.github.io/tags/Unity/"/>
    
  </entry>
  
  <entry>
    <title>浅析GC-垃圾回收</title>
    <link href="https://ycy666666.github.io/2022/11/14/%E6%B5%85%E6%9E%90GC-%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/"/>
    <id>https://ycy666666.github.io/2022/11/14/%E6%B5%85%E6%9E%90GC-%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/</id>
    <published>2022-11-14T14:05:51.000Z</published>
    <updated>2022-11-22T12:17:41.172Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前置知识"><a href="#前置知识" class="headerlink" title="前置知识"></a>前置知识</h1><h2 id="CLR：公共语言运行时"><a href="#CLR：公共语言运行时" class="headerlink" title="CLR：公共语言运行时"></a>CLR：公共语言运行时</h2><p>CLR（Common Language Runtime）：CLR的核心功能包括<strong>内存管理，程序集加载，类型安全，异常处理和线程同步</strong>，而且还负责对代码实施严格的类型安全检查，保证代码的准确性，这些功能都可以提供给面向CLR的所有语言</p><p>CLR并不关心是使用何种语言进行编程开发，只要编译器是面向CLR而进行编译的即可，这个中间的结果，就是IL(Intermediate Language), 最终面向CLR编译得到的结果是：IL语句以及托管数据(元数据)组成的托管模块</p><p><img src="/2022/11/14/%E6%B5%85%E6%9E%90GC-%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/image-20221114185011460.png" alt="image-20221114185011460"></p><span id="more"></span><h2 id="托管资源与非托管资源"><a href="#托管资源与非托管资源" class="headerlink" title="托管资源与非托管资源"></a>托管资源与非托管资源</h2><p>托管就是.net framework 负责帮你管理内存及资源释放，不需要自己控制。</p><p>对于引用类型，栈上保存着一个地址而已，当栈释放后， 即使对象已经没有用了，但<strong>堆上分配的内存还在</strong>，只能等<strong>GC收集时才能真正释放</strong>。但对于值类型，GC会<strong>自动释放</strong>他们占用的内存，不需要GC来<strong>回收释放</strong></p><ul><li>托管资源指的是.NET可以自动进行回收的资源，主要是指托管堆上分配的内存资源。托管资源的回收工作是不需要人工干预的，由.NET运行时在适当的时候调用垃圾回收器进行回收。例如程序中分配的对象,作用域内的变量等</li><li>非托管资源指的是.NET不知道如何回收的资源，最常见的一类非托管资源如文件、窗口、网络连接、数据库连接等。这类资源，垃圾回收器在清理的时候会调用<code>Object.Finalize()</code>方法。默认情况下，方法是空的，<strong>对于非托管对象，需要在此方法中编写回收非托管资源的代码</strong>，以便垃圾回收器正确回收资源</li></ul><blockquote><p>托管代码和非托管代码</p><p>托管代码：由公共语言运行库环境（而不是直接由操作系统）执行的代码。托管代码应用程序可以获得公共语言运行库服务，例如自动垃圾回收、运行库类型检查和安全支持等。</p><p>非托管代码：<strong>在公共语言运行库环境的外部，由操作系统直接执行的代码</strong>。非托管代码必须提供自己的垃圾回收、类型检查、安全支持等服务。</p></blockquote><h1 id="内存管理机制"><a href="#内存管理机制" class="headerlink" title="内存管理机制"></a>内存管理机制</h1><h2 id="值数据类型的内存管理"><a href="#值数据类型的内存管理" class="headerlink" title="值数据类型的内存管理"></a>值数据类型的内存管理</h2><p>在进程的虚拟内存中，有一个区域称为栈。C#的值类型数据、传递给方法的参数副本都存储在这个栈中。在栈中存储数据时，是从高内存地址向低内存地址填充的。操作系统维护一个变量，称为栈指针，栈指针总是会指向栈中下一个空闲存储单元的地址。</p><p>函数调用在执行时，首先要在栈中为形参和局部变量分配存储空间，然后还要将实参的值复制给形参，接下来还要将函数的返回地址（该地址指明了函数执行结束后，程序应该回到哪里继续执行）放入栈中，最后才跳转到函数内部执行。这个过程是要耗费时间的。<strong>C# 函数执行 return 语句返回时，需要从栈中回收形参和局部变量占用的存储空间，然后从栈中取出返回地址</strong>，再跳转到该地址继续执行，这个过程也要耗费时间。</p><h2 id="如何垃圾回收"><a href="#如何垃圾回收" class="headerlink" title="如何垃圾回收"></a>如何垃圾回收</h2><p><strong>当满足以下条件之一时CLR将发生垃圾回收：</strong></p><ol><li>系统具有低的物理内存。</li><li><strong>由托管堆上已分配的对象使用的内存超出了可接受的阈值（涉及到代的概念）</strong>。随着进程的运行，此阈值会不断地进行调整。</li><li>强制调用 <code>GC.Collect</code> 方法。</li><li>CLR正在卸载应用程序域（<code>AppDomain</code>）</li><li>CLR正在关闭。</li></ol><h3 id="具体流程："><a href="#具体流程：" class="headerlink" title="具体流程："></a>具体流程：</h3><p>GC是一种<strong>分代式垃圾回收器</strong>，使用引用计数算法，该算法只关心引用类型变量</p><blockquote><p>根对象：相当于是当前存活对象的合集，GC去搜索能被该集合直接或者是间接指向的对象</p></blockquote><ul><li>GC的准备阶段：<br>在这个阶段，CLR会暂停进程中的所有线程，这是为了防止线程在CLR检查根期间访问堆。</li><li>GC的标记阶段：<br>当GC开始运行时，它会假设托管堆上的所有对象都是垃圾。然后GC开始遍历根对象并让所有与之有引用关系的对象构成一个<strong>对象图</strong>，假如一个根对象指向null，GC会忽略这个根并继续检查下个根。</li></ul><p>下图是<strong>回收之前的托管堆模型</strong>，根直接引用了对象A，C，D，F。标记对象D时，垃圾回收器发现这个对象含有一个引用对象H的字段，所以H也会被标记，整个过程一直持续到所有根检查完毕。<code>NextObjPtr</code>对象始终保持指向最后一个对象放入托管堆的地址</p><p><strong>如果GC发现一个对象已经在图中就会换一个路径继续遍历。这样做有两个目的：一是提高性能，二是避免无限循环。</strong></p><p><img src="/2022/11/14/%E6%B5%85%E6%9E%90GC-%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/image-20221114193614095.png" alt="image-20221114193614095"></p><ul><li>GC的碎片整理阶段<br>托管堆上所有不在这个图上的对象就是要做回收的垃圾对象了。同时，CLR会使堆中非垃圾对象覆盖占用连续的内存空间（还伴随着对根返回新的内存地址的行为），这样一方面恢复了引用的“局部化”，也解决了本机堆的空间碎片化问题。</li></ul><p><img src="/2022/11/14/%E6%B5%85%E6%9E%90GC-%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/image-20221114195707900.png" alt="image-20221114195707900"></p><ul><li>GC恢复阶段<br>恢复暂停的所有线程，使这些线程可以继续访问对象。</li></ul><p>值得注意的是，将引用赋值为null并不意味着强制GC立即启动并把对象从堆上移除，唯一完成的事情是显式取消了引用和之前 引用所指向对象之间的连接</p><h2 id="代数概念（Generation）"><a href="#代数概念（Generation）" class="headerlink" title="代数概念（Generation）"></a>代数概念（Generation）</h2><p>代的分代式垃圾回收器，而代就是一种为了降低GC对性能影响的机制，垃圾回收有两个基本原理：</p><ol><li>对象越新，生命周期越短，反之也成立</li><li>回收托管堆的一部分，速度快于回收整个堆</li></ol><p>托管堆中的每个对象都可以被分为0、1、2三个代，表示他们经历了几次GC仍没有被回收</p><ul><li>低一代的GC触发，移动到高一代后，未必会触发高一代的GC，只有高一代的内存不足时才会触发高一代的GC</li><li>不同代的自动GC频率是可以设置的</li></ul><p><img src="/2022/11/14/%E6%B5%85%E6%9E%90GC-%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/image-20221114200653061.png" alt="image-20221114200653061"></p><p>第 0 代满的时候触发GC，GC后第 0 代对象不包括任何对象，并且第一代对象也已经被压缩整理到连续的地址空间中<img src="/2022/11/14/%E6%B5%85%E6%9E%90GC-%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/image-20221114200703105.png" alt="image-20221114200703105"></p><p>超过第 0 代预算时再次触发GC，<strong>假如第 1 代占用内存远少于预算，GC将只检查第 0 代对象，即便此时原来的第 1 代对象中也出现了垃圾对象</strong></p><p><img src="/2022/11/14/%E6%B5%85%E6%9E%90GC-%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/image-20221114200713580.png" alt="image-20221114200713580"></p><h2 id="非托管对象资源回收"><a href="#非托管对象资源回收" class="headerlink" title="非托管对象资源回收"></a>非托管对象资源回收</h2><p>大多数类型只要分配了内存就能够正常工作，但有的类型除了内存还需要本机资源，比如说常用的FileStream，便需要打开一个文件（本机资源）并保存文件句柄，或者是数据库连接信息，那么我们就需要显式释放非托管对象，因为GC仅能跟踪托管堆上的内存资源</p><h3 id="可终结对象（Finalize）"><a href="#可终结对象（Finalize）" class="headerlink" title="可终结对象（Finalize）"></a>可终结对象（Finalize）</h3><p>Finalize方法（C#中是析构函数），允许对象在判定为垃圾之后，在对象内存在回收之前执行一些代码。当一个对象被判定不可达后，对象将终结它自己，并释放包装着的本机资源，之后，GC再从托管堆中回收对象。</p><p>Finalize虽然看似手动清除非托管资源，其实还是由垃圾回收器维护，它的最大作用是确保非托管资源一定被释放</p><p><strong>Finalize方法的执行时间无法控制，所以原则上并不提倡使用终结器机制</strong></p><h3 id="可处置对象（IDisposable）"><a href="#可处置对象（IDisposable）" class="headerlink" title="可处置对象（IDisposable）"></a>可处置对象（IDisposable）</h3><p>为了更快更具操作性进行释放，而非让垃圾回收器（即不可预知）来进行，可以使用Dispose，即实现IDispose接口</p><p>结构和类类型都可以实现IDispose（与重写Finalize不同，Finalize只适用于类类型），<strong>因为不是垃圾回收器来调用Dispose方法，而是对象本身释放非托管资源</strong>，这也意味着如果没有调用Dispose（）方法，非托管资源永远得不到释放</p><p>同样的，Dispose方法也不会将托管对象从托管堆中删除，<strong>我们要记住在正常情况下，只有在GC之后，托管堆中的内存才能得以释放</strong>。习惯用法是将Dispose方法放入try finally的finally块中，以确保代码的顺利执行</p><h2 id="Unity内存管理"><a href="#Unity内存管理" class="headerlink" title="Unity内存管理"></a>Unity内存管理</h2><p><strong>Unity自动内存管理机制</strong></p><ol><li>unity内部有两个内存管理池：堆内存和栈内存。栈内存(stack)主要用来存储较小的和短暂的数据，堆内存(heap)主要用来存储较大的和存储时间较长的数据。</li><li>unity中的变量只会在堆栈或者堆内存上进行内存分配，变量要么存储在堆栈内存上，要么处于堆内存上。</li><li>只要变量处于激活状态，则其占用的内存会被标记为使用状态，则该部分的内存处于被分配的状态。</li><li>一旦变量不再激活，则其所占用的内存不再需要，该部分内存可以被回收到内存池中被再次使用，这样的操作就是内存回收。处于栈上的内存回收极其快速，处于堆上的内存并不是及时回收的，此时其对应的内存依然会被标记为使用状态。</li><li>垃圾回收主要是指堆上的内存分配和回收，unity中会定时对堆内存进行GC操作。</li></ol><p><strong>利用profiler window 来检测堆内存分配</strong></p><p>在CPU usage分析窗口中，我们可以检测任何一帧cpu的内存分配情况。其中一个选项是GC Alloc，通过分析其来定位是什么函数造成大量的堆内存分配操作</p><h1 id="如何减少GC副作用"><a href="#如何减少GC副作用" class="headerlink" title="如何减少GC副作用"></a>如何减少GC副作用</h1><p>主要有三种方法降低影响：</p><ul><li>减少GC的运行次数；</li><li>减少单次GC的运行时间；</li><li>将GC的运行时间延迟，避免在关键时候触发，比如可以在场景加载的时候调用GC</li></ul><p>分别对应着三个策略：</p><p>- </p><ul><li>对游戏进行重构，减少堆内存的分配和引用的分配。更少的变量和引用会减少GC操作中的检测个数从而提高GC的运行效率。</li><li>降低堆内存分配和回收的频率，尤其是在关键时刻。也就是说更少的事件触发GC操作，同时也降低堆内存的碎片化。</li><li>我们可以试着按照可预测的顺序执行。当然这样操作的难度极大</li></ul><h2 id="缓存变量"><a href="#缓存变量" class="headerlink" title="缓存变量"></a>缓存变量</h2><p>如果在代码中反复调用某些造成堆内存分配的函数但是其返回结果并没有使用，这就会造成不必要的内存垃圾，我们可以缓存这些变量来重复利用</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 下面的代码每次调用的时候就会新分配一个数组，造成堆内存分配</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">OnTriggerEnter</span>(<span class="params">Collider other</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">     Renderer[] allRenderers = FindObjectsOfType&lt;Renderer&gt;();</span><br><span class="line">     ExampleFunction(allRenderers);      </span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// --------修改为---------</span></span><br><span class="line"><span class="keyword">private</span> Renderer[] allRenderers;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Start</span>()</span></span><br><span class="line">&#123;</span><br><span class="line">   allRenderers = FindObjectsOfType&lt;Renderer&gt;();</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">OnTriggerEnter</span>(<span class="params">Collider other</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    ExampleFunction(allRenderers);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果是链表等数据结构，记得需要先调用 <code>Clear()</code>函数</p><p>同时也要避免在 <code>Update</code>等函数中反复进行堆内存分配</p><h2 id="对象池方法"><a href="#对象池方法" class="headerlink" title="对象池方法"></a>对象池方法</h2><p>如果游戏有大量的对象需要产生和销毁依然会造成GC。对象池技术可以通过重复使用对象来降低堆内存的分配和回收频率。对象池在游戏中广泛的使用，特别是在游戏中需要频繁的创建和销毁相同的游戏对象的时候，例如枪的子弹</p><p>更进一步，可以不将整个游戏物体 <code>SetActive(false)</code>而是只取消掉他的关键组件</p><h2 id="字符串调用"><a href="#字符串调用" class="headerlink" title="字符串调用"></a>字符串调用</h2><p>在c#中，字符串是引用类型变量而不是值类型变量。</p><p>c#中的字符串在创建后是不可变更的。每次在对字符串进行操作的时候（例如运“加”操作），会新建一个字符串用来存储新的字符串，使得旧的字符串被废弃，这样就会造成内存垃圾</p><p>在Text文本组件中，我们可以分离常量字符串和需要修改的字符串（尤其是表示UI数字的Text），去除 + 操作符，实施创建的字符串还可以使用 <code>StringBuilder</code> </p><h2 id="Unity函数调用"><a href="#Unity函数调用" class="headerlink" title="Unity函数调用"></a>Unity函数调用</h2><h3 id="迭代器"><a href="#迭代器" class="headerlink" title="迭代器"></a>迭代器</h3><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 下面的代码中对于每个迭代器都会产生一个新的数组</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ExampleFunction</span>()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="built_in">int</span> i=<span class="number">0</span>; i &lt; myMesh.normals.Length;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        Vector3 normal = myMesh.normals[i];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// ----修改为---------</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ExampleFunction</span>()</span></span><br><span class="line">&#123;</span><br><span class="line">    Vector3[] meshNormals = myMesh.normals;</span><br><span class="line">    <span class="keyword">for</span>(<span class="built_in">int</span> i=<span class="number">0</span>; i &lt; meshNormals.Length;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        Vector3 normal = meshNormals[i];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="协程"><a href="#协程" class="headerlink" title="协程"></a>协程</h3><p>调用 StartCoroutine()会产生少量的内存垃圾，因为unity会生成实体来管理协程。所以在游戏的关键时刻应该限制该函数的调用</p><p>yield在协程中不会产生堆内存分配，但是如果yield带有参数返回，则会造成不必要的内存垃圾，比如应该将 <code>yield return 0</code> 改为 <code>yield return null</code>,否则会引发装箱</p><p>也尽量少返回一个新创建的变量</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span>(!isComplete)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">yield</span> <span class="keyword">return</span> <span class="keyword">new</span> <span class="title">WaitForSeconds</span>(<span class="params"><span class="number">1f</span></span>)</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 我们可以采用缓存来避免这样的内存垃圾产生：</span></span><br><span class="line"></span><br><span class="line">WaitForSeconds delay = <span class="keyword">new</span> WaiForSeconds(<span class="number">1f</span>);</span><br><span class="line"><span class="keyword">while</span>(!isComplete)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">yield</span> <span class="keyword">return</span> delay;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h3><ul><li>LINQ和常量表达式以装箱的方式实现，所以在使用的时候最好进行性能测试</li><li>struct是值类型的变量，但是如果struct中包含有引用类型的变量，那么GC就必须检测整个struct。</li></ul>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;前置知识&quot;&gt;&lt;a href=&quot;#前置知识&quot; class=&quot;headerlink&quot; title=&quot;前置知识&quot;&gt;&lt;/a&gt;前置知识&lt;/h1&gt;&lt;h2 id=&quot;CLR：公共语言运行时&quot;&gt;&lt;a href=&quot;#CLR：公共语言运行时&quot; class=&quot;headerlink&quot; title=&quot;CLR：公共语言运行时&quot;&gt;&lt;/a&gt;CLR：公共语言运行时&lt;/h2&gt;&lt;p&gt;CLR（Common Language Runtime）：CLR的核心功能包括&lt;strong&gt;内存管理，程序集加载，类型安全，异常处理和线程同步&lt;/strong&gt;，而且还负责对代码实施严格的类型安全检查，保证代码的准确性，这些功能都可以提供给面向CLR的所有语言&lt;/p&gt;
&lt;p&gt;CLR并不关心是使用何种语言进行编程开发，只要编译器是面向CLR而进行编译的即可，这个中间的结果，就是IL(Intermediate Language), 最终面向CLR编译得到的结果是：IL语句以及托管数据(元数据)组成的托管模块&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/2022/11/14/%E6%B5%85%E6%9E%90GC-%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/image-20221114185011460.png&quot; alt=&quot;image-20221114185011460&quot;&gt;&lt;/p&gt;</summary>
    
    
    
    
    <category term="C#" scheme="https://ycy666666.github.io/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>游戏设计模式杂谈（一）</title>
    <link href="https://ycy666666.github.io/2022/11/07/%E6%B8%B8%E6%88%8F%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E6%9D%82%E8%B0%88%EF%BC%88%E4%B8%80%EF%BC%89/"/>
    <id>https://ycy666666.github.io/2022/11/07/%E6%B8%B8%E6%88%8F%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E6%9D%82%E8%B0%88%EF%BC%88%E4%B8%80%EF%BC%89/</id>
    <published>2022-11-07T08:58:28.000Z</published>
    <updated>2022-11-07T08:59:00.678Z</updated>
    
    <content type="html"><![CDATA[<h1 id="设计模式简介"><a href="#设计模式简介" class="headerlink" title="设计模式简介"></a>设计模式简介</h1><p>设计模式的主要目的就在于解耦，也就是今后处理改动的时候<strong>最小化在编写代码前需要了解的信息</strong></p><p>任何设计模式都需要遵循基本原则，让类与类之间减少耦合</p><h2 id="设计模式的类型"><a href="#设计模式的类型" class="headerlink" title="设计模式的类型"></a>设计模式的类型</h2><p><strong>创建型模式</strong>： 这些设计模式提供了一种在创建对象的同时隐藏创建逻辑的方式，而不是使用 new 运算符直接实例化对象。这使得程序在判断针对某个给定实例需要创建哪些对象时更加灵活。</p><p><strong>结构型模式</strong>： 这些设计模式关注类和对象的组合。继承的概念被用来组合接口和定义组合对象获得新功能的方式。</p><p><strong>行为型模式</strong>：这些设计模式特别关注对象之间的通信。</p><span id="more"></span><h1 id="命令模式"><a href="#命令模式" class="headerlink" title="命令模式"></a>命令模式</h1><p>准确定义：<strong>将一个请求封装为一个对象，从而使你可用不同的请求对客户进行参数化； 对请求排队或记录请求日志，以及支持可撤销的操作。</strong></p><p>这太难理解了，简化后就是： <strong>命令是具现化的方法调用</strong>，就是函数调用被存储在对象之中</p><p><strong>什么时候使用？</strong></p><p>游戏中比较常见一种场景就是实现用户自定义配置按键，要实现这样的话我们就不能在代码中将用户输入和将执行的方法一一对应。</p><p>我们需要将游戏行为作为一个<strong>对象</strong>来传递， 将每个行为都继承同一个基类，这样的话就能通过基类调用函数。我们还能在基类中要求实现行为执行的虚函数的同时实现他对应的撤销方法虚函数，这就是如何支持他可撤销的操作</p><p>我们可以给游戏行为指定游戏对象，比如 <code>execute(GameObject go)</code>这样的话不仅<strong>能够复用代码在玩家或者是NPC上</strong>，还能实现本地双人游戏的按键映射</p><p>这样还有个好处，我们能够在选择命令的AI和执行命令的角色之间解耦，这样我们能够为了不同的行为混合AI或者是对同一角色执行不同AI，这样我们就能分模块编写巡逻AI，不同难度的战斗AI，控制AI等</p><h1 id="享元模式"><a href="#享元模式" class="headerlink" title="享元模式"></a>享元模式</h1><p>享元模式，利用先前创建的已有对象，判断当前所需对象是否能够通过原有对象做一定修改后获得</p><p>比如在游戏中出现了一片森林，需要大量的时间渲染，但是每棵树之间只是位置、颜色、大小等可调节差异。那么我们就可以将共有的数据分离到另一个类中</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">TreeModel</span></span><br><span class="line">&#123;</span><br><span class="line">  Mesh mesh_;</span><br><span class="line">  Texture bark_;</span><br><span class="line">  Texture leaves_;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其余的修改数据放到另一个类中，保留对这个类的引用就行了</p><p><img src="/2022/11/07/%E6%B8%B8%E6%88%8F%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E6%9D%82%E8%B0%88%EF%BC%88%E4%B8%80%EF%BC%89/image-20221106200402976.png" alt="image-20221106200402976"></p><p>同时，我们只用发送后每个模型的独特数据后在告诉GPU，用同一模型渲染每一个实例，这样也能减少Drawcall</p><p>更近一步，我们对于游戏中的地形也能采用这样的模式。所有地形都是一个类的不同实例，只是属性不同而已，比如纹理，能够在上面生成的生物类型等。水域，草地，沙漠一系列地形，我们提前创建好他们的范式实例。</p><p><img src="/2022/11/07/%E6%B8%B8%E6%88%8F%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E6%9D%82%E8%B0%88%EF%BC%88%E4%B8%80%EF%BC%89/image-20221106201556447.png" alt="image-20221106201556447"></p><p>我们需要获取某一区块属性的时候就可以直接从那个区块获得</p><p><code>int id = world.getTile(2, 3).getID();</code></p><p>这样相较于在每个函数中判断地形的枚举值，做许多的分支跳转好得多</p><h1 id="观察者模式"><a href="#观察者模式" class="headerlink" title="观察者模式"></a>观察者模式</h1><p>大概思路就是：让代码宣称某个事件触发了，而不必关心谁接受了这个通知。C#甚至专门设定了event关键词来方便我们开发观察者模式</p><p>比如游戏中成就系统，各种全局的管理系统都和各种各样的模块有交互。当我们不想这些模块了解彼此，那样会写出非常不明所以的代码</p><p>比如MC中有一个成就就是把猪摔死，我们总不能在地面每次检测到有东西落地时判断下落物体是不是猪而且有没有摔死，这样的判断放在物理碰撞的代码之后太诡异了。</p><p>我们可以在落地的时候加一个通知，成就系统注册他自己为观察者就行了，具体的判断交给成就系统自己去做。这样的话我们之后修改了成就的具体要求或者是删除了整个成就系统也不会对物理引擎造成丝毫的影响。此外物体落地时的订阅者还可能包含血量减少，音效播放等，这些代码都不应该出现在物理模块中，而是应该传递给对应的模块去处理</p><p><strong>值得注意的地方：</strong></p><p>我们移除了被观察者的时候如果没有取消观察者的注册，有可能这时候他没有被垃圾回收，这个时候事件仍然会被传递，这个问题在通知系统中被称为：<strong>失效监听者问题</strong></p><h1 id="原型模式"><a href="#原型模式" class="headerlink" title="原型模式"></a>原型模式</h1><p>和之前的享元模式不同，原型模式是一种创建型模式，它是根据某种规则去根据原型创建实例</p><p>所有怪物子类都继承基类，并实现他的clone方法来依据模板生成更多一样的怪物。</p><p>这不仅能复制原型的类还能复制他的状态，不需要硬编码修改独特值，只需要有对应的原型就行了</p><h1 id="单例模式"><a href="#单例模式" class="headerlink" title="单例模式"></a>单例模式</h1><p>单例模式算是日常开发中解决问题最容易想到的设计模式，<strong>他保证一个类只有一个实例，并且提供了访问该实例的全局访问点</strong>，这带来了极大的便利，<strong>但是通常他弊大于利</strong></p><ul><li><strong>他是一个全局变量</strong></li></ul><p>这意味着不同模块的代码会相互耦合，比如我们在击打怪物的时候需要播放音乐，而恰好有个全局可见的音乐模板，我们很难抵制诱惑最终在战斗模块中加入有关音频的代码</p><p>同时他对并行操作很难兼容，我们并不知道其他线程是否正在使用单例，很容易造成死锁以及数据同步问题</p><ul><li><strong>我们不能控制初始化</strong></li></ul><p>单例通常都是需要调用时在初始化他，因为这样就不用考虑生命周期的问题。但是如果初始化需要消耗比较多的时间，这就会影响游戏体验。</p><p><strong>如何不使用单例模式？</strong></p><p>很多游戏中的单例类都是作为管理器这个角色，也就是“XXXManager”。很多时候我们都可以删去这些manager，把他们移到单例管理的类当中，让对象管理好自己</p><p>比如有可能我们拥有 <code>Bullet</code>和 <code>BulletManager</code>， <code>BulletManager</code>中拥有生成子弹，移动子弹等方法，但是呢这些都可以让 <code>Bullet</code>自己实现。设计糟糕的单例会让另一个类反而增加代码</p><p>此外，很多时候我们使用单例就是为了方便地获取所需的对象。但是代价就是我们不想要对象的地方也能轻易的使用。我们需要在完成功能的同时，将对象影响的范围改变的尽量小，于是解决方案就有以下几种：</p><ul><li>我们不让方法自己去获取对象，而是将对象传入方法，这是最简单的方法，但是呢，我们在调用攻击怪物的函数时还要传入一个音频的参数，这并没有改善代码的耦合程度</li><li>从基类中获得，我们可以在武器基类中加入<code>protected</code>音频对象，使得不同的武器子类拥有不同的打击音效，每个派生的实体都能调用自己的播放音频方法</li><li>从已经是全局的东西中获取，我们可以将整个游戏世界作为一个单例，将音频，log类作为这个单例的属性，能访问Game这个单例的类才能访问音频，从而限定了范围</li></ul><h1 id="状态模式"><a href="#状态模式" class="headerlink" title="状态模式"></a>状态模式</h1><p>状态模式简单来说可以认为是FSM——有限状态机</p><p>有限状态机在编写玩家控制逻辑的时候经常使用，根据当前角色的状态：下落过程，在地上等过程对同一操作有不同的反应。</p><p>展开来讲状态机就是：<strong>拥有状态机所有可能状态的集合</strong>，<strong>状态机同时只能在一个状态</strong>，<strong>每个状态都有一系列的转移，每个转移与输入和另一状态相关</strong></p><p>更近一步，如果我们允许玩家能拿起武器，这样的话状态就会翻倍：站立，持械站立等等。这可不符合我们的预期，为了改进我们不能使用大量的switch，而是将每个状态都封装为一个类。这样的话每个状态独有的字段都只出现在对应的状态当中，每次输入或者游戏循环都交给当前状态去执行。</p><p>这样有了个新的问题，我们切换状态的时候需要删除之前的状态，而且不同状态切换到同一状态的效果几乎是差不多的。因此我们可以给所有状态添加一个入口方法，这样避免了重复代码而且不用关心从哪个状态转换而来。</p><p>当然如果遇到更复杂的状态编写，我们可以实现分层状态机，使状态之间可以继承来实现层级。或者是遇到需要记录上一个状态的场景，我们可以使用栈来记录，这样就不用为了追踪之前的状态定义很多相似的类：比如站立开火，跑步开火等</p><p><img src="/2022/11/07/%E6%B8%B8%E6%88%8F%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E6%9D%82%E8%B0%88%EF%BC%88%E4%B8%80%EF%BC%89/image-20221107165309628.png" alt="image-20221107165309628"></p><p>当然由于状态机各种各样的限制，如今的AI已经发展成了行为树，规划系统等领域。</p><p>但是他还有有用的，我们可以在下列场景愉快的使用FSM</p><ul><li>你有个实体，它的行为基于一些内在状态。</li><li>状态可以被严格地分割为相对较少的不相干项目。</li><li>实体响应一系列输入或事件。</li></ul>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;设计模式简介&quot;&gt;&lt;a href=&quot;#设计模式简介&quot; class=&quot;headerlink&quot; title=&quot;设计模式简介&quot;&gt;&lt;/a&gt;设计模式简介&lt;/h1&gt;&lt;p&gt;设计模式的主要目的就在于解耦，也就是今后处理改动的时候&lt;strong&gt;最小化在编写代码前需要了解的信息&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;任何设计模式都需要遵循基本原则，让类与类之间减少耦合&lt;/p&gt;
&lt;h2 id=&quot;设计模式的类型&quot;&gt;&lt;a href=&quot;#设计模式的类型&quot; class=&quot;headerlink&quot; title=&quot;设计模式的类型&quot;&gt;&lt;/a&gt;设计模式的类型&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;创建型模式&lt;/strong&gt;： 这些设计模式提供了一种在创建对象的同时隐藏创建逻辑的方式，而不是使用 new 运算符直接实例化对象。这使得程序在判断针对某个给定实例需要创建哪些对象时更加灵活。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;结构型模式&lt;/strong&gt;： 这些设计模式关注类和对象的组合。继承的概念被用来组合接口和定义组合对象获得新功能的方式。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;行为型模式&lt;/strong&gt;：这些设计模式特别关注对象之间的通信。&lt;/p&gt;</summary>
    
    
    
    
    <category term="其他" scheme="https://ycy666666.github.io/tags/%E5%85%B6%E4%BB%96/"/>
    
  </entry>
  
  <entry>
    <title>ECS框架浅析</title>
    <link href="https://ycy666666.github.io/2022/10/31/ECS%E6%A1%86%E6%9E%B6%E6%B5%85%E6%9E%90/"/>
    <id>https://ycy666666.github.io/2022/10/31/ECS%E6%A1%86%E6%9E%B6%E6%B5%85%E6%9E%90/</id>
    <published>2022-10-31T09:30:58.000Z</published>
    <updated>2022-10-31T09:32:18.798Z</updated>
    
    <content type="html"><![CDATA[<h1 id="关于ECS"><a href="#关于ECS" class="headerlink" title="关于ECS"></a>关于ECS</h1><h2 id="为何需要ECS"><a href="#为何需要ECS" class="headerlink" title="为何需要ECS"></a>为何需要ECS</h2><p>在传统的面向对象设计中（OOP）,进行框架设计首先就要进行类的层次结构，而在这一过程中就会出现多重继承困难、层次结构不易改动的现象。</p><p>而且游戏开发中一种比较常见的现象就是，由于操作和数据没分离，A对B造成了伤害，是A去打了B，还是B受到了A的伤害，函数应该放在哪里？ECS就没有这种疑惑，数据存放在Component类、逻辑计算直接由System负责</p><span id="more"></span><p>这和传统的面向对象或是 Actor 模型是截然不同的。OO 或 Actor 强调的是对象自身处理自身的业务，然后框架去管理对象的集合，负责用消息驱动它们。而在 ECS 中，每个系统关注的是不同的对象集合，它处理的对象中有共性的切片。</p><h2 id="ECS的基本概念"><a href="#ECS的基本概念" class="headerlink" title="ECS的基本概念"></a>ECS的基本概念</h2><h3 id="Component：由数据组成"><a href="#Component：由数据组成" class="headerlink" title="Component：由数据组成"></a>Component：由数据组成</h3><p>Component是数据的集合，只有变量，只有Get，Set相应函数或者是对应的属性，<strong>Component之间不能直接通信</strong></p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> Component&#123;</span><br><span class="line"><span class="comment">//子类将会有大量变量，以供System利用</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在定义一个Component时最好先搞清楚它的数据是System数据还是Entity数据。<strong>如果是System的数据，一般设计成单例Component</strong>。例如存放玩家键盘输入的 Component ，全局只需要一个，很多 System 都需要去读这个唯一的 Component 中的数据。</p><h3 id="Entity：-由多个Component组成"><a href="#Entity：-由多个Component组成" class="headerlink" title="Entity： 由多个Component组成"></a>Entity： 由多个Component组成</h3><p>Entity就可以代表我们的游戏物体，比如一个正方体就包含着Position，Rotation等一系列Component，Unity中的GameObject就是这样的存在</p><p>拥有全局唯一的ID来标识自身</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">Entity</span>&#123;</span><br><span class="line">Int32 ID;</span><br><span class="line">    <span class="comment">//通过观察者模式将自己注册到System可以提升System遍历的速度，因为只需要遍历已经注册的entity</span></span><br><span class="line">List&lt;Component&gt; components;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Entity需要遵循立即创建和延迟销毁原则，销毁放在帧末执行，不然很容易空引用</p><h3 id="System：由纯逻辑组成"><a href="#System：由纯逻辑组成" class="headerlink" title="System：由纯逻辑组成"></a>System：由纯逻辑组成</h3><p>System用来制定游戏的运行规则，只有函数，没有变量。System之间的执行顺序需要严格制定。<strong>System之间不可以直接通信</strong>。</p><p>一个 System只关心某一个固定的Component组合，这个组合集合称为tuple。</p><p><strong>各个System的Update顺序要根据具体情况设置好</strong>，System在Update时都会遍历所有的Entity，如果一个Entity拥有该System的tuple中指定的所有Component实例，则对该Entity进行处理。看到这里你可能会想每次update都遍历Entity，会不会太耗费时间，因此前面我们推荐使用观察者模式来注册</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">System</span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">Update</span>()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title">ASystem</span>:<span class="title">System</span>&#123;</span><br><span class="line">    Tuple tuple;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">override</span> <span class="keyword">void</span> <span class="title">Update</span>()</span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(Entity entity <span class="keyword">in</span> World.entitys)&#123;</span><br><span class="line">            <span class="keyword">if</span>(entity.components中有tuple指定的所有Component实例)&#123;</span><br><span class="line">                <span class="comment">//do something for Components</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="World-整个游戏世界"><a href="#World-整个游戏世界" class="headerlink" title="World:整个游戏世界"></a>World:整个游戏世界</h3><p>游戏通常情况下只会有一个world，但是守望先锋等游戏为了死亡回放等游戏内容创建了两个world（后面还会有很多次提到守望先锋，因为他是最早使用ECS框架的）</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">World</span>&#123;</span><br><span class="line">    List&lt;System&gt; systems;                   <span class="comment">//所有System</span></span><br><span class="line">    dictionary&lt;Int32, Entity&gt; entitys;      <span class="comment">//所有Entity，Int32是Entity.ID</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//由引擎帧循环驱动</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Update</span>()</span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(System sys <span class="keyword">in</span> systems)</span><br><span class="line">            sys.Update();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="ECS的优点"><a href="#ECS的优点" class="headerlink" title="ECS的优点"></a>ECS的优点</h1><h2 id="任意增删"><a href="#任意增删" class="headerlink" title="任意增删"></a>任意增删</h2><p>因为Component之间不可以直接访问，System之间也不可以直接访问，System和Component在设计原则上也不存在耦合。</p><p>对于System来说，Component只是放在一边的数据，Component提供的数据足够就update，数据不够就不update。所以随时增删任意Component和System都不会导致游戏崩溃报错</p><p>比如一个单位中了不能移动的Debuff，那么我们只需要去掉这个单位的Move Component就行了，如果是玩家那么再去掉一个Input Component就可以了</p><h2 id="优化性能"><a href="#优化性能" class="headerlink" title="优化性能"></a>优化性能</h2><p>因为数据都被统一存放到Component中，所以如果能够在内存中以合理的方式将所有Component聚合到连续的内存中，这样可以大幅度提升cpu cache命中率</p><p>Unity，在传统模式下，我们在场景中创建一个Cube，上面会有Transform，MeshRenderer，Collider等组件，而这些组件在内存中的排放都是无序的，这就会降低我们的缓存命中率</p><p>每个内存块我们称之为Chunk，ECS会将符合Chunk对应组合的Entity放在该Chunk当中。一个Chunk中，内存地址是连续的，大小固定为16KB</p><h2 id="避免不必要开销"><a href="#避免不必要开销" class="headerlink" title="避免不必要开销"></a>避免不必要开销</h2><p>守望先锋在GDC中移除不活跃用户时，AFK 处理系统遍历所有同时具备连接组件、输入组件等组件的对象，根据最近输入事件产生的时间强制下线。AI 控制的机器人，由于没有连接组件，就根本不会遍历到，也就不用在其上面浪费计算资源了</p><h1 id="ECS的实际运用"><a href="#ECS的实际运用" class="headerlink" title="ECS的实际运用"></a>ECS的实际运用</h1><h2 id="需要遵循的原则"><a href="#需要遵循的原则" class="headerlink" title="需要遵循的原则"></a>需要遵循的原则</h2><ol><li>设计并不是从Entity开始的，而是应该从System抽象出Component，最后组装到Entity中。</li><li>设计的过程中尽量确保每个System都依赖很多Component去运行，也就是说System和Component并不是一对一的关系，而是一对多的关系。<ul><li>System和Component的划分很难在一开始就确定好，一般都是在实现的过程中看情况一步一步地去划分System和Component。</li></ul></li><li>System<strong>尽量</strong>不改变Component的数据。<ul><li>可以读数据完成的功能就不要写数据来完成。因为写数据会影响到使用了这些数据的模块，如果对于其它模块不熟悉的话，就会产生Bug。如果只是读数据来增加功能的话，即使出Bug也只局限于新功能中，而不会影响其它模块。这样容易管理复杂度，而且给并行处理留下了优化空间</li></ul></li></ol><h2 id="处理一些复杂问题的常见手法"><a href="#处理一些复杂问题的常见手法" class="headerlink" title="处理一些复杂问题的常见手法"></a>处理一些复杂问题的常见手法</h2><h3 id="同类问题的处理方式"><a href="#同类问题的处理方式" class="headerlink" title="同类问题的处理方式"></a>同类问题的处理方式</h3><p>​许多 System 中很可能会处理同一类问题，涉及的 Component 类型是相同的。<strong>如果这个有共性的问题只涉及一个 Entity ，那么直观的方法是设计一个 System ，迭代，逐个把结果计算出来，存为 Component 的状态</strong>，别的 System 可以在后续把这个结果作为一个状态读出来就可以了。</p><p>​但如果<strong>这个行为涉及多个 Entity</strong> ，比如在不同的 System 中，都需要查询两个 Entity 的敌对关系。我们不可能用一个 System 计算出所有 Entity 间的敌对关系，这样必然产生了大量不必要的计算；又或者这个行为并不想额外修改 Component 的状态，希望对它保持无副作用，比如我想持续模拟一个对象随时间流逝的位置变化，就不能用一个 System 计算好，再从另一个 System 读出来。</p><p>​这样，<strong>就引入了 Utility 函数的概念，来做上面这种类型的操作，再把 Utility 函数共享给不同的 System 调用（也就是单例组件）</strong>。为了降低系统复杂度，就要求要么这种函数是无副作用的，随便怎么调用都没问题，比如上面查询敌对关系的例子；要么就限制调用这种函数的地方，仅在很少的地方调用，由调用者小心的保证副作用的影响，比如上面那个持续位置变化的过程。</p><p>​如果产生状态改变这种副作用的行为必须存在时，又在很多 System 中都会触发，那么为了减少调用的地方，就需要把真正产生副作用的点集中在一处了。这个技巧就是推迟行为的发生时机。就是把行为发生时需要的状态保存起来，放在队列里，由一个单独的 System 在独立的环节集中处理它们。集中在一起推迟到当前帧的末尾或下一帧的开头来做。</p><h3 id="网络问题"><a href="#网络问题" class="headerlink" title="网络问题"></a>网络问题</h3><p>ECS 要解决的最复杂，最核心的问题，或许还是网络同步。我认为这也是设计一个状态和行为严格分离的框架的主要动机。因为一个好的网络同步系统必须实现预测、有预测就有预测失败的情况，发生后要解决冲突，回滚状态是必须支持的。而状态回滚还包括了只回滚部分状态，而不能简单回滚整个世界。</p><p>​ECS 框架在这件事上可以做到只去回滚和重算相关的 Component ，一个 System 知道哪些 Entity 才是它真正关心的，该怎么回退它所关心的东西。这样开发的复杂度就减少了。游戏本身是复杂的，但是和网络同步相关的影响到游戏业务的 System 却很少，而且参与的 Component 几乎都是只读的。这样我们就尽可能的把这个复杂的问题和引擎其它部分解耦。</p>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;关于ECS&quot;&gt;&lt;a href=&quot;#关于ECS&quot; class=&quot;headerlink&quot; title=&quot;关于ECS&quot;&gt;&lt;/a&gt;关于ECS&lt;/h1&gt;&lt;h2 id=&quot;为何需要ECS&quot;&gt;&lt;a href=&quot;#为何需要ECS&quot; class=&quot;headerlink&quot; title=&quot;为何需要ECS&quot;&gt;&lt;/a&gt;为何需要ECS&lt;/h2&gt;&lt;p&gt;在传统的面向对象设计中（OOP）,进行框架设计首先就要进行类的层次结构，而在这一过程中就会出现多重继承困难、层次结构不易改动的现象。&lt;/p&gt;
&lt;p&gt;而且游戏开发中一种比较常见的现象就是，由于操作和数据没分离，A对B造成了伤害，是A去打了B，还是B受到了A的伤害，函数应该放在哪里？ECS就没有这种疑惑，数据存放在Component类、逻辑计算直接由System负责&lt;/p&gt;</summary>
    
    
    
    
    <category term="Unity" scheme="https://ycy666666.github.io/tags/Unity/"/>
    
  </entry>
  
  <entry>
    <title>A-Star寻路算法</title>
    <link href="https://ycy666666.github.io/2022/10/12/A-Star%E5%AF%BB%E8%B7%AF%E7%AE%97%E6%B3%95/"/>
    <id>https://ycy666666.github.io/2022/10/12/A-Star%E5%AF%BB%E8%B7%AF%E7%AE%97%E6%B3%95/</id>
    <published>2022-10-12T03:11:44.000Z</published>
    <updated>2022-10-12T03:12:22.923Z</updated>
    
    <content type="html"><![CDATA[<h1 id="各寻路算法之间的比较"><a href="#各寻路算法之间的比较" class="headerlink" title="各寻路算法之间的比较"></a>各寻路算法之间的比较</h1><p>深度优先算法（BFS）在所有方向上平等的探索，是最好写的寻路算法</p><p>Dijkstra算法优先考虑低成本的路径，在游戏中可以规定远离敌人、避开森林需要更高的成本，所以当移动成本发生变化的时候我们使用该算法而不是BFS</p><p>A*寻路是对Dijkstra算法的修改，针对单个目标时进行了优化，Dijkstra的算法可以找到所有位置的路径;A 查找到一个位置的路径，或多个位置中最近的路径。它优先考虑似乎更接近目标的路径。</p><p>下图依次表示他们的搜索区间估计范围</p><p><img src="/2022/10/12/A-Star%E5%AF%BB%E8%B7%AF%E7%AE%97%E6%B3%95/image-20221011155903860.png" alt="image-20221011155903860"></p><span id="more"></span><p>Dijkstra的算法可以很好地找到最短的路径，但它浪费了时间探索那些没有希望的方向。Greedy Best-First在有希望的方向上探索，但它可能不会找到最短的路径。A* 算法<em>同时</em>使用从起点开始的实际距离和到目标的估计距离。</p><p>不同算法情况下不同的搜索范围和最终路线</p><p><img src="/2022/10/12/A-Star%E5%AF%BB%E8%B7%AF%E7%AE%97%E6%B3%95/image-20221011160752165.png" alt="image-20221011160752165"></p><h1 id="A-寻路算法的过程"><a href="#A-寻路算法的过程" class="headerlink" title="A*寻路算法的过程"></a>A*寻路算法的过程</h1><p>对于任意一个格子n，其估价函数如下：</p><blockquote><p>f(n) &#x3D; g(n) + h(n)</p></blockquote><p><strong>其中 g(n) 指的是从起始格子到格子n的实际代价，而 h(n) 指的是从格子n到终点格子的估计代价。</strong></p><ol><li>我们找到周围格子中f(n)值最小的各格子，在计算他周围格子的f(n)</li><li>一直找出边界格子中的f(n)最小的格子，直到找到与重点相邻的格子。</li></ol><h2 id="A-对启发式方法的使用"><a href="#A-对启发式方法的使用" class="headerlink" title="A*对启发式方法的使用"></a>A*对启发式方法的使用</h2><p>启发式算法，即<strong>优先搜索最有可能产生最佳路径的格子</strong>。</p><p>对于h（n）函数，不同的表示方法会导致最终结果的不同，比如如果采用曼哈顿距离（只能水平和垂直移动）和欧几里得距离（直线距离）</p><p>h(n)的具体影响为： </p><ul><li>在一个极端，如果是0,那么会漫无目的的寻找，A*变成Dijkstra的算法，它保证找到一个最短的路径。</li><li>如果始终低于到目标实际距离，则保证 A* 找到最短路径。越低，节点 A* 扩展得越多，速度越慢。</li><li>如果 正好等于到目标实际距离，则 A* 只会遵循最佳路径，从不扩展其他任何内容，使其非常快。虽然您无法在所有情况下都做到这一点，但在某些特殊情况下可以使其精确。很高兴知道，给定完美的信息，A *将表现完美。</li><li>如果大于到目标实际距离，则A *不能保证找到最短的路径，但它可以运行得更快。</li><li>在另一个极端，如果非常高，那么主要取决与h(n)，而A*变成了贪心算法</li></ul><p>使用具体的移动方式匹配地图：</p><ul><li>在允许 4 个方向移动<strong>的</strong>正方形网格上，使用曼哈顿距离 .</li><li>在允许 <strong>8 个方向移动的</strong>方形网格上，使用对角线距离 .</li></ul><h1 id="A-算法的具体实现"><a href="#A-算法的具体实现" class="headerlink" title="A*算法的具体实现"></a>A*算法的具体实现</h1><p>地图中允许8D运动，h（n）采用对角线加直线运动。我们就可以根据水平方向的差值与竖直方向的差值中较小的那个值，计算出对角线，然后再平移。</p><p>横向纵向的格子的单位消耗为10，对角单位消耗为14。</p><p>定义一个<code>OpenList</code>，用于存储和搜索当前最小值的格子。</p><p>定义一个<code>CloseList</code>，用于标记已经处理过的格子，以防止重复搜索。</p><p>将<code>OpenList</code>中f值最小的点作为当前点，加入邻居点到<code>OpenList</code></p><p>对于邻居点执行以下代码伪代码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">如果邻居点在OpenList中</span><br><span class="line">    计算当前值的G与该邻居点的G值</span><br><span class="line">    如果G值比该邻居点的G值小</span><br><span class="line">        将当前点设置为该邻居点的父节点</span><br><span class="line">        更新该邻居点的GF值</span><br><span class="line">若不在</span><br><span class="line">    计算并设置当前点与该邻居点的G值</span><br><span class="line">    计算并设置当前点与该邻居点的H值</span><br><span class="line">    计算并设置该邻居点的F值</span><br><span class="line">    将当前点设置为该邻居点的父节点</span><br></pre></td></tr></table></figure><p>判断终点是否在<code>OpenList</code>中，如果已在<code>OpenList</code>中，则返回该点，其父节点连起来的路径就是A*搜索的路径。如果不在，则重复执行2，3，4，5。直到找到终点，或者<code>OpenList</code>中节点数量为0。</p><h2 id="格子的记录值"><a href="#格子的记录值" class="headerlink" title="格子的记录值"></a>格子的记录值</h2><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Node</span></span><br><span class="line">&#123;</span><br><span class="line">    Int2 m_position;<span class="comment">//下标</span></span><br><span class="line">    <span class="keyword">public</span> Int2 position =&gt; m_position;</span><br><span class="line">    <span class="keyword">public</span> Node parent;<span class="comment">//上一个node</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//角色到该节点的实际距离</span></span><br><span class="line">    <span class="built_in">int</span> m_g;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span> g &#123;</span><br><span class="line">        <span class="keyword">get</span> =&gt; m_g;</span><br><span class="line">        <span class="keyword">set</span> &#123;</span><br><span class="line">            m_g = <span class="keyword">value</span>;</span><br><span class="line">            m_f = m_g + m_h;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//该节点到目的地的估价距离</span></span><br><span class="line">    <span class="built_in">int</span> m_h;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span> h &#123;</span><br><span class="line">        <span class="keyword">get</span> =&gt; m_h;</span><br><span class="line">        <span class="keyword">set</span> &#123;</span><br><span class="line">            m_h = <span class="keyword">value</span>;</span><br><span class="line">            m_f = m_g + m_h;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">int</span> m_f;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span> f =&gt; m_f;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Node</span>(<span class="params">Int2 pos, Node parent, <span class="built_in">int</span> g, <span class="built_in">int</span> h</span>)</span> &#123;</span><br><span class="line">        m_position = pos;</span><br><span class="line">        <span class="keyword">this</span>.parent = parent;</span><br><span class="line">        m_g = g;</span><br><span class="line">        m_h = h;</span><br><span class="line">        m_f = m_g + m_h;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="A-过程"><a href="#A-过程" class="headerlink" title="A*过程"></a>A*过程</h2><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">AStar</span> &#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="built_in">int</span> FACTOR = <span class="number">10</span>;<span class="comment">//水平竖直相邻格子的距离</span></span><br><span class="line">    <span class="keyword">static</span> <span class="built_in">int</span> FACTOR_DIAGONAL = <span class="number">14</span>;<span class="comment">//对角线相邻格子的距离</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">bool</span> m_isInit = <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">bool</span> isInit =&gt; m_isInit;</span><br><span class="line"></span><br><span class="line">    UIGridController[,] m_map;<span class="comment">//地图数据</span></span><br><span class="line">    Int2 m_mapSize;</span><br><span class="line">    Int2 m_player, m_destination;<span class="comment">//起始点和结束点坐标</span></span><br><span class="line">    EvaluationFunctionType m_evaluationFunctionType;<span class="comment">//估价方式</span></span><br><span class="line"></span><br><span class="line">    Dictionary&lt;Int2, Node&gt; m_openDic = <span class="keyword">new</span> Dictionary&lt;Int2, Node&gt;();<span class="comment">//准备处理的网格</span></span><br><span class="line">    Dictionary&lt;Int2, Node&gt; m_closeDic = <span class="keyword">new</span> Dictionary&lt;Int2, Node&gt;();<span class="comment">//完成处理的网格</span></span><br><span class="line"></span><br><span class="line">    Node m_destinationNode;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Init</span>(<span class="params">UIGridController[,] map, Int2 mapSize, Int2 player, Int2 destination, EvaluationFunctionType type = EvaluationFunctionType.Diagonal</span>)</span> &#123;</span><br><span class="line">        m_map = map;</span><br><span class="line">        m_mapSize = mapSize;</span><br><span class="line">        m_player = player;</span><br><span class="line">        m_destination = destination;</span><br><span class="line">        m_evaluationFunctionType = type;</span><br><span class="line"></span><br><span class="line">        m_openDic.Clear();</span><br><span class="line">        m_closeDic.Clear();</span><br><span class="line"></span><br><span class="line">        m_destinationNode = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//将起始点加入open中</span></span><br><span class="line">        AddNodeInOpenQueue(<span class="keyword">new</span> Node(m_player, <span class="literal">null</span>, <span class="number">0</span>, <span class="number">0</span>));</span><br><span class="line">        m_isInit = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//计算寻路</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> IEnumerator <span class="title">Start</span>()</span> &#123;</span><br><span class="line">        <span class="keyword">while</span>(m_openDic.Count &gt; <span class="number">0</span> &amp;&amp; m_destinationNode == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="comment">//按照f的值升序排列</span></span><br><span class="line">            m_openDic = m_openDic.OrderBy(kv =&gt; kv.Value.f).ToDictionary(p =&gt; p.Key, o =&gt; o.Value);</span><br><span class="line">            <span class="comment">//提取排序后的第一个节点</span></span><br><span class="line">            Node node = m_openDic.First().Value;</span><br><span class="line">            <span class="comment">//因为使用的不是Queue，因此要从open中手动删除该节点</span></span><br><span class="line">            m_openDic.Remove(node.position);</span><br><span class="line">            <span class="comment">//处理该节点相邻的节点</span></span><br><span class="line">            OperateNeighborNode(node);</span><br><span class="line">            <span class="comment">//处理完后将该节点加入close中</span></span><br><span class="line">            AddNodeInCloseDic(node);</span><br><span class="line">            <span class="keyword">yield</span> <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(m_destinationNode == <span class="literal">null</span>)</span><br><span class="line">            Debug.LogError(<span class="string">&quot;找不到可用路径&quot;</span>);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            ShowPath(m_destinationNode);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//处理相邻的节点</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">OperateNeighborNode</span>(<span class="params">Node node</span>)</span> &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="built_in">int</span> i = <span class="number">-1</span>; i &lt; <span class="number">2</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="built_in">int</span> j = <span class="number">-1</span>; j &lt; <span class="number">2</span>; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span>(i == <span class="number">0</span> &amp;&amp; j == <span class="number">0</span>)</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                Int2 pos = <span class="keyword">new</span> Int2(node.position.x + i, node.position.y + j);</span><br><span class="line">                <span class="comment">//超出地图范围</span></span><br><span class="line">                <span class="keyword">if</span>(pos.x &lt; <span class="number">0</span> || pos.x &gt;= m_mapSize.x || pos.y &lt; <span class="number">0</span> || pos.y &gt;= m_mapSize.y)</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                <span class="comment">//已经处理过的节点</span></span><br><span class="line">                <span class="keyword">if</span>(m_closeDic.ContainsKey(pos))</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                <span class="comment">//障碍物节点</span></span><br><span class="line">                <span class="keyword">if</span>(m_map[pos.x, pos.y].state == GridState.Obstacle)</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                <span class="comment">//将相邻节点加入open中</span></span><br><span class="line">                <span class="keyword">if</span>(i == <span class="number">0</span> || j == <span class="number">0</span>)</span><br><span class="line">                    AddNeighborNodeInQueue(node, pos, FACTOR);</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    AddNeighborNodeInQueue(node, pos, FACTOR_DIAGONAL);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//将节点加入到open中</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">AddNeighborNodeInQueue</span>(<span class="params">Node parentNode, Int2 position, <span class="built_in">int</span> g</span>)</span> &#123;</span><br><span class="line">        <span class="comment">//当前节点的实际距离g等于上个节点的实际距离加上自己到上个节点的实际距离</span></span><br><span class="line">        <span class="built_in">int</span> nodeG = parentNode.g + g;</span><br><span class="line">        <span class="comment">//如果该位置的节点已经在open中</span></span><br><span class="line">        <span class="keyword">if</span>(m_openDic.ContainsKey(position)) &#123;</span><br><span class="line">            <span class="comment">//比较实际距离g的值，用更小的值替换</span></span><br><span class="line">            <span class="keyword">if</span>(nodeG &lt; m_openDic[position].g) &#123;</span><br><span class="line">                m_openDic[position].g = nodeG;</span><br><span class="line">                m_openDic[position].parent = parentNode;</span><br><span class="line">                ShowOrUpdateAStarHint(m_openDic[position]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//生成新的节点并加入到open中</span></span><br><span class="line">            Node node = <span class="keyword">new</span> Node(position, parentNode, nodeG, GetH(position));</span><br><span class="line">            <span class="comment">//如果周边有一个是终点，那么说明已经找到了。</span></span><br><span class="line">            <span class="keyword">if</span>(position == m_destination)</span><br><span class="line">                m_destinationNode = node;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                AddNodeInOpenQueue(node);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//加入open中，并更新网格状态</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">AddNodeInOpenQueue</span>(<span class="params">Node node</span>)</span> &#123;</span><br><span class="line">        m_openDic[node.position] = node;</span><br><span class="line">        ShowOrUpdateAStarHint(node);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">ShowOrUpdateAStarHint</span>(<span class="params">Node node</span>)</span> &#123;</span><br><span class="line">        m_map[node.position.x, node.position.y].ShowOrUpdateAStarHint(node.g, node.h, node.f,</span><br><span class="line">            node.parent == <span class="literal">null</span> ? Vector2.zero : <span class="keyword">new</span> Vector2(node.parent.position.x - node.position.x, node.parent.position.y - node.position.y));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//加入close中，并更新网格状态</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">AddNodeInCloseDic</span>(<span class="params">Node node</span>)</span> &#123;</span><br><span class="line">        m_closeDic.Add(node.position, node);</span><br><span class="line">        m_map[node.position.x, node.position.y].ChangeInOpenStateToInClose();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//寻路完成，显示路径</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">ShowPath</span>(<span class="params">Node node</span>)</span> &#123;</span><br><span class="line">        <span class="keyword">while</span>(node != <span class="literal">null</span>) &#123;</span><br><span class="line">            m_map[node.position.x, node.position.y].ChangeToPathState();</span><br><span class="line">            node = node.parent;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//获取估价距离</span></span><br><span class="line">    <span class="function"><span class="built_in">int</span> <span class="title">GetH</span>(<span class="params">Int2 position</span>)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(m_evaluationFunctionType == EvaluationFunctionType.Manhattan)</span><br><span class="line">            <span class="keyword">return</span> GetManhattanDistance(position);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(m_evaluationFunctionType == EvaluationFunctionType.Diagonal)</span><br><span class="line">            <span class="keyword">return</span> GetDiagonalDistance(position);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">return</span> Mathf.CeilToInt(GetEuclideanDistance(position));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//获取对角线距离</span></span><br><span class="line">    <span class="function"><span class="built_in">int</span> <span class="title">GetDiagonalDistance</span>(<span class="params">Int2 position</span>)</span> &#123;</span><br><span class="line">        <span class="built_in">int</span> x = Mathf.Abs(m_destination.x - position.x);</span><br><span class="line">        <span class="built_in">int</span> y = Mathf.Abs(m_destination.y - position.y);</span><br><span class="line">        <span class="built_in">int</span> min = Mathf.Min(x, y);</span><br><span class="line">        <span class="keyword">return</span> min * FACTOR_DIAGONAL + Mathf.Abs(x - y) * FACTOR;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//获取曼哈顿距离</span></span><br><span class="line">    <span class="function"><span class="built_in">int</span> <span class="title">GetManhattanDistance</span>(<span class="params">Int2 position</span>)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> Mathf.Abs(m_destination.x - position.x) * FACTOR + Mathf.Abs(m_destination.y - position.y) * FACTOR;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Clear</span>()</span> &#123;</span><br><span class="line">        <span class="keyword">foreach</span>(<span class="keyword">var</span> pos <span class="keyword">in</span> m_openDic.Keys) &#123;</span><br><span class="line">            m_map[pos.x, pos.y].ClearAStarHint();</span><br><span class="line">        &#125;</span><br><span class="line">        m_openDic.Clear();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">foreach</span>(<span class="keyword">var</span> pos <span class="keyword">in</span> m_closeDic.Keys) &#123;</span><br><span class="line">            m_map[pos.x, pos.y].ClearAStarHint();</span><br><span class="line">        &#125;</span><br><span class="line">        m_closeDic.Clear();</span><br><span class="line">        m_destinationNode = <span class="literal">null</span>;</span><br><span class="line">        m_isInit = <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="最终结果"><a href="#最终结果" class="headerlink" title="最终结果"></a>最终结果</h1><h2 id="在unity中呈现效果"><a href="#在unity中呈现效果" class="headerlink" title="在unity中呈现效果"></a>在unity中呈现效果</h2><p>我们在生成的格子中添加显示F,G,H值的文本，在创建一个<code>MapController</code>来管理网格的属性、颜色等，暴露函数给按钮调用</p><p><img src="/2022/10/12/A-Star%E5%AF%BB%E8%B7%AF%E7%AE%97%E6%B3%95/image-20221012104733538.png" alt="image-20221012104733538"></p><p><img src="/2022/10/12/A-Star%E5%AF%BB%E8%B7%AF%E7%AE%97%E6%B3%95/image-20221012110933599.png" alt="image-20221012110933599"></p>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;各寻路算法之间的比较&quot;&gt;&lt;a href=&quot;#各寻路算法之间的比较&quot; class=&quot;headerlink&quot; title=&quot;各寻路算法之间的比较&quot;&gt;&lt;/a&gt;各寻路算法之间的比较&lt;/h1&gt;&lt;p&gt;深度优先算法（BFS）在所有方向上平等的探索，是最好写的寻路算法&lt;/p&gt;
&lt;p&gt;Dijkstra算法优先考虑低成本的路径，在游戏中可以规定远离敌人、避开森林需要更高的成本，所以当移动成本发生变化的时候我们使用该算法而不是BFS&lt;/p&gt;
&lt;p&gt;A*寻路是对Dijkstra算法的修改，针对单个目标时进行了优化，Dijkstra的算法可以找到所有位置的路径;A 查找到一个位置的路径，或多个位置中最近的路径。它优先考虑似乎更接近目标的路径。&lt;/p&gt;
&lt;p&gt;下图依次表示他们的搜索区间估计范围&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/2022/10/12/A-Star%E5%AF%BB%E8%B7%AF%E7%AE%97%E6%B3%95/image-20221011155903860.png&quot; alt=&quot;image-20221011155903860&quot;&gt;&lt;/p&gt;</summary>
    
    
    
    
    <category term="Unity" scheme="https://ycy666666.github.io/tags/Unity/"/>
    
  </entry>
  
  <entry>
    <title>unity任务系统</title>
    <link href="https://ycy666666.github.io/2022/09/25/unity%E4%BB%BB%E5%8A%A1%E7%B3%BB%E7%BB%9F/"/>
    <id>https://ycy666666.github.io/2022/09/25/unity%E4%BB%BB%E5%8A%A1%E7%B3%BB%E7%BB%9F/</id>
    <published>2022-09-25T15:51:37.000Z</published>
    <updated>2022-10-06T09:06:37.228Z</updated>
    
    <content type="html"><![CDATA[<h1 id="读取策划配置表"><a href="#读取策划配置表" class="headerlink" title="读取策划配置表"></a>读取策划配置表</h1><p>一般策划都是通过EXCEL来配置，如下图所示：</p><p><img src="/2022/09/25/unity%E4%BB%BB%E5%8A%A1%E7%B3%BB%E7%BB%9F/image-20220925124533325.png" alt="image-20220925124533325"></p><h2 id="Unity读取EXCEL"><a href="#Unity读取EXCEL" class="headerlink" title="Unity读取EXCEL"></a>Unity读取EXCEL</h2><p>游戏中并不是直接读取<code>Excel</code>配置，实际项目中一般都是将<code>Excel</code>转为<code>xml</code>、<code>json</code>、<code>lua</code>或自定义的文本格式的配置，这样不会让Excel打包时占据额外空间。</p><p>对于 <code>Json</code>格式，在 <code>Excel</code>中能够安装额外的插件，直接导出为 <code>Json</code>格式，当然也可以用 <code>Python</code>批量化处理，这里不赘述</p><span id="more"></span><h2 id="读取json"><a href="#读取json" class="headerlink" title="读取json"></a>读取json</h2><p><strong>我们将json文件都放入Resource文件夹中</strong>。但一般不推荐按这样做，因为Resource文件夹只读，而且打包时会全部进行压缩后打包。建议将资源打成<code>AssetBundle</code>放在<code>StreamingAssets</code>目录或服务器中，方便热更资源</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">string</span> txt = Resources.Load&lt;TextAsset&gt;(<span class="string">&quot;task_cfg&quot;</span>).text;</span><br></pre></td></tr></table></figure><p>引入<code>LitJson</code>能帮助我们更好的配置   地址：<a href="https://hub.fastgit.org/LitJSON/litjson">https://hub.fastgit.org/LitJSON/litjson</a></p><p>使用时引入命名空间： <code>using LitJson;</code></p><h3 id="任务配置读取"><a href="#任务配置读取" class="headerlink" title="任务配置读取"></a>任务配置读取</h3><p><code>LitJson</code>提供了一个<code>JsonMapper.ToObject&lt;T&gt;(jsonString)</code>方法，可以直接将<code>json</code>字符串转为类对象，前提是类的字段名要与<code>json</code>的字段相同</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> 任务配置结构</span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">TaskCfgItem</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span> task_chain_id;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span> task_sub_id;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">string</span> icon;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">string</span> desc;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">string</span> task_target;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span> target_amount;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">string</span> award;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">string</span> open_chain;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">TaskCfg</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// 任务配置，(链id : 子任务id : TaskCfgItem)</span></span><br><span class="line"><span class="keyword">private</span> Dictionary&lt;<span class="built_in">int</span>, Dictionary&lt;<span class="built_in">int</span>, TaskCfgItem&gt;&gt; m_cfg;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 单例模式</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> TaskCfg s_instance;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> TaskCfg instance</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">get</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (s_instance == <span class="literal">null</span>)</span><br><span class="line">                s_instance = <span class="keyword">new</span> TaskCfg();</span><br><span class="line">            <span class="keyword">return</span> s_instance;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 读取配置</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">LoadCfg</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        m_cfg = <span class="keyword">new</span> Dictionary&lt;<span class="built_in">int</span>, Dictionary&lt;<span class="built_in">int</span>, TaskCfgItem&gt;&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">var</span> txt = Resources.Load&lt;TextAsset&gt;(<span class="string">&quot;task_cfg&quot;</span>).text;</span><br><span class="line">        <span class="comment">// 直接转换为类对象</span></span><br><span class="line">        <span class="keyword">var</span> jd = JsonMapper.ToObject&lt;JsonData&gt;(txt);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 根据转换之后的类对象的个数循环</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>, cnt = jd.Count; i &lt; cnt; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 读取每个类对象，将其视作JsonData格式 </span></span><br><span class="line">            <span class="keyword">var</span> itemJd = jd[i] <span class="keyword">as</span> JsonData;</span><br><span class="line">            <span class="comment">// 转换为任务配置对象</span></span><br><span class="line">            TaskCfgItem cfgItem = JsonMapper.ToObject&lt;TaskCfgItem&gt;(itemJd.ToJson());</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 任务配置中字典的相应操作</span></span><br><span class="line">            <span class="keyword">if</span> (!m_cfg.ContainsKey(cfgItem.task_chain_id))</span><br><span class="line">            &#123;</span><br><span class="line">                m_cfg[cfgItem.task_chain_id] = <span class="keyword">new</span> Dictionary&lt;<span class="built_in">int</span>, TaskCfgItem&gt;();</span><br><span class="line">            &#125;</span><br><span class="line">            m_cfg[cfgItem.task_chain_id].Add(cfgItem.task_sub_id, cfgItem);</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 获取任务配置</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> TaskCfgItem <span class="title">GetCfgItem</span>(<span class="params"><span class="built_in">int</span> chainId, <span class="built_in">int</span> taskSubId</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (m_cfg.ContainsKey(chainId) &amp;&amp; m_cfg[chainId].ContainsKey(taskSubId))</span><br><span class="line">            <span class="keyword">return</span> m_cfg[chainId][taskSubId];</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><img src="/2022/09/25/unity%E4%BB%BB%E5%8A%A1%E7%B3%BB%E7%BB%9F/image-20220925151702813.png" alt="image-20220925151702813"></p><h1 id="任务数据的更新"><a href="#任务数据的更新" class="headerlink" title="任务数据的更新"></a>任务数据的更新</h1><p>目前只考虑客户端进行任务数据的管理，与服务端进行交互不在本篇的介绍范围内</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">TaskDataItem</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 链id</span></span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span> task_chain_id;</span><br><span class="line">    <span class="comment">// 任务子id</span></span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span> task_sub_id;</span><br><span class="line">    <span class="comment">// 进度</span></span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span> progress;</span><br><span class="line">    <span class="comment">// 奖励是否被领取了，0：未被领取，1：已被领取</span></span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">short</span> award_is_get;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>打算采用的是<code>PlayerPrefs</code>进行持久化储存，虽说这会污染注册表，当时我们将所有任务的数据编写在一个string中，这样产生的影响就会少很多</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">TaskData</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">TaskData</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        m_taskDatas = <span class="keyword">new</span> List&lt;TaskDataItem&gt;();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> List&lt;TaskDataItem&gt; taskDatas</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">get</span> &#123; <span class="keyword">return</span> m_taskDatas; &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 定义存储数据的容器</span></span><br><span class="line">    <span class="keyword">private</span> List&lt;TaskDataItem&gt; m_taskDatas;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 从数据库读取任务数据</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">GetTaskDataFromDB</span>(<span class="params">Action cb</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 正规是与服务端通信，从数据库中读取，这里纯客户端进行模拟，直接使用PlayerPrefs从客户端本地读取</span></span><br><span class="line">        <span class="keyword">var</span> jsonStr = PlayerPrefs.GetString(<span class="string">&quot;TASK_DATA&quot;</span>);</span><br><span class="line">        <span class="keyword">var</span> taskList = JsonMapper.ToObject&lt; List&lt;TaskDataItem&gt; &gt;(jsonStr);</span><br><span class="line">        <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>, cnt = taskList.Count; i &lt; cnt; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            AddOrUpdateData(taskList[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        cb();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取某个任务数据</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> TaskDataItem <span class="title">GetData</span>(<span class="params"><span class="built_in">int</span> chainId, <span class="built_in">int</span> subId</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>, cnt = m_taskDatas.Count; i &lt; cnt; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">var</span> item = m_taskDatas[i];</span><br><span class="line">            <span class="keyword">if</span> (chainId == item.task_chain_id &amp;&amp; subId == item.task_sub_id)</span><br><span class="line">                <span class="keyword">return</span> item;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 添加或更新任务</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">AddOrUpdateData</span>(<span class="params">TaskDataItem itemData</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">bool</span> isUpdate = <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>, cnt = m_taskDatas.Count; i &lt; cnt; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">var</span> item = m_taskDatas[i];</span><br><span class="line">            <span class="keyword">if</span> (itemData.task_chain_id == item.task_chain_id &amp;&amp; itemData.task_sub_id == item.task_sub_id)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">// 更新数据</span></span><br><span class="line">                m_taskDatas[i] = itemData;</span><br><span class="line">                isUpdate = <span class="literal">true</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(!isUpdate)</span><br><span class="line">            m_taskDatas.Add(itemData);</span><br><span class="line">        <span class="comment">// 排序，确保主线在最前面</span></span><br><span class="line">        m_taskDatas.Sort((a, b) =&gt; </span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> a.task_chain_id.CompareTo(b.task_chain_id);</span><br><span class="line">        &#125;);</span><br><span class="line">        SaveDataToDB();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/2022/09/25/unity%E4%BB%BB%E5%8A%A1%E7%B3%BB%E7%BB%9F/image-20220926153721624.png" alt="image-20220926153721624"></p><h1 id="任务逻辑"><a href="#任务逻辑" class="headerlink" title="任务逻辑"></a>任务逻辑</h1><p>使用<code>Action cb</code>回调是为了模拟实际场景中从服务端数据库读取数据（异步）的过程, 仅在客户端交互的情况可以直接忽略</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">TaskLogic</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">TaskLogic</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        m_taskData = <span class="keyword">new</span> TaskData();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 先把TaskData作为成员变量，并提供一个数据属性taskDatas，方便访问</span></span><br><span class="line">    <span class="keyword">private</span> TaskData m_taskData;</span><br><span class="line">    <span class="keyword">public</span> List&lt;TaskDataItem&gt; taskDatas</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">get</span> &#123; <span class="keyword">return</span> m_taskData.taskDatas; &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 获取任务数据</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">GetTaskData</span>(<span class="params">Action cb</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        m_taskData.GetTaskDataFromDB(cb);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 更新任务进度</span></span><br><span class="line">   <span class="comment">// 使用Action&lt;int, bool&gt;回调是为了模拟实际场景中与服务端通信（异步）</span></span><br><span class="line">    <span class="comment">// 处理结果会有个返回码ErrorCode（回调函数第一个参数），客户端需判断ErrorCode的值来进行处理,一般约定ErrorCode为0表示成功</span></span><br><span class="line">    <span class="comment">// 回调函数第二个参数是是否任务进度已达成，如果任务达成，客户端需要显示领奖按钮</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">AddProgress</span>(<span class="params"><span class="built_in">int</span> chainId, <span class="built_in">int</span> subId, <span class="built_in">int</span> deltaProgress, Action&lt;<span class="built_in">int</span>, <span class="built_in">bool</span>&gt; cb</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">var</span> data = m_taskData.GetData(chainId, subId);</span><br><span class="line">        <span class="keyword">if</span> (<span class="literal">null</span> != data)</span><br><span class="line">        &#123;</span><br><span class="line">            data.progress += deltaProgress;</span><br><span class="line">            m_taskData.AddOrUpdateData(data);</span><br><span class="line">            <span class="keyword">var</span> cfg = TaskCfg.instance.GetCfgItem(data.task_chain_id, data.task_sub_id);</span><br><span class="line">            <span class="keyword">if</span> (cfg != <span class="literal">null</span>)</span><br><span class="line">                cb(<span class="number">0</span>, data.progress &gt;= cfg.target_amount);</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                cb(<span class="number">-1</span>, <span class="literal">false</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            cb(<span class="number">-1</span>, <span class="literal">false</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 领取任务奖励，解锁下一系列任务</span></span><br><span class="line">    <span class="comment">// cb用于与服务端交互，解决错误产生原因</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">GetAward</span>(<span class="params"><span class="built_in">int</span> chainId, <span class="built_in">int</span> subId, Action&lt;<span class="built_in">int</span>, <span class="built_in">string</span>&gt; cb</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">var</span> data = m_taskData.GetData(chainId, subId);</span><br><span class="line">        <span class="keyword">if</span> (data == <span class="literal">null</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            cb(<span class="number">-1</span>, <span class="string">&quot;&#123;&#125;&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (data.award_is_get == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            data.award_is_get = <span class="number">1</span>;</span><br><span class="line">            m_taskData.AddOrUpdateData(data);</span><br><span class="line">            GoNext(chainId, subId);</span><br><span class="line">            <span class="keyword">var</span> cfg = TaskCfg.instance.GetCfgItem(data.task_chain_id, data.task_sub_id);</span><br><span class="line">            cb(<span class="number">0</span>, cfg.award);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            cb(<span class="number">-2</span>, <span class="string">&quot;&#123;&#125;&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 开启下一任务</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">GoNext</span>(<span class="params"><span class="built_in">int</span> chainId, <span class="built_in">int</span> subId</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">var</span> data = m_taskData.GetData(chainId, subId);</span><br><span class="line">        <span class="keyword">var</span> cfg = TaskCfg.instance.GetCfgItem(data.task_chain_id, data.task_sub_id);</span><br><span class="line">        <span class="keyword">var</span> nextCfg = TaskCfg.instance.GetCfgItem(data.task_chain_id, data.task_sub_id + <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (data.award_is_get == <span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 移除掉已领奖的任务</span></span><br><span class="line">            m_taskData.RemoveData(chainId, subId);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 开启下一个任务</span></span><br><span class="line">            <span class="keyword">if</span> (nextCfg != <span class="literal">null</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                TaskDataItem dataItem = <span class="keyword">new</span> TaskDataItem();</span><br><span class="line">                dataItem.task_chain_id = nextCfg.task_chain_id;</span><br><span class="line">                dataItem.task_sub_id = nextCfg.task_sub_id;</span><br><span class="line">                dataItem.progress = <span class="number">0</span>;</span><br><span class="line">                dataItem.award_is_get = <span class="number">0</span>;</span><br><span class="line">                m_taskData.AddOrUpdateData(dataItem);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 开启支线任务</span></span><br><span class="line">            <span class="keyword">if</span> (!<span class="built_in">string</span>.IsNullOrEmpty(cfg.open_chain))</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">// 开启新分支</span></span><br><span class="line">                <span class="keyword">var</span> chains = cfg.open_chain.Split(<span class="string">&#x27;,&#x27;</span>);</span><br><span class="line">                <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>, len = chains.Length; i &lt; len; ++i)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">var</span> task = chains[i].Split(<span class="string">&#x27;|&#x27;</span>);</span><br><span class="line">                    </span><br><span class="line">                    <span class="comment">// 更新子任务状态</span></span><br><span class="line">                    TaskDataItem subChainDataItem = <span class="keyword">new</span> TaskDataItem();</span><br><span class="line">                    subChainDataItem.task_chain_id = <span class="built_in">int</span>.Parse(task[<span class="number">0</span>]);</span><br><span class="line">                    subChainDataItem.task_sub_id = <span class="built_in">int</span>.Parse(task[<span class="number">1</span>]);</span><br><span class="line">                    subChainDataItem.progress = <span class="number">0</span>;</span><br><span class="line">                    subChainDataItem.award_is_get = <span class="number">0</span>;</span><br><span class="line">                    m_taskData.AddOrUpdateData(subChainDataItem);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/2022/09/25/unity%E4%BB%BB%E5%8A%A1%E7%B3%BB%E7%BB%9F/image-20220926153704381.png" alt="image-20220926153704381"></p><h1 id="与UI的互动"><a href="#与UI的互动" class="headerlink" title="与UI的互动"></a>与UI的互动</h1><p>与UI互动的关键是问题是，什么时候更新任务数据的问题，又在什么时候根据更新后的数据刷新UI界面</p><p>如果是任务栏这样的弹出式UI界面，那么在OnEnable中可以添加UI更新任务数据的函数，还有种方式是在任务数据的set属性中添加一个订阅者列表，每次任务更新的时候都刷新</p><p>那UI显示任务进度为例子，我们首先需要根据任务ID获取对应的 <code>TaskDataItem</code>，再根据它的属性获取任务进度就可以了</p>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;读取策划配置表&quot;&gt;&lt;a href=&quot;#读取策划配置表&quot; class=&quot;headerlink&quot; title=&quot;读取策划配置表&quot;&gt;&lt;/a&gt;读取策划配置表&lt;/h1&gt;&lt;p&gt;一般策划都是通过EXCEL来配置，如下图所示：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/2022/09/25/unity%E4%BB%BB%E5%8A%A1%E7%B3%BB%E7%BB%9F/image-20220925124533325.png&quot; alt=&quot;image-20220925124533325&quot;&gt;&lt;/p&gt;
&lt;h2 id=&quot;Unity读取EXCEL&quot;&gt;&lt;a href=&quot;#Unity读取EXCEL&quot; class=&quot;headerlink&quot; title=&quot;Unity读取EXCEL&quot;&gt;&lt;/a&gt;Unity读取EXCEL&lt;/h2&gt;&lt;p&gt;游戏中并不是直接读取&lt;code&gt;Excel&lt;/code&gt;配置，实际项目中一般都是将&lt;code&gt;Excel&lt;/code&gt;转为&lt;code&gt;xml&lt;/code&gt;、&lt;code&gt;json&lt;/code&gt;、&lt;code&gt;lua&lt;/code&gt;或自定义的文本格式的配置，这样不会让Excel打包时占据额外空间。&lt;/p&gt;
&lt;p&gt;对于 &lt;code&gt;Json&lt;/code&gt;格式，在 &lt;code&gt;Excel&lt;/code&gt;中能够安装额外的插件，直接导出为 &lt;code&gt;Json&lt;/code&gt;格式，当然也可以用 &lt;code&gt;Python&lt;/code&gt;批量化处理，这里不赘述&lt;/p&gt;</summary>
    
    
    
    
    <category term="Unity" scheme="https://ycy666666.github.io/tags/Unity/"/>
    
  </entry>
  
</feed>
